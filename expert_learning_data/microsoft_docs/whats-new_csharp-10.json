{
  "url": "https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10",
  "title": "The history of C#",
  "topic": "whats-new/csharp-10",
  "content": "Table of contents\nExit focus mode\nAsk Learn\nAsk Learn\nTable of contents\nRead in English\nAdd\nAdd to plan\nEdit\nShare via\nFacebook\nx.com\nLinkedIn\nEmail\nPrint\nNote\nAccess to this page requires authorization. You can try\nsigning in\nor\nchanging directories\n.\nAccess to this page requires authorization. You can try\nchanging directories\n.\nThe history of C#\n2024-12-22\nFeedback\nIn this article\nThis article provides a history of each major release of the C# language. The C# team is continuing to innovate and add new features. Detailed language feature status, including features considered for upcoming releases can be found\non the dotnet/roslyn repository\non GitHub. To find when a particular feature was added to the language, consult the\nC# version history\nfile in the\ndotnet/csharplang\nrepository on GitHub.\nImportant\nThe C# language relies on types and methods in what the C# specification defines as a\nstandard library\nfor some of the features. The .NET platform delivers those types and methods in a number of packages. One example is exception processing. Every\nthrow\nstatement or expression is checked to ensure the object being thrown is derived from\nException\n. Similarly, every\ncatch\nis checked to ensure that the type being caught is derived from\nException\n. Each version may add new requirements. To use the latest language features in older environments, you may need to install specific libraries. These dependencies are documented in the page for each specific version. You can learn more about the\nrelationships between language and library\nfor background on this dependency.\nC# version 13\nReleased November 2024\nC# 13 includes the following new features:\nparams\ncollections: the\nparams\nmodifier isn't limited to array types. You can now use\nparams\nwith any recognized collection type, including\nSpan<T>\n, and interface types.\nNew\nlock\ntype and semantics: If the target of a\nlock\nstatement is a\nSystem.Threading.Lock\n, compiler generates code to use the\nLock.EnterScope()\nmethod to enter an exclusive scope. The\nref struct\nreturned from that supports the\nDispose()\npattern to exit the exclusive scope.\nNew escape sequence -\n\\e\n: You can use\n\\e\nas a character literal escape sequence for the\nESCAPE\ncharacter, Unicode\nU+001B\n.\nSmall optimizations to overload resolution involving method groups.\nImplicit indexer access in object initializers: The implicit \"from the end\" index operator,\n^\n, is now allowed in an object initializer expression.\nYou can use\nref\nlocals and\nunsafe\ncontexts in iterators and async methods.\nYou can use\nref struct\ntypes to implement interfaces.\nYou can allow\nref struct\ntypes as arguments for type parameters in generics.\nPartial properties and indexers are now allowed in\npartial\ntypes.\nOverload resolution priority allows library authors to designate one overload as better than others.\nAnd, the\nfield\ncontextual keyword to access the compiler generated backing field in an automatically implemented property was released as a preview feature.\nC# version 12\nReleased November 2023\nThe following features were added in C# 12:\nPrimary constructors\n- You can create primary constructors in any\nclass\nor\nstruct\ntype.\nCollection expressions\n- A new syntax to specify collection expressions, including the spread element, (\n..e\n), to expand any collection.\nInline arrays\n- Inline arrays enable you to create an array of fixed size in a\nstruct\ntype.\nOptional parameters in lambda expressions\n- You can define default values for parameters on lambda expressions.\nref readonly\nparameters\n-\nref readonly\nparameters enables more clarity for APIs that might be using\nref\nparameters or\nin\nparameters.\nAlias any type\n- You can use the\nusing\nalias directive to alias any type, not just named types.\nExperimental attribute\n- Indicate an experimental feature.\nAnd,\nInterceptors\n- was released as a\nPreview feature\n.\nOverall, C# 12 provides new features that make you more productive writing C# code. Syntax you already knew is available in more places. Other syntax enables consistency for related concepts.\nC# version 11\nReleased November 2022\nThe following features were added in C# 11:\nRaw string literals\nGeneric math support\nGeneric attributes\nUTF-8 string literals\nNewlines in string interpolation expressions\nList patterns\nFile-local types\nRequired members\nAuto-default structs\nPattern match\nSpan<char>\non a constant\nstring\nExtended\nnameof\nscope\nNumeric IntPtr\nref\nfields and\nscoped ref\nImproved method group conversion to delegate\nWarning wave 7\nC# 11 introduces\ngeneric math\nand several features that support that goal. You can write numeric algorithms once for all number types. There's more features to make working with\nstruct\ntypes easier, like required members and auto-default structs. Working with strings gets easier with Raw string literals, newline in string interpolations, and UTF-8 string literals. Features like file local types enable source generators to be simpler. Finally, list patterns add more support for pattern matching.\nC# version 10\nReleased November 2021\nC# 10 adds the following features and enhancements to the C# language:\nRecord structs\nImprovements of structure types\nInterpolated string handlers\nglobal using\ndirectives\nFile-scoped namespace declaration\nExtended property patterns\nLambda expressions can have a\nnatural type\n, where the compiler can infer a delegate type from the lambda expression or method group.\nLambda expressions can declare a\nreturn type\nwhen the compiler can't infer it.\nAttributes\ncan be applied to lambda expressions.\nIn C# 10,\nconst\nstrings can be initialized using\nstring interpolation\nif all the placeholders are themselves constant strings.\nIn C# 10, you can add the\nsealed\nmodifier when you override\nToString\nin a\nrecord\ntype.\nWarnings for definite assignment and null-state analysis are more accurate.\nAllow both assignment and declaration in the same deconstruction.\nAllow\nAsyncMethodBuilder\nattribute on methods\nCallerArgumentExpression attribute\nC# 10 supports a new format for the\n#line\npragma.\nMore features were available in\npreview\nmode. In order to use these features, you must\nset\n<LangVersion>\nto\nPreview\nin your project:\nGeneric attributes\nlater in this article.\nstatic abstract members in interfaces\n.\nC# 10 continues work on themes of removing ceremony, separating data from algorithms, and improved performance for the .NET Runtime.\nMany of the features mean you type less code to express the same concepts.\nRecord structs\nsynthesize many of the same methods that\nrecord classes\ndo. Structs and anonymous types support\nwith expressions\n.\nGlobal using directives\nand\nfile scoped namespace declarations\nmean you express dependencies and namespace organization more clearly.\nLambda improvements\nmake it easier to declare lambda expressions where they're used. New property patterns and deconstruction improvements create more concise code.\nThe new interpolated string handlers and\nAsyncMethodBuilder\nbehavior can improve performance. These language features were applied in the .NET Runtime to achieve performance improvements in .NET 6.\nC# 10 also marks more of a shift to the yearly cadence for .NET releases. Because not every feature can be completed in a yearly timeframe, you can try a couple of \"preview\" features in C# 10. Both\ngeneric attributes\nand\nstatic abstract members in interfaces\ncan be used, but these preview features might change before their final release.\nC# version 9\nReleased November 2020\nC# 9 was released with .NET 5. It's the default language version for any assembly that targets the .NET 5 release. It contains the following new and enhanced features:\nRecords\nInit only setters\nTop-level statements\nPattern matching enhancements:\nrelational patterns\nand\nlogical patterns\nPerformance and interop\nNative sized integers\nFunction pointers\nSuppress emitting localsinit flag\nModule initializers\nNew features for partial methods\nFit and finish features\nTarget-typed\nnew\nexpressions\nstatic\nanonymous functions\nTarget-typed conditional expressions\nCovariant return types\nExtension\nGetEnumerator\nsupport for\nforeach\nloops\nLambda discard parameters\nAttributes on local functions\nC# 9 continues three of the themes from previous releases: removing ceremony, separating data from algorithms, and providing more patterns in more places.\nTop level statements\nmeans your main program is simpler to read. There's less need for ceremony: a namespace, a\nProgram\nclass, and\nstatic void Main()\nare all unnecessary.\nThe introduction of\nrecords\nprovides a concise syntax for reference types that follow value semantics for equality. You use these types to define data containers that typically define minimal behavior.\nInit-only setters\nprovide the capability for nondestructive mutation (\nwith\nexpressions) in records. C# 9 also adds\ncovariant return types\nso that derived records can override virtual methods and return a type derived from the base method's return type.\nThe\npattern matching\ncapabilities expanded in several ways. Numeric types now support\nrange patterns\n. Patterns can be combined using\nand\n,\nor\n, and\nnot\npatterns. Parentheses can be added to clarify more complex patterns:\nC# 9 includes new pattern matching improvements:\nType patterns\nmatch an object matches a particular type\nParenthesized patterns\nenforce or emphasize the precedence of pattern combinations\nConjunctive\nand\npatterns\nrequire both patterns to match\nDisjunctive\nor\npatterns\nrequire either pattern to match\nNegated\nnot\npatterns\nrequire that a pattern doesn't match\nRelational patterns\nrequire the input be less than, greater than, less than or equal, or greater than or equal to a given constant\nThese patterns enrich the syntax for patterns. One of the most common uses is a new syntax for a null check:\nif (e is not null)\n{\n    // ...\n}\nAny of these patterns can be used in any context where patterns are allowed:\nis\npattern expressions,\nswitch\nexpressions, nested patterns, and the pattern of a\nswitch\nstatement's\ncase\nlabel.\nAnother set of features supports high-performance computing in C#:\nThe\nnint\nand\nnuint\ntypes model the native-size integer types on the target CPU.\nFunction pointers\nprovide delegate-like functionality while avoiding the allocations necessary to create a delegate object.\nThe\nlocalsinit\ninstruction can be omitted to save instructions.\nPerformance and interop\nAnother set of improvements supports scenarios where\ncode generators\nadd functionality:\nModule initializers\nare methods that the runtime calls when an assembly loads.\nPartial methods\nsupport new accessibly modifiers and non-void return types. In those cases, an implementation must be provided.\nFit and finish features\nC# 9 adds many other small features that improve developer productivity, both writing and reading code:\nTarget-type\nnew\nexpressions\nstatic\nanonymous functions\nTarget-type conditional expressions\nExtension\nGetEnumerator()\nsupport for\nforeach\nloops\nLambda expressions can declare discard parameters\nAttributes can be applied to local functions\nThe C# 9 release continues the work to keep C# a modern, general-purpose programming language. Features continue to support modern workloads and application types.\nC# version 8.0\nReleased September 2019\nC# 8.0 is the first major C# release that specifically targets .NET Core. Some features rely on new Common Language Runtime (CLR) capabilities, others on library types added only in .NET Core. C# 8.0 adds the following features and enhancements to the C# language:\nReadonly members\nDefault interface methods\nPattern matching enhancements\n:\nSwitch expressions\nProperty patterns\nTuple patterns\nPositional patterns\nUsing declarations\nStatic local functions\nDisposable ref structs\nNullable reference types\nAsynchronous streams\nIndices and ranges\nNull-coalescing assignment\nUnmanaged constructed types\nStackalloc in nested expressions\nEnhancement of interpolated verbatim strings\nDefault interface members require enhancements in the CLR. Those features were added in the CLR for .NET Core 3.0. Ranges and indexes, and asynchronous streams require new types in the .NET Core 3.0 libraries. Nullable reference types, while implemented in the compiler, is much more useful when libraries are annotated to provide semantic information regarding the null state of arguments and return values. Those annotations are being added in the .NET Core libraries.\nC# version 7.3\nReleased May 2018\nThere are two main themes to the C# 7.3 release. One theme provides features that enable safe code to be as performant as unsafe code. The second theme provides incremental improvements to existing features. New compiler options were also added in this release.\nThe following new features support the theme of better performance for safe code:\nYou can access fixed fields without pinning.\nYou can reassign\nref\nlocal variables.\nYou can use initializers on\nstackalloc\narrays.\nYou can use\nfixed\nstatements with any type that supports a pattern.\nYou can use more generic constraints.\nThe following enhancements were made to existing features:\nYou can test\n==\nand\n!=\nwith tuple types.\nYou can use expression variables in more locations.\nYou can attach attributes to the backing field of automatically implemented properties.\nMethod resolution when arguments differ by\nin\nwas improved.\nOverload resolution now has fewer ambiguous cases.\nThe new compiler options are:\n-publicsign\nto enable Open Source Software (OSS) signing of assemblies.\n-pathmap\nto provide a mapping for source directories.\nC# version 7.2\nReleased November 2017\nC# 7.2 added several small language features:\nInitializers on\nstackalloc\narrays.\nUse\nfixed\nstatements with any type that supports a pattern.\nAccess fixed fields without pinning.\nReassign\nref\nlocal variables.\nDeclare\nreadonly struct\ntypes, to indicate that a struct is immutable and should be passed as an\nin\nparameter to its member methods.\nAdd the\nin\nmodifier on parameters, to specify that an argument is passed by reference but not modified by the called method.\nUse the\nref readonly\nmodifier on method returns, to indicate that a method returns its value by reference but doesn't allow writes to that object.\nDeclare\nref struct\ntypes, to indicate that a struct type accesses managed memory directly and must always be stack allocated.\nUse more generic constraints.\nNon-trailing named arguments\n:\nPositional arguments can follow named arguments.\nLeading underscores in numeric literals:\nNumeric literals can now have leading underscores before any printed digits.\nprivate protected\naccess modifier\n:\nThe\nprivate protected\naccess modifier enables access for derived classes in the same assembly.\nConditional\nref\nexpressions:\nThe result of a conditional expression (\n?:\n) can now be a reference.\nC# version 7.1\nReleased August 2017\nC# started releasing\npoint releases\nwith C# 7.1. This version added the\nlanguage version selection\nconfiguration element, three new language features, and new compiler behavior.\nThe new language features in this release are:\nasync\nMain\nmethod\nThe entry point for an application can have the\nasync\nmodifier.\ndefault\nliteral expressions\nYou can use default literal expressions in default value expressions when the target type can be inferred.\nInferred tuple element names\nThe names of tuple elements can be inferred from tuple initialization in many cases.\nPattern matching on generic type parameters\nYou can use pattern match expressions on variables whose type is a generic type parameter.\nFinally, the compiler has two options\n-refout\nand\n-refonly\nthat\ncontrol reference assembly generation.\nC# version 7.0\nReleased March 2017\nC# version 7.0 was released with Visual Studio 2017. This version has some evolutionary and cool stuff in the vein of C# 6.0. Here are some of the new features:\nOut variables\nTuples and deconstruction\nPattern matching\nLocal functions\nExpanded expression bodied members\nRef locals\nRef returns\nOther features included:\nDiscards\nBinary Literals and Digit Separators\nThrow expressions\nAll of these features offer new capabilities for developers and the opportunity to write cleaner code than ever. A highlight is condensing the declaration of variables to use with the\nout\nkeyword and by allowing multiple return values via tuple. .NET Core now targets any operating system and has its eyes firmly on the cloud and on portability. These new capabilities certainly occupy the language designers' thoughts and time, in addition to coming up with new features.\nC# version 6.0\nReleased July 2015\nVersion 6.0, released with Visual Studio 2015, released many smaller features that made C# programming more productive. Here are some of them:\nStatic imports\nException filters\nAuto-property initializers\nExpression bodied members\nNull propagator\nString interpolation\nnameof operator\nOther new features include:\nIndex initializers\nAwait in catch/finally blocks\nDefault values for getter-only properties\nIf you look at these features together, you see an interesting pattern. In this version, C# started to eliminate language boilerplate to make code more terse and readable. So for fans of clean, simple code, this language version was a huge win.\nThey did one other thing along with this version, though it's not a traditional language feature in itself. They released\nRoslyn the compiler as a service\n. The C# compiler is now written in C#, and you can use the compiler as part of your programming efforts.\nC# version 5.0\nReleased August 2012\nC# version 5.0, released with Visual Studio 2012, was a focused version of the language. Nearly all of the effort for that version went into another groundbreaking language concept: the\nasync\nand\nawait\nmodel for asynchronous programming. Here's the major features list:\nAsynchronous members\nCaller info attributes\nThe caller info attribute lets you easily retrieve information about the context in which you're running without resorting to a ton of boilerplate reflection code. It has many uses in diagnostics and logging tasks.\nBut\nasync\nand\nawait\nare the real stars of this release. When these features came out in 2012, C# changed the game again by baking asynchrony into the language as a first-class participant.\nC# version 4.0\nReleased April 2010\nC# version 4.0, released with Visual Studio 2010, introduced some interesting new features:\nDynamic binding\nNamed/optional arguments\nGeneric covariant and contravariant\nEmbedded interop types\nEmbedded interop types eased the deployment pain of creating COM interop assemblies for your application. Generic covariance and contravariance give you more power to use generics, but they're a bit academic and probably most appreciated by framework and library authors. Named and optional parameters let you eliminate many method overloads and provide convenience. But none of those features are exactly paradigm altering.\nThe major feature was the introduction of the\ndynamic\nkeyword. The\ndynamic\nkeyword introduced into C# version 4.0 the ability to override the compiler on compile-time typing. By using the dynamic keyword, you can create constructs similar to dynamically typed languages like JavaScript. You can create a\ndynamic x = \"a string\"\nand then add six to it, leaving it up to the runtime to sort out what should happen next.\nDynamic binding gives you the potential for errors but also great power within the language.\nC# version 3.0\nReleased November 2007\nC# version 3.0 came in late 2007, along with Visual Studio 2008, though the full boat of language features would actually come with .NET Framework version 3.5. This version marked a major change in the growth of C#. It established C# as a truly formidable programming language. Let's take a look at some major features in this version:\nAuto-implemented properties\nAnonymous types\nQuery expressions\nLambda expressions\nExpression trees\nExtension methods\nImplicitly typed local variables\nPartial methods\nObject and collection initializers\nIn retrospect, many of these features seem both inevitable and inseparable. They all fit together strategically. This C# version's killer feature was the query expression, also known as Language-Integrated Query (LINQ).\nA more nuanced view examines expression trees, lambda expressions, and anonymous types as the foundation upon which LINQ is constructed. But, in either case, C# 3.0 presented a revolutionary concept. C# 3.0 began to lay the groundwork for turning C# into a hybrid Object-Oriented / Functional language.\nSpecifically, you could now write SQL-style, declarative queries to perform operations on collections, among other things. Instead of writing a\nfor\nloop to compute the average of a list of integers, you could now do that as simply as\nlist.Average()\n. The combination of query expressions and extension methods made a list of integers a whole lot smarter.\nC# version 2.0\nReleased November 2005\nLet's take a look at some major features of C# 2.0, released in 2005, along with Visual Studio 2005:\nGenerics\nPartial types\nAnonymous methods\nNullable value types\nIterators\nCovariance and contravariance\nOther C# 2.0 features added capabilities to existing features:\nGetter/setter separate accessibility\nMethod group conversions (delegates)\nStatic classes\nDelegate inference\nWhile C# began as a generic Object-Oriented (OO) language, C# version 2.0 changed that in a hurry. With generics, types and methods can operate on an arbitrary type while still retaining type safety. For instance, having a\nList<T>\nlets you have\nList<string>\nor\nList<int>\nand perform type-safe operations on those strings or integers while you iterate through them. Using generics is better than creating a\nListInt\ntype that derives from\nArrayList\nor casting from\nObject\nfor every operation.\nC# version 2.0 brought iterators. To put it succinctly, iterators let you examine all the items in a\nList\n(or other Enumerable types) with a\nforeach\nloop. Having iterators as a first-class part of the language dramatically enhanced readability of the language and people's ability to reason about the code.\nC# version 1.2\nReleased April 2003\nC# version 1.2 shipped with Visual Studio .NET 2003. It contained a few small enhancements to the language. Most notable is that starting with this version, the code generated in a\nforeach\nloop called\nDispose\non an\nIEnumerator\nwhen that\nIEnumerator\nimplemented\nIDisposable\n.\nC# version 1.0\nReleased January 2002\nWhen you go back and look, C# version 1.0, released with Visual Studio .NET 2002, looked a lot like Java. As\npart of its stated design goals for ECMA\n, it sought to be a \"simple, modern, general-purpose object-oriented language.\" At the time, looking like Java meant it achieved those early design goals.\nBut if you look back on C# 1.0 now, you'd find yourself a little dizzy. It lacked the built-in async capabilities and some of the slick functionality around generics you take for granted. As a matter of fact, it lacked generics altogether. And\nLINQ\n? Not available yet. Those additions would take some years to come out.\nC# version 1.0 looked stripped of features, compared to today. You'd find yourself writing some verbose code. But yet, you have to start somewhere. C# version 1.0 was a viable alternative to Java on the Windows platform.\nThe major features of C# 1.0 included:\nClasses\nStructs\nInterfaces\nEvents\nProperties\nDelegates\nOperators and expressions\nStatements\nAttributes\nArticle\noriginally published on the NDepend blog\n, courtesy of Erik Dietrich and Patrick Smacchia.\nCollaborate with us on GitHub\nThe source for this content can be found on GitHub, where you can also create and review issues and pull requests. For more information, see\nour contributor guide\n.\n.NET\nOpen a documentation issue\nProvide product feedback\nAdditional resources",
  "code_samples": [],
  "collected_at": "2025-06-27T01:19:09.090160"
}