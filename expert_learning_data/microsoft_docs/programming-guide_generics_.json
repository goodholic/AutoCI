{
  "url": "https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/",
  "title": "Generic classes and methods",
  "topic": "programming-guide/generics/",
  "content": "Table of contents\nExit focus mode\nAsk Learn\nAsk Learn\nTable of contents\nRead in English\nAdd\nAdd to plan\nEdit\nShare via\nFacebook\nx.com\nLinkedIn\nEmail\nPrint\nNote\nAccess to this page requires authorization. You can try\nsigning in\nor\nchanging directories\n.\nAccess to this page requires authorization. You can try\nchanging directories\n.\nGeneric classes and methods\n2024-03-19\nFeedback\nIn this article\nGenerics introduces the concept of type parameters to .NET. Generics make it possible to design classes and methods that defer the specification of one or more type parameters until you use the class or method in your code. For example, by using a generic type parameter\nT\n, you can write a single class that other client code can use without incurring the cost or risk of runtime casts or boxing operations, as shown here:\n// Declare the generic class.\npublic class GenericList<T>\n{\n    public void Add(T item) { }\n}\n\npublic class ExampleClass { }\n\nclass TestGenericList\n{\n    static void Main()\n    {\n        // Create a list of type int.\n        GenericList<int> list1 = new();\n        list1.Add(1);\n\n        // Create a list of type string.\n        GenericList<string> list2 = new();\n        list2.Add(\"\");\n\n        // Create a list of type ExampleClass.\n        GenericList<ExampleClass> list3 = new();\n        list3.Add(new ExampleClass());\n    }\n}\nGeneric classes and methods combine reusability, type safety, and efficiency in a way that their nongeneric counterparts can't. Generic type parameters are replaced with the type arguments during compilation. In the preceding example, the compiler replaces\nT\nwith\nint\n. Generics are most frequently used with collections and the methods that operate on them. The\nSystem.Collections.Generic\nnamespace contains several generic-based collection classes. The nongeneric collections, such as\nArrayList\naren't recommended and are maintained only for compatibility purposes. For more information, see\nGenerics in .NET\n.\nYou can also create custom generic types and methods to provide your own generalized solutions and design patterns that are type-safe and efficient. The following code example shows a simple generic linked-list class for demonstration purposes. (In most cases, you should use the\nList<T>\nclass provided by .NET instead of creating your own.) The type parameter\nT\nis used in several locations where a concrete type would ordinarily be used to indicate the type of the item stored in the list:\nAs the type of a method parameter in the\nAddHead\nmethod.\nAs the return type of the\nData\nproperty in the nested\nNode\nclass.\nAs the type of the private member\ndata\nin the nested class.\nT\nis available to the nested\nNode\nclass. When\nGenericList<T>\nis instantiated with a concrete type, for example as a\nGenericList<int>\n, each occurrence of\nT\nis replaced with\nint\n.\n// Type parameter T in angle brackets.\npublic class GenericList<T>\n{\n    // The nested class is also generic, and\n    // holds a data item of type T.\n    private class Node(T t)\n    {\n        // T as property type.\n        public T Data { get; set; } = t;\n\n        public Node? Next { get; set; }\n    }\n\n    // First item in the linked list\n    private Node? head;\n\n    // T as parameter type.\n    public void AddHead(T t)\n    {\n        Node n = new(t);\n        n.Next = head;\n        head = n;\n    }\n\n    // T in method return type.\n    public IEnumerator<T> GetEnumerator()\n    {\n        Node? current = head;\n\n        while (current is not null)\n        {\n            yield return current.Data;\n            current = current.Next;\n        }\n    }\n}\nThe following code example shows how client code uses the generic\nGenericList<T>\nclass to create a list of integers. If you change the type argument, the following code creates lists of strings or any other custom type:\n// A generic list of int.\nGenericList<int> list = new();\n\n// Add ten int values.\nfor (int x = 0; x < 10; x++)\n{\n    list.AddHead(x);\n}\n\n// Write them to the console.\nforeach (int i in list)\n{\n    Console.WriteLine(i);\n}\n\nConsole.WriteLine(\"Done\");\nNote\nGeneric types aren't limited to classes. The preceding examples use\nclass\ntypes, but you can define generic\ninterface\nand\nstruct\ntypes, including\nrecord\ntypes.\nGenerics overview\nUse generic types to maximize code reuse, type safety, and performance.\nThe most common use of generics is to create collection classes.\nThe .NET class library contains several generic collection classes in the\nSystem.Collections.Generic\nnamespace. The generic collections should be used whenever possible instead of classes such as\nArrayList\nin the\nSystem.Collections\nnamespace.\nYou can create your own generic interfaces, classes, methods, events, and delegates.\nGeneric classes can be constrained to enable access to methods on particular data types.\nYou can obtain information at run time on the types that are used in a generic data type by using reflection.\nC# language specification\nFor more information, see the\nC# Language Specification\n.\nSee also\nGenerics in .NET\nSystem.Collections.Generic\nCollaborate with us on GitHub\nThe source for this content can be found on GitHub, where you can also create and review issues and pull requests. For more information, see\nour contributor guide\n.\n.NET\nOpen a documentation issue\nProvide product feedback\nAdditional resources",
  "code_samples": [
    {
      "language": "csharp",
      "code": "// Declare the generic class.\npublic class GenericList<T>\n{\n    public void Add(T item) { }\n}\n\npublic class ExampleClass { }\n\nclass TestGenericList\n{\n    static void Main()\n    {\n        // Create a list of type int.\n        GenericList<int> list1 = new();\n        list1.Add(1);\n\n        // Create a list of type string.\n        GenericList<string> list2 = new();\n        list2.Add(\"\");\n\n        // Create a list of type ExampleClass.\n        GenericList<ExampleClass> list3 = new();\n        list3.Add(new ExampleClass());\n    }\n}",
      "lines": 25
    },
    {
      "language": "csharp",
      "code": "// Declare the generic class.\npublic class GenericList<T>\n{\n    public void Add(T item) { }\n}\n\npublic class ExampleClass { }\n\nclass TestGenericList\n{\n    static void Main()\n    {\n        // Create a list of type int.\n        GenericList<int> list1 = new();\n        list1.Add(1);\n\n        // Create a list of type string.\n        GenericList<string> list2 = new();\n        list2.Add(\"\");\n\n        // Create a list of type ExampleClass.\n        GenericList<ExampleClass> list3 = new();\n        list3.Add(new ExampleClass());\n    }\n}",
      "lines": 25
    },
    {
      "language": "csharp",
      "code": "// Type parameter T in angle brackets.\npublic class GenericList<T>\n{\n    // The nested class is also generic, and\n    // holds a data item of type T.\n    private class Node(T t)\n    {\n        // T as property type.\n        public T Data { get; set; } = t;\n\n        public Node? Next { get; set; }\n    }\n\n    // First item in the linked list\n    private Node? head;\n\n    // T as parameter type.\n    public void AddHead(T t)\n    {\n        Node n = new(t);\n        n.Next = head;\n        head = n;\n    }\n\n    // T in method return type.\n    public IEnumerator<T> GetEnumerator()\n    {\n        Node? current = head;\n\n        while (current is not null)\n        {\n            yield return current.Data;\n            current = current.Next;\n        }\n    }\n}",
      "lines": 36
    },
    {
      "language": "csharp",
      "code": "// Type parameter T in angle brackets.\npublic class GenericList<T>\n{\n    // The nested class is also generic, and\n    // holds a data item of type T.\n    private class Node(T t)\n    {\n        // T as property type.\n        public T Data { get; set; } = t;\n\n        public Node? Next { get; set; }\n    }\n\n    // First item in the linked list\n    private Node? head;\n\n    // T as parameter type.\n    public void AddHead(T t)\n    {\n        Node n = new(t);\n        n.Next = head;\n        head = n;\n    }\n\n    // T in method return type.\n    public IEnumerator<T> GetEnumerator()\n    {\n        Node? current = head;\n\n        while (current is not null)\n        {\n            yield return current.Data;\n            current = current.Next;\n        }\n    }\n}",
      "lines": 36
    },
    {
      "language": "csharp",
      "code": "// A generic list of int.\nGenericList<int> list = new();\n\n// Add ten int values.\nfor (int x = 0; x < 10; x++)\n{\n    list.AddHead(x);\n}\n\n// Write them to the console.\nforeach (int i in list)\n{\n    Console.WriteLine(i);\n}\n\nConsole.WriteLine(\"Done\");",
      "lines": 16
    },
    {
      "language": "csharp",
      "code": "// A generic list of int.\nGenericList<int> list = new();\n\n// Add ten int values.\nfor (int x = 0; x < 10; x++)\n{\n    list.AddHead(x);\n}\n\n// Write them to the console.\nforeach (int i in list)\n{\n    Console.WriteLine(i);\n}\n\nConsole.WriteLine(\"Done\");",
      "lines": 16
    }
  ],
  "collected_at": "2025-06-27T01:19:04.366354"
}