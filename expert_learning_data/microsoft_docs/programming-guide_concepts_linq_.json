{
  "url": "https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/",
  "title": "Language Integrated Query (LINQ)",
  "topic": "programming-guide/concepts/linq/",
  "content": "Table of contents\nExit focus mode\nAsk Learn\nAsk Learn\nTable of contents\nRead in English\nAdd\nAdd to plan\nEdit\nShare via\nFacebook\nx.com\nLinkedIn\nEmail\nPrint\nNote\nAccess to this page requires authorization. You can try\nsigning in\nor\nchanging directories\n.\nAccess to this page requires authorization. You can try\nchanging directories\n.\nLanguage Integrated Query (LINQ)\n2023-12-15\nFeedback\nIn this article\nLanguage-Integrated Query (LINQ) is the name for a set of technologies based on the integration of query capabilities directly into the C# language. Traditionally, queries against data are expressed as simple strings without type checking at compile time or IntelliSense support. Furthermore, you have to learn a different query language for each type of data source: SQL databases, XML documents, various Web services, and so on. With LINQ, a query is a first-class language construct, just like classes, methods, and events.\nWhen you write queries, the most visible \"language-integrated\" part of LINQ is the query expression. Query expressions are written in a declarative\nquery syntax\n. By using query syntax, you perform filtering, ordering, and grouping operations on data sources with a minimum of code. You use the same query expression patterns to query and transform data from any type of data source.\nThe following example shows a complete query operation. The complete operation includes creating a data source, defining the query expression, and executing the query in a\nforeach\nstatement.\n// Specify the data source.\nint[] scores = [97, 92, 81, 60];\n\n// Define the query expression.\nIEnumerable<int> scoreQuery =\n    from score in scores\n    where score > 80\n    select score;\n\n// Execute the query.\nforeach (var i in scoreQuery)\n{\n    Console.Write(i + \" \");\n}\n\n// Output: 97 92 81\nYou might need to add a\nusing\ndirective,\nusing System.Linq;\n, for the preceding example to compile. The most recent versions of .NET make use of\nimplicit usings\nto add this directive as a\nglobal using\n. Older versions require you to add it in your source.\nQuery expression overview\nQuery expressions query and transform data from any LINQ-enabled data source. For example, a single query can retrieve data from an SQL database and produce an XML stream as output.\nQuery expressions use many familiar C# language constructs, which make them easy to read.\nThe variables in a query expression are all strongly typed.\nA query isn't executed until you iterate over the query variable, for example in a\nforeach\nstatement.\nAt compile time, query expressions are converted to standard query operator method calls according to the rules defined in the C# specification. Any query that can be expressed by using query syntax can also be expressed by using method syntax. In some cases, query syntax is more readable and concise. In others, method syntax is more readable. There's no semantic or performance difference between the two different forms. For more information, see\nC# language specification\nand\nStandard query operators overview\n.\nSome query operations, such as\nCount\nor\nMax\n, have no equivalent query expression clause and must therefore be expressed as a method call. Method syntax can be combined with query syntax in various ways.\nQuery expressions can be compiled to expression trees or to delegates, depending on the type that the query is applied to.\nIEnumerable<T>\nqueries are compiled to delegates.\nIQueryable\nand\nIQueryable<T>\nqueries are compiled to expression trees. For more information, see\nExpression trees\n.\nHow to enable LINQ querying of your data source\nIn-memory data\nThere are two ways you enable LINQ querying of in-memory data. If the data is of a type that implements\nIEnumerable<T>\n, you query the data by using LINQ to Objects. If it doesn't make sense to enable enumeration by implementing the\nIEnumerable<T>\ninterface, you define LINQ standard query operator methods, either in that type or as\nextension methods\nfor that type. Custom implementations of the standard query operators should use deferred execution to return the results.\nRemote data\nThe best option for enabling LINQ querying of a remote data source is to implement the\nIQueryable<T>\ninterface.\nIQueryable LINQ providers\nLINQ providers that implement\nIQueryable<T>\ncan vary widely in their complexity.\nA less complex\nIQueryable\nprovider might access a single method from a Web service. This type of provider is very specific because it expects specific information in the queries that it handles. It has a closed type system, perhaps exposing a single result type. Most of the execution of the query occurs locally, for example by using the\nEnumerable\nimplementations of the standard query operators. A less complex provider might examine only one method call expression in the expression tree that represents the query, and let the remaining logic of the query be handled elsewhere.\nAn\nIQueryable\nprovider of medium complexity might target a data source that has a partially expressive query language. If it targets a Web service, it might access more than one method of the Web service and select which method to call based on the information that the query seeks. A provider of medium complexity would have a richer type system than a simple provider, but it would still be a fixed type system. For example, the provider might expose types that have one-to-many relationships that can be traversed, but it wouldn't provide mapping technology for user-defined types.\nA complex\nIQueryable\nprovider, such as the\nEntity Framework Core\nprovider, might translate complete LINQ queries to an expressive query language, such as SQL. A complex provider is more general because it can handle a wider variety of questions in the query. It also has an open type system and therefore must contain extensive infrastructure to map user-defined types. Developing a complex provider requires a significant amount of effort.\nCollaborate with us on GitHub\nThe source for this content can be found on GitHub, where you can also create and review issues and pull requests. For more information, see\nour contributor guide\n.\n.NET\nOpen a documentation issue\nProvide product feedback\nAdditional resources",
  "code_samples": [
    {
      "language": "csharp",
      "code": "// Specify the data source.\nint[] scores = [97, 92, 81, 60];\n\n// Define the query expression.\nIEnumerable<int> scoreQuery =\n    from score in scores\n    where score > 80\n    select score;\n\n// Execute the query.\nforeach (var i in scoreQuery)\n{\n    Console.Write(i + \" \");\n}\n\n// Output: 97 92 81",
      "lines": 16
    },
    {
      "language": "csharp",
      "code": "// Specify the data source.\nint[] scores = [97, 92, 81, 60];\n\n// Define the query expression.\nIEnumerable<int> scoreQuery =\n    from score in scores\n    where score > 80\n    select score;\n\n// Execute the query.\nforeach (var i in scoreQuery)\n{\n    Console.Write(i + \" \");\n}\n\n// Output: 97 92 81",
      "lines": 16
    }
  ],
  "collected_at": "2025-06-27T01:19:02.649695"
}