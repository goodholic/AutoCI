{
  "url": "https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/pattern-matching",
  "title": "Tutorial: Use pattern matching to build type-driven and data-driven algorithms",
  "topic": "tutorials/pattern-matching",
  "content": "Table of contents\nExit focus mode\nAsk Learn\nAsk Learn\nTable of contents\nRead in English\nAdd\nAdd to plan\nEdit\nShare via\nFacebook\nx.com\nLinkedIn\nEmail\nPrint\nNote\nAccess to this page requires authorization. You can try\nsigning in\nor\nchanging directories\n.\nAccess to this page requires authorization. You can try\nchanging directories\n.\nTutorial: Use pattern matching to build type-driven and data-driven algorithms\n2025-03-19\nFeedback\nIn this article\nYou can write functionality that behaves as though you extended types that may be in other libraries. Another use for patterns is to create functionality your application requires that isn't a fundamental feature of the type being extended.\nIn this tutorial, you'll learn how to:\nRecognize situations where pattern matching should be used.\nUse pattern matching expressions to implement behavior based on types and property values.\nCombine pattern matching with other techniques to create complete algorithms.\nPrerequisites\nThe latest\n.NET SDK\nVisual Studio Code\neditor\nThe\nC# DevKit\nInstallation instructions\nOn Windows, this\nWinGet configuration file\nto install all prerequisites. If you already have something installed, WinGet will skip that step.\nDownload the file and double-click to run it.\nRead the license agreement, type\ny\n, and select\nEnter\nwhen prompted to accept.\nIf you get a flashing User Account Control (UAC) prompt in your Taskbar, allow the installation to continue.\nOn other platforms, you need to install each of these components separately.\nDownload the recommended installer from the\n.NET SDK download page\nand double-click to run it. The download page detects your platform and recommends the latest installer for your platform.\nDownload the latest installer from the\nVisual Studio Code\nhome page and double click to run it. That page also detects your platform and the link should be correct for your system.\nClick the \"Install\" button on the\nC# DevKit\nextension page. That opens Visual Studio code, and asks if you want to install or enable the extension. Select \"install\".\nThis tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET CLI.\nScenarios for pattern matching\nModern development often includes integrating data from multiple sources and presenting information and insights from that data in a single cohesive application. You and your team won't have control or access for all the types that represent the incoming data.\nThe classic object-oriented design would call for creating types in your application that represent each data type from those multiple data sources. Then, your application would work with those new types, build inheritance hierarchies, create virtual methods, and implement abstractions. Those techniques work, and sometimes they're the best tools. Other times you can write less code. You can write more clear code using techniques that separate the data from the operations that manipulate that data.\nIn this tutorial, you'll create and explore an application that takes incoming data from several external sources for a single scenario. You'll see how\npattern matching\nprovides an efficient way to consume and process that data in ways that weren't part of the original system.\nConsider a major metropolitan area that is using tolls and peak time pricing to manage traffic. You write an application that calculates tolls for a vehicle based on its type. Later enhancements incorporate pricing based on the number of occupants in the vehicle. Further enhancements add pricing based on the time and the day of the week.\nFrom that brief description, you may have quickly sketched out an object hierarchy to model this system. However, your data is coming from multiple sources like other vehicle registration management systems. These systems provide different classes to model that data and you don't have a single object model you can use. In this tutorial, you'll use these simplified classes to model for the vehicle data from these external systems, as shown in the following code:\nnamespace ConsumerVehicleRegistration\n{\n    public class Car\n    {\n        public int Passengers { get; set; }\n    }\n}\n\nnamespace CommercialRegistration\n{\n    public class DeliveryTruck\n    {\n        public int GrossWeightClass { get; set; }\n    }\n}\n\nnamespace LiveryRegistration\n{\n    public class Taxi\n    {\n        public int Fares { get; set; }\n    }\n\n    public class Bus\n    {\n        public int Capacity { get; set; }\n        public int Riders { get; set; }\n    }\n}\nYou can download the starter code from the\ndotnet/samples\nGitHub repository. You can see that the vehicle classes are from different systems, and are in different namespaces. No common base class, other than\nSystem.Object\ncan be used.\nPattern matching designs\nThe scenario used in this tutorial highlights the kinds of problems that pattern matching is well suited to solve:\nThe objects you need to work with aren't in an object hierarchy that matches your goals. You may be working with classes that are part of unrelated systems.\nThe functionality you're adding isn't part of the core abstraction for these classes. The toll paid by a vehicle\nchanges\nfor different types of vehicles, but the toll isn't a core function of the vehicle.\nWhen the\nshape\nof the data and the\noperations\non that data aren't described together, the pattern matching features in C# make it easier to work with.\nImplement the basic toll calculations\nThe most basic toll calculation relies only on the vehicle type:\nA\nCar\nis $2.00.\nA\nTaxi\nis $3.50.\nA\nBus\nis $5.00.\nA\nDeliveryTruck\nis $10.00\nCreate a new\nTollCalculator\nclass, and implement pattern matching on the vehicle type to get the toll amount. The following code shows the initial implementation of the\nTollCalculator\n.\nusing System;\nusing CommercialRegistration;\nusing ConsumerVehicleRegistration;\nusing LiveryRegistration;\n\nnamespace Calculators;\n\npublic class TollCalculator\n{\n    public decimal CalculateToll(object vehicle) =>\n        vehicle switch\n    {\n        Car c           => 2.00m,\n        Taxi t          => 3.50m,\n        Bus b           => 5.00m,\n        DeliveryTruck t => 10.00m,\n        { }             => throw new ArgumentException(message: \"Not a known vehicle type\", paramName: nameof(vehicle)),\n        null            => throw new ArgumentNullException(nameof(vehicle))\n    };\n}\nThe preceding code uses a\nswitch\nexpression\n(not the same as a\nswitch\nstatement\n) that tests the\ndeclaration pattern\n. A\nswitch expression\nbegins with the variable,\nvehicle\nin the preceding code, followed by the\nswitch\nkeyword. Next comes all the\nswitch arms\ninside curly braces. The\nswitch\nexpression makes other refinements to the syntax that surrounds the\nswitch\nstatement. The\ncase\nkeyword is omitted, and the result of each arm is an expression. The last two arms show a new language feature. The\n{ }\ncase matches any non-null object that didn't match an earlier arm. This arm catches any incorrect types passed to this method. The\n{ }\ncase must follow the cases for each vehicle type. If the order were reversed, the\n{ }\ncase would take precedence. Finally, the\nnull\nconstant pattern\ndetects when\nnull\nis passed to this method. The\nnull\npattern can be last because the other patterns match only a non-null object of the correct type.\nYou can test this code using the following code in\nProgram.cs\n:\nusing System;\nusing CommercialRegistration;\nusing ConsumerVehicleRegistration;\nusing LiveryRegistration;\n\nusing toll_calculator;\n\nvar tollCalc = new TollCalculator();\n\nvar car = new Car();\nvar taxi = new Taxi();\nvar bus = new Bus();\nvar truck = new DeliveryTruck();\n\nConsole.WriteLine($\"The toll for a car is {tollCalc.CalculateToll(car)}\");\nConsole.WriteLine($\"The toll for a taxi is {tollCalc.CalculateToll(taxi)}\");\nConsole.WriteLine($\"The toll for a bus is {tollCalc.CalculateToll(bus)}\");\nConsole.WriteLine($\"The toll for a truck is {tollCalc.CalculateToll(truck)}\");\n\ntry\n{\n    tollCalc.CalculateToll(\"this will fail\");\n}\ncatch (ArgumentException e)\n{\n    Console.WriteLine(\"Caught an argument exception when using the wrong type\");\n}\ntry\n{\n    tollCalc.CalculateToll(null!);\n}\ncatch (ArgumentNullException e)\n{\n    Console.WriteLine(\"Caught an argument exception when using null\");\n}\nThat code is included in the starter project, but is commented out. Remove the comments, and you can test what you've written.\nYou're starting to see how patterns can help you create algorithms where the code and the data are separate. The\nswitch\nexpression tests the type and produces different values based on the results. That's only the beginning.\nAdd occupancy pricing\nThe toll authority wants to encourage vehicles to travel at maximum capacity. They've decided to charge more when vehicles have fewer passengers, and encourage full vehicles by offering lower pricing:\nCars and taxis with no passengers pay an extra $0.50.\nCars and taxis with two passengers get a $0.50 discount.\nCars and taxis with three or more passengers get a $1.00 discount.\nBuses that are less than 50% full pay an extra $2.00.\nBuses that are more than 90% full get a $1.00 discount.\nThese rules can be implemented using a\nproperty pattern\nin the same switch expression. A property pattern compares a property value to a constant value. The property pattern examines properties of the object once the type has been determined. The single case for a\nCar\nexpands to four different cases:\nvehicle switch\n{\n    Car {Passengers: 0} => 2.00m + 0.50m,\n    Car {Passengers: 1} => 2.0m,\n    Car {Passengers: 2} => 2.0m - 0.50m,\n    Car                 => 2.00m - 1.0m,\n\n    // ...\n};\nThe first three cases test the type as a\nCar\n, then check the value of the\nPassengers\nproperty. If both match, that expression is evaluated and returned.\nYou would also expand the cases for taxis in a similar manner:\nvehicle switch\n{\n    // ...\n\n    Taxi {Fares: 0}  => 3.50m + 1.00m,\n    Taxi {Fares: 1}  => 3.50m,\n    Taxi {Fares: 2}  => 3.50m - 0.50m,\n    Taxi             => 3.50m - 1.00m,\n\n    // ...\n};\nNext, implement the occupancy rules by expanding the cases for buses, as shown in the following example:\nvehicle switch\n{\n    // ...\n\n    Bus b when ((double)b.Riders / (double)b.Capacity) < 0.50 => 5.00m + 2.00m,\n    Bus b when ((double)b.Riders / (double)b.Capacity) > 0.90 => 5.00m - 1.00m,\n    Bus => 5.00m,\n\n    // ...\n};\nThe toll authority isn't concerned with the number of passengers in the delivery trucks. Instead, they adjust the toll amount based on the weight class of the trucks as follows:\nTrucks over 5000 lbs are charged an extra $5.00.\nLight trucks under 3000 lbs are given a $2.00 discount.\nThat rule is implemented with the following code:\nvehicle switch\n{\n    // ...\n\n    DeliveryTruck t when (t.GrossWeightClass > 5000) => 10.00m + 5.00m,\n    DeliveryTruck t when (t.GrossWeightClass < 3000) => 10.00m - 2.00m,\n    DeliveryTruck => 10.00m,\n};\nThe preceding code shows the\nwhen\nclause of a switch arm. You use the\nwhen\nclause to test conditions other than equality on a property. When you've finished, you'll have a method that looks much like the following code:\nvehicle switch\n{\n    Car {Passengers: 0}        => 2.00m + 0.50m,\n    Car {Passengers: 1}        => 2.0m,\n    Car {Passengers: 2}        => 2.0m - 0.50m,\n    Car                        => 2.00m - 1.0m,\n\n    Taxi {Fares: 0}  => 3.50m + 1.00m,\n    Taxi {Fares: 1}  => 3.50m,\n    Taxi {Fares: 2}  => 3.50m - 0.50m,\n    Taxi             => 3.50m - 1.00m,\n\n    Bus b when ((double)b.Riders / (double)b.Capacity) < 0.50 => 5.00m + 2.00m,\n    Bus b when ((double)b.Riders / (double)b.Capacity) > 0.90 => 5.00m - 1.00m,\n    Bus => 5.00m,\n\n    DeliveryTruck t when (t.GrossWeightClass > 5000) => 10.00m + 5.00m,\n    DeliveryTruck t when (t.GrossWeightClass < 3000) => 10.00m - 2.00m,\n    DeliveryTruck => 10.00m,\n\n    { }     => throw new ArgumentException(message: \"Not a known vehicle type\", paramName: nameof(vehicle)),\n    null    => throw new ArgumentNullException(nameof(vehicle))\n};\nMany of these switch arms are examples of\nrecursive patterns\n. For example,\nCar { Passengers: 1}\nshows a constant pattern inside a property pattern.\nYou can make this code less repetitive by using nested switches. The\nCar\nand\nTaxi\nboth have four different arms in the preceding examples. In both cases, you can create a declaration pattern that feeds into a constant pattern. This technique is shown in the following code:\npublic decimal CalculateToll(object vehicle) =>\n    vehicle switch\n    {\n        Car c => c.Passengers switch\n        {\n            0 => 2.00m + 0.5m,\n            1 => 2.0m,\n            2 => 2.0m - 0.5m,\n            _ => 2.00m - 1.0m\n        },\n\n        Taxi t => t.Fares switch\n        {\n            0 => 3.50m + 1.00m,\n            1 => 3.50m,\n            2 => 3.50m - 0.50m,\n            _ => 3.50m - 1.00m\n        },\n\n        Bus b when ((double)b.Riders / (double)b.Capacity) < 0.50 => 5.00m + 2.00m,\n        Bus b when ((double)b.Riders / (double)b.Capacity) > 0.90 => 5.00m - 1.00m,\n        Bus b => 5.00m,\n\n        DeliveryTruck t when (t.GrossWeightClass > 5000) => 10.00m + 5.00m,\n        DeliveryTruck t when (t.GrossWeightClass < 3000) => 10.00m - 2.00m,\n        DeliveryTruck t => 10.00m,\n\n        { }  => throw new ArgumentException(message: \"Not a known vehicle type\", paramName: nameof(vehicle)),\n        null => throw new ArgumentNullException(nameof(vehicle))\n    };\nIn the preceding sample, using a recursive expression means you don't repeat the\nCar\nand\nTaxi\narms containing child arms that test the property value. This technique isn't used for the\nBus\nand\nDeliveryTruck\narms because those arms are testing ranges for the property, not discrete values.\nAdd peak pricing\nFor the final feature, the toll authority wants to add time sensitive peak pricing. During the morning and evening rush hours, the tolls are doubled. That rule only affects traffic in one direction: inbound to the city in the morning, and outbound in the evening rush hour. During other times during the workday, tolls increase by 50%. Late night and early morning, tolls are reduced by 25%. During the weekend, it's the normal rate, regardless of the time. You could use a series of\nif\nand\nelse\nstatements to express this using the following code:\npublic decimal PeakTimePremiumIfElse(DateTime timeOfToll, bool inbound)\n{\n    if ((timeOfToll.DayOfWeek == DayOfWeek.Saturday) ||\n        (timeOfToll.DayOfWeek == DayOfWeek.Sunday))\n    {\n        return 1.0m;\n    }\n    else\n    {\n        int hour = timeOfToll.Hour;\n        if (hour < 6)\n        {\n            return 0.75m;\n        }\n        else if (hour < 10)\n        {\n            if (inbound)\n            {\n                return 2.0m;\n            }\n            else\n            {\n                return 1.0m;\n            }\n        }\n        else if (hour < 16)\n        {\n            return 1.5m;\n        }\n        else if (hour < 20)\n        {\n            if (inbound)\n            {\n                return 1.0m;\n            }\n            else\n            {\n                return 2.0m;\n            }\n        }\n        else // Overnight\n        {\n            return 0.75m;\n        }\n    }\n}\nThe preceding code does work correctly, but isn't readable. You have to chain through all the input cases and the nested\nif\nstatements to reason about the code. Instead, you'll use pattern matching for this feature, but you'll integrate it with other techniques. You could build a single pattern match expression that would account for all the combinations of direction, day of the week, and time. The result would be a complicated expression. It would be hard to read and difficult to understand. That makes it hard to ensure correctness. Instead, combine those methods to build a tuple of values that concisely describes all those states. Then use pattern matching to calculate a multiplier for the toll. The tuple contains three discrete conditions:\nThe day is either a weekday or a weekend.\nThe band of time when the toll is collected.\nThe direction is into the city or out of the city\nThe following table shows the combinations of input values and the peak pricing multiplier:\nDay\nTime\nDirection\nPremium\nWeekday\nmorning rush\ninbound\nx 2.00\nWeekday\nmorning rush\noutbound\nx 1.00\nWeekday\ndaytime\ninbound\nx 1.50\nWeekday\ndaytime\noutbound\nx 1.50\nWeekday\nevening rush\ninbound\nx 1.00\nWeekday\nevening rush\noutbound\nx 2.00\nWeekday\novernight\ninbound\nx 0.75\nWeekday\novernight\noutbound\nx 0.75\nWeekend\nmorning rush\ninbound\nx 1.00\nWeekend\nmorning rush\noutbound\nx 1.00\nWeekend\ndaytime\ninbound\nx 1.00\nWeekend\ndaytime\noutbound\nx 1.00\nWeekend\nevening rush\ninbound\nx 1.00\nWeekend\nevening rush\noutbound\nx 1.00\nWeekend\novernight\ninbound\nx 1.00\nWeekend\novernight\noutbound\nx 1.00\nThere are 16 different combinations of the three variables. By combining some of the conditions, you'll simplify the final switch expression.\nThe system that collects the tolls uses a\nDateTime\nstructure for the time when the toll was collected. Build member methods that create the variables from the preceding table. The following function uses a pattern matching switch expression to express whether a\nDateTime\nrepresents a weekend or a weekday:\nprivate static bool IsWeekDay(DateTime timeOfToll) =>\n    timeOfToll.DayOfWeek switch\n    {\n        DayOfWeek.Monday    => true,\n        DayOfWeek.Tuesday   => true,\n        DayOfWeek.Wednesday => true,\n        DayOfWeek.Thursday  => true,\n        DayOfWeek.Friday    => true,\n        DayOfWeek.Saturday  => false,\n        DayOfWeek.Sunday    => false\n    };\nThat method is correct, but it's repetitious. You can simplify it, as shown in the following code:\nprivate static bool IsWeekDay(DateTime timeOfToll) =>\n    timeOfToll.DayOfWeek switch\n    {\n        DayOfWeek.Saturday => false,\n        DayOfWeek.Sunday => false,\n        _ => true\n    };\nNext, add a similar function to categorize the time into the blocks:\nprivate enum TimeBand\n{\n    MorningRush,\n    Daytime,\n    EveningRush,\n    Overnight\n}\n\nprivate static TimeBand GetTimeBand(DateTime timeOfToll) =>\n    timeOfToll.Hour switch\n    {\n        < 6 or > 19 => TimeBand.Overnight,\n        < 10 => TimeBand.MorningRush,\n        < 16 => TimeBand.Daytime,\n        _ => TimeBand.EveningRush,\n    };\nYou add a private\nenum\nto convert each range of time to a discrete value. Then, the\nGetTimeBand\nmethod uses\nrelational patterns\n, and\nconjunctive\nor\npatterns\n. A relational pattern lets you test a numeric value using\n<\n,\n>\n,\n<=\n, or\n>=\n. The\nor\npattern tests if an expression matches one or more patterns. You can also use an\nand\npattern to ensure that an expression matches two distinct patterns, and a\nnot\npattern to test that an expression doesn't match a pattern.\nAfter you create those methods, you can use another\nswitch\nexpression with the\ntuple pattern\nto calculate the pricing premium. You could build a\nswitch\nexpression with all 16 arms:\npublic decimal PeakTimePremiumFull(DateTime timeOfToll, bool inbound) =>\n    (IsWeekDay(timeOfToll), GetTimeBand(timeOfToll), inbound) switch\n    {\n        (true, TimeBand.MorningRush, true) => 2.00m,\n        (true, TimeBand.MorningRush, false) => 1.00m,\n        (true, TimeBand.Daytime, true) => 1.50m,\n        (true, TimeBand.Daytime, false) => 1.50m,\n        (true, TimeBand.EveningRush, true) => 1.00m,\n        (true, TimeBand.EveningRush, false) => 2.00m,\n        (true, TimeBand.Overnight, true) => 0.75m,\n        (true, TimeBand.Overnight, false) => 0.75m,\n        (false, TimeBand.MorningRush, true) => 1.00m,\n        (false, TimeBand.MorningRush, false) => 1.00m,\n        (false, TimeBand.Daytime, true) => 1.00m,\n        (false, TimeBand.Daytime, false) => 1.00m,\n        (false, TimeBand.EveningRush, true) => 1.00m,\n        (false, TimeBand.EveningRush, false) => 1.00m,\n        (false, TimeBand.Overnight, true) => 1.00m,\n        (false, TimeBand.Overnight, false) => 1.00m,\n    };\nThe above code works, but it can be simplified. All eight combinations for the weekend have the same toll. You can replace all eight with the following line:\n(false, _, _) => 1.0m,\nBoth inbound and outbound traffic have the same multiplier during the weekday daytime and overnight hours. Those four switch arms can be replaced with the following two lines:\n(true, TimeBand.Overnight, _) => 0.75m,\n(true, TimeBand.Daytime, _)   => 1.5m,\nThe code should look like the following code after those two changes:\npublic decimal PeakTimePremium(DateTime timeOfToll, bool inbound) =>\n    (IsWeekDay(timeOfToll), GetTimeBand(timeOfToll), inbound) switch\n    {\n        (true, TimeBand.MorningRush, true)  => 2.00m,\n        (true, TimeBand.MorningRush, false) => 1.00m,\n        (true, TimeBand.Daytime,     _)     => 1.50m,\n        (true, TimeBand.EveningRush, true)  => 1.00m,\n        (true, TimeBand.EveningRush, false) => 2.00m,\n        (true, TimeBand.Overnight,   _)     => 0.75m,\n        (false, _,                   _)     => 1.00m,\n    };\nFinally, you can remove the two rush hour times that pay the regular price. Once you remove those arms, you can replace the\nfalse\nwith a discard (\n_\n) in the final switch arm. You'll have the following finished method:\npublic decimal PeakTimePremium(DateTime timeOfToll, bool inbound) =>\n    (IsWeekDay(timeOfToll), GetTimeBand(timeOfToll), inbound) switch\n    {\n        (true, TimeBand.Overnight, _) => 0.75m,\n        (true, TimeBand.Daytime, _) => 1.5m,\n        (true, TimeBand.MorningRush, true) => 2.0m,\n        (true, TimeBand.EveningRush, false) => 2.0m,\n        _ => 1.0m,\n    };\nThis example highlights one of the advantages of pattern matching: the pattern branches are evaluated in order. If you rearrange them so that an earlier branch handles one of your later cases, the compiler warns you about the unreachable code. Those language rules made it easier to do the preceding simplifications with confidence that the code didn't change.\nPattern matching makes some types of code more readable and offers an alternative to object-oriented techniques when you can't add code to your classes. The cloud is causing data and functionality to live apart. The\nshape\nof the data and the\noperations\non it aren't necessarily described together. In this tutorial, you consumed existing data in entirely different ways from its original function. Pattern matching gave you the ability to write functionality that overrode those types, even though you couldn't extend them.\nNext steps\nYou can download the finished code from the\ndotnet/samples\nGitHub repository. Explore patterns on your own and add this technique into your regular coding activities. Learning these techniques gives you another way to approach problems and create new functionality.\nSee also\nPatterns\nswitch\nexpression\nCollaborate with us on GitHub\nThe source for this content can be found on GitHub, where you can also create and review issues and pull requests. For more information, see\nour contributor guide\n.\n.NET\nOpen a documentation issue\nProvide product feedback\nAdditional resources",
  "code_samples": [
    {
      "language": "csharp",
      "code": "namespace ConsumerVehicleRegistration\n{\n    public class Car\n    {\n        public int Passengers { get; set; }\n    }\n}\n\nnamespace CommercialRegistration\n{\n    public class DeliveryTruck\n    {\n        public int GrossWeightClass { get; set; }\n    }\n}\n\nnamespace LiveryRegistration\n{\n    public class Taxi\n    {\n        public int Fares { get; set; }\n    }\n\n    public class Bus\n    {\n        public int Capacity { get; set; }\n        public int Riders { get; set; }\n    }\n}",
      "lines": 29
    },
    {
      "language": "csharp",
      "code": "namespace ConsumerVehicleRegistration\n{\n    public class Car\n    {\n        public int Passengers { get; set; }\n    }\n}\n\nnamespace CommercialRegistration\n{\n    public class DeliveryTruck\n    {\n        public int GrossWeightClass { get; set; }\n    }\n}\n\nnamespace LiveryRegistration\n{\n    public class Taxi\n    {\n        public int Fares { get; set; }\n    }\n\n    public class Bus\n    {\n        public int Capacity { get; set; }\n        public int Riders { get; set; }\n    }\n}",
      "lines": 29
    },
    {
      "language": "csharp",
      "code": "using System;\nusing CommercialRegistration;\nusing ConsumerVehicleRegistration;\nusing LiveryRegistration;\n\nnamespace Calculators;\n\npublic class TollCalculator\n{\n    public decimal CalculateToll(object vehicle) =>\n        vehicle switch\n    {\n        Car c           => 2.00m,\n        Taxi t          => 3.50m,\n        Bus b           => 5.00m,\n        DeliveryTruck t => 10.00m,\n        { }             => throw new ArgumentException(message: \"Not a known vehicle type\", paramName: nameof(vehicle)),\n        null            => throw new ArgumentNullException(nameof(vehicle))\n    };\n}",
      "lines": 20
    },
    {
      "language": "csharp",
      "code": "using System;\nusing CommercialRegistration;\nusing ConsumerVehicleRegistration;\nusing LiveryRegistration;\n\nnamespace Calculators;\n\npublic class TollCalculator\n{\n    public decimal CalculateToll(object vehicle) =>\n        vehicle switch\n    {\n        Car c           => 2.00m,\n        Taxi t          => 3.50m,\n        Bus b           => 5.00m,\n        DeliveryTruck t => 10.00m,\n        { }             => throw new ArgumentException(message: \"Not a known vehicle type\", paramName: nameof(vehicle)),\n        null            => throw new ArgumentNullException(nameof(vehicle))\n    };\n}",
      "lines": 20
    },
    {
      "language": "csharp",
      "code": "using System;\nusing CommercialRegistration;\nusing ConsumerVehicleRegistration;\nusing LiveryRegistration;\n\nusing toll_calculator;\n\nvar tollCalc = new TollCalculator();\n\nvar car = new Car();\nvar taxi = new Taxi();\nvar bus = new Bus();\nvar truck = new DeliveryTruck();\n\nConsole.WriteLine($\"The toll for a car is {tollCalc.CalculateToll(car)}\");\nConsole.WriteLine($\"The toll for a taxi is {tollCalc.CalculateToll(taxi)}\");\nConsole.WriteLine($\"The toll for a bus is {tollCalc.CalculateToll(bus)}\");\nConsole.WriteLine($\"The toll for a truck is {tollCalc.CalculateToll(truck)}\");\n\ntry\n{\n    tollCalc.CalculateToll(\"this will fail\");\n}\ncatch (ArgumentException e)\n{\n    Console.WriteLine(\"Caught an argument exception when using the wrong type\");\n}\ntry\n{\n    tollCalc.CalculateToll(null!);\n}\ncatch (ArgumentNullException e)\n{\n    Console.WriteLine(\"Caught an argument exception when using null\");\n}",
      "lines": 35
    },
    {
      "language": "csharp",
      "code": "using System;\nusing CommercialRegistration;\nusing ConsumerVehicleRegistration;\nusing LiveryRegistration;\n\nusing toll_calculator;\n\nvar tollCalc = new TollCalculator();\n\nvar car = new Car();\nvar taxi = new Taxi();\nvar bus = new Bus();\nvar truck = new DeliveryTruck();\n\nConsole.WriteLine($\"The toll for a car is {tollCalc.CalculateToll(car)}\");\nConsole.WriteLine($\"The toll for a taxi is {tollCalc.CalculateToll(taxi)}\");\nConsole.WriteLine($\"The toll for a bus is {tollCalc.CalculateToll(bus)}\");\nConsole.WriteLine($\"The toll for a truck is {tollCalc.CalculateToll(truck)}\");\n\ntry\n{\n    tollCalc.CalculateToll(\"this will fail\");\n}\ncatch (ArgumentException e)\n{\n    Console.WriteLine(\"Caught an argument exception when using the wrong type\");\n}\ntry\n{\n    tollCalc.CalculateToll(null!);\n}\ncatch (ArgumentNullException e)\n{\n    Console.WriteLine(\"Caught an argument exception when using null\");\n}",
      "lines": 35
    },
    {
      "language": "csharp",
      "code": "vehicle switch\n{\n    Car {Passengers: 0} => 2.00m + 0.50m,\n    Car {Passengers: 1} => 2.0m,\n    Car {Passengers: 2} => 2.0m - 0.50m,\n    Car                 => 2.00m - 1.0m,\n\n    // ...\n};",
      "lines": 9
    },
    {
      "language": "csharp",
      "code": "vehicle switch\n{\n    Car {Passengers: 0} => 2.00m + 0.50m,\n    Car {Passengers: 1} => 2.0m,\n    Car {Passengers: 2} => 2.0m - 0.50m,\n    Car                 => 2.00m - 1.0m,\n\n    // ...\n};",
      "lines": 9
    },
    {
      "language": "csharp",
      "code": "vehicle switch\n{\n    // ...\n\n    Taxi {Fares: 0}  => 3.50m + 1.00m,\n    Taxi {Fares: 1}  => 3.50m,\n    Taxi {Fares: 2}  => 3.50m - 0.50m,\n    Taxi             => 3.50m - 1.00m,\n\n    // ...\n};",
      "lines": 11
    },
    {
      "language": "csharp",
      "code": "vehicle switch\n{\n    // ...\n\n    Taxi {Fares: 0}  => 3.50m + 1.00m,\n    Taxi {Fares: 1}  => 3.50m,\n    Taxi {Fares: 2}  => 3.50m - 0.50m,\n    Taxi             => 3.50m - 1.00m,\n\n    // ...\n};",
      "lines": 11
    },
    {
      "language": "csharp",
      "code": "vehicle switch\n{\n    // ...\n\n    Bus b when ((double)b.Riders / (double)b.Capacity) < 0.50 => 5.00m + 2.00m,\n    Bus b when ((double)b.Riders / (double)b.Capacity) > 0.90 => 5.00m - 1.00m,\n    Bus => 5.00m,\n\n    // ...\n};",
      "lines": 10
    },
    {
      "language": "csharp",
      "code": "vehicle switch\n{\n    // ...\n\n    Bus b when ((double)b.Riders / (double)b.Capacity) < 0.50 => 5.00m + 2.00m,\n    Bus b when ((double)b.Riders / (double)b.Capacity) > 0.90 => 5.00m - 1.00m,\n    Bus => 5.00m,\n\n    // ...\n};",
      "lines": 10
    },
    {
      "language": "csharp",
      "code": "vehicle switch\n{\n    // ...\n\n    DeliveryTruck t when (t.GrossWeightClass > 5000) => 10.00m + 5.00m,\n    DeliveryTruck t when (t.GrossWeightClass < 3000) => 10.00m - 2.00m,\n    DeliveryTruck => 10.00m,\n};",
      "lines": 8
    },
    {
      "language": "csharp",
      "code": "vehicle switch\n{\n    // ...\n\n    DeliveryTruck t when (t.GrossWeightClass > 5000) => 10.00m + 5.00m,\n    DeliveryTruck t when (t.GrossWeightClass < 3000) => 10.00m - 2.00m,\n    DeliveryTruck => 10.00m,\n};",
      "lines": 8
    },
    {
      "language": "csharp",
      "code": "vehicle switch\n{\n    Car {Passengers: 0}        => 2.00m + 0.50m,\n    Car {Passengers: 1}        => 2.0m,\n    Car {Passengers: 2}        => 2.0m - 0.50m,\n    Car                        => 2.00m - 1.0m,\n\n    Taxi {Fares: 0}  => 3.50m + 1.00m,\n    Taxi {Fares: 1}  => 3.50m,\n    Taxi {Fares: 2}  => 3.50m - 0.50m,\n    Taxi             => 3.50m - 1.00m,\n\n    Bus b when ((double)b.Riders / (double)b.Capacity) < 0.50 => 5.00m + 2.00m,\n    Bus b when ((double)b.Riders / (double)b.Capacity) > 0.90 => 5.00m - 1.00m,\n    Bus => 5.00m,\n\n    DeliveryTruck t when (t.GrossWeightClass > 5000) => 10.00m + 5.00m,\n    DeliveryTruck t when (t.GrossWeightClass < 3000) => 10.00m - 2.00m,\n    DeliveryTruck => 10.00m,\n\n    { }     => throw new ArgumentException(message: \"Not a known vehicle type\", paramName: nameof(vehicle)),\n    null    => throw new ArgumentNullException(nameof(vehicle))\n};",
      "lines": 23
    },
    {
      "language": "csharp",
      "code": "vehicle switch\n{\n    Car {Passengers: 0}        => 2.00m + 0.50m,\n    Car {Passengers: 1}        => 2.0m,\n    Car {Passengers: 2}        => 2.0m - 0.50m,\n    Car                        => 2.00m - 1.0m,\n\n    Taxi {Fares: 0}  => 3.50m + 1.00m,\n    Taxi {Fares: 1}  => 3.50m,\n    Taxi {Fares: 2}  => 3.50m - 0.50m,\n    Taxi             => 3.50m - 1.00m,\n\n    Bus b when ((double)b.Riders / (double)b.Capacity) < 0.50 => 5.00m + 2.00m,\n    Bus b when ((double)b.Riders / (double)b.Capacity) > 0.90 => 5.00m - 1.00m,\n    Bus => 5.00m,\n\n    DeliveryTruck t when (t.GrossWeightClass > 5000) => 10.00m + 5.00m,\n    DeliveryTruck t when (t.GrossWeightClass < 3000) => 10.00m - 2.00m,\n    DeliveryTruck => 10.00m,\n\n    { }     => throw new ArgumentException(message: \"Not a known vehicle type\", paramName: nameof(vehicle)),\n    null    => throw new ArgumentNullException(nameof(vehicle))\n};",
      "lines": 23
    },
    {
      "language": "csharp",
      "code": "public decimal CalculateToll(object vehicle) =>\n    vehicle switch\n    {\n        Car c => c.Passengers switch\n        {\n            0 => 2.00m + 0.5m,\n            1 => 2.0m,\n            2 => 2.0m - 0.5m,\n            _ => 2.00m - 1.0m\n        },\n\n        Taxi t => t.Fares switch\n        {\n            0 => 3.50m + 1.00m,\n            1 => 3.50m,\n            2 => 3.50m - 0.50m,\n            _ => 3.50m - 1.00m\n        },\n\n        Bus b when ((double)b.Riders / (double)b.Capacity) < 0.50 => 5.00m + 2.00m,\n        Bus b when ((double)b.Riders / (double)b.Capacity) > 0.90 => 5.00m - 1.00m,\n        Bus b => 5.00m,\n\n        DeliveryTruck t when (t.GrossWeightClass > 5000) => 10.00m + 5.00m,\n        DeliveryTruck t when (t.GrossWeightClass < 3000) => 10.00m - 2.00m,\n        DeliveryTruck t => 10.00m,\n\n        { }  => throw new ArgumentException(message: \"Not a known vehicle type\", paramName: nameof(vehicle)),\n        null => throw new ArgumentNullException(nameof(vehicle))\n    };",
      "lines": 30
    },
    {
      "language": "csharp",
      "code": "public decimal CalculateToll(object vehicle) =>\n    vehicle switch\n    {\n        Car c => c.Passengers switch\n        {\n            0 => 2.00m + 0.5m,\n            1 => 2.0m,\n            2 => 2.0m - 0.5m,\n            _ => 2.00m - 1.0m\n        },\n\n        Taxi t => t.Fares switch\n        {\n            0 => 3.50m + 1.00m,\n            1 => 3.50m,\n            2 => 3.50m - 0.50m,\n            _ => 3.50m - 1.00m\n        },\n\n        Bus b when ((double)b.Riders / (double)b.Capacity) < 0.50 => 5.00m + 2.00m,\n        Bus b when ((double)b.Riders / (double)b.Capacity) > 0.90 => 5.00m - 1.00m,\n        Bus b => 5.00m,\n\n        DeliveryTruck t when (t.GrossWeightClass > 5000) => 10.00m + 5.00m,\n        DeliveryTruck t when (t.GrossWeightClass < 3000) => 10.00m - 2.00m,\n        DeliveryTruck t => 10.00m,\n\n        { }  => throw new ArgumentException(message: \"Not a known vehicle type\", paramName: nameof(vehicle)),\n        null => throw new ArgumentNullException(nameof(vehicle))\n    };",
      "lines": 30
    },
    {
      "language": "csharp",
      "code": "public decimal PeakTimePremiumIfElse(DateTime timeOfToll, bool inbound)\n{\n    if ((timeOfToll.DayOfWeek == DayOfWeek.Saturday) ||\n        (timeOfToll.DayOfWeek == DayOfWeek.Sunday))\n    {\n        return 1.0m;\n    }\n    else\n    {\n        int hour = timeOfToll.Hour;\n        if (hour < 6)\n        {\n            return 0.75m;\n        }\n        else if (hour < 10)\n        {\n            if (inbound)\n            {\n                return 2.0m;\n            }\n            else\n            {\n                return 1.0m;\n            }\n        }\n        else if (hour < 16)\n        {\n            return 1.5m;\n        }\n        else if (hour < 20)\n        {\n            if (inbound)\n            {\n                return 1.0m;\n            }\n            else\n            {\n                return 2.0m;\n            }\n        }\n        else // Overnight\n        {\n            return 0.75m;\n        }\n    }\n}",
      "lines": 46
    },
    {
      "language": "csharp",
      "code": "public decimal PeakTimePremiumIfElse(DateTime timeOfToll, bool inbound)\n{\n    if ((timeOfToll.DayOfWeek == DayOfWeek.Saturday) ||\n        (timeOfToll.DayOfWeek == DayOfWeek.Sunday))\n    {\n        return 1.0m;\n    }\n    else\n    {\n        int hour = timeOfToll.Hour;\n        if (hour < 6)\n        {\n            return 0.75m;\n        }\n        else if (hour < 10)\n        {\n            if (inbound)\n            {\n                return 2.0m;\n            }\n            else\n            {\n                return 1.0m;\n            }\n        }\n        else if (hour < 16)\n        {\n            return 1.5m;\n        }\n        else if (hour < 20)\n        {\n            if (inbound)\n            {\n                return 1.0m;\n            }\n            else\n            {\n                return 2.0m;\n            }\n        }\n        else // Overnight\n        {\n            return 0.75m;\n        }\n    }\n}",
      "lines": 46
    },
    {
      "language": "csharp",
      "code": "private static bool IsWeekDay(DateTime timeOfToll) =>\n    timeOfToll.DayOfWeek switch\n    {\n        DayOfWeek.Monday    => true,\n        DayOfWeek.Tuesday   => true,\n        DayOfWeek.Wednesday => true,\n        DayOfWeek.Thursday  => true,\n        DayOfWeek.Friday    => true,\n        DayOfWeek.Saturday  => false,\n        DayOfWeek.Sunday    => false\n    };",
      "lines": 11
    },
    {
      "language": "csharp",
      "code": "private static bool IsWeekDay(DateTime timeOfToll) =>\n    timeOfToll.DayOfWeek switch\n    {\n        DayOfWeek.Monday    => true,\n        DayOfWeek.Tuesday   => true,\n        DayOfWeek.Wednesday => true,\n        DayOfWeek.Thursday  => true,\n        DayOfWeek.Friday    => true,\n        DayOfWeek.Saturday  => false,\n        DayOfWeek.Sunday    => false\n    };",
      "lines": 11
    },
    {
      "language": "csharp",
      "code": "private static bool IsWeekDay(DateTime timeOfToll) =>\n    timeOfToll.DayOfWeek switch\n    {\n        DayOfWeek.Saturday => false,\n        DayOfWeek.Sunday => false,\n        _ => true\n    };",
      "lines": 7
    },
    {
      "language": "csharp",
      "code": "private static bool IsWeekDay(DateTime timeOfToll) =>\n    timeOfToll.DayOfWeek switch\n    {\n        DayOfWeek.Saturday => false,\n        DayOfWeek.Sunday => false,\n        _ => true\n    };",
      "lines": 7
    },
    {
      "language": "csharp",
      "code": "private enum TimeBand\n{\n    MorningRush,\n    Daytime,\n    EveningRush,\n    Overnight\n}\n\nprivate static TimeBand GetTimeBand(DateTime timeOfToll) =>\n    timeOfToll.Hour switch\n    {\n        < 6 or > 19 => TimeBand.Overnight,\n        < 10 => TimeBand.MorningRush,\n        < 16 => TimeBand.Daytime,\n        _ => TimeBand.EveningRush,\n    };",
      "lines": 16
    },
    {
      "language": "csharp",
      "code": "private enum TimeBand\n{\n    MorningRush,\n    Daytime,\n    EveningRush,\n    Overnight\n}\n\nprivate static TimeBand GetTimeBand(DateTime timeOfToll) =>\n    timeOfToll.Hour switch\n    {\n        < 6 or > 19 => TimeBand.Overnight,\n        < 10 => TimeBand.MorningRush,\n        < 16 => TimeBand.Daytime,\n        _ => TimeBand.EveningRush,\n    };",
      "lines": 16
    },
    {
      "language": "csharp",
      "code": "public decimal PeakTimePremiumFull(DateTime timeOfToll, bool inbound) =>\n    (IsWeekDay(timeOfToll), GetTimeBand(timeOfToll), inbound) switch\n    {\n        (true, TimeBand.MorningRush, true) => 2.00m,\n        (true, TimeBand.MorningRush, false) => 1.00m,\n        (true, TimeBand.Daytime, true) => 1.50m,\n        (true, TimeBand.Daytime, false) => 1.50m,\n        (true, TimeBand.EveningRush, true) => 1.00m,\n        (true, TimeBand.EveningRush, false) => 2.00m,\n        (true, TimeBand.Overnight, true) => 0.75m,\n        (true, TimeBand.Overnight, false) => 0.75m,\n        (false, TimeBand.MorningRush, true) => 1.00m,\n        (false, TimeBand.MorningRush, false) => 1.00m,\n        (false, TimeBand.Daytime, true) => 1.00m,\n        (false, TimeBand.Daytime, false) => 1.00m,\n        (false, TimeBand.EveningRush, true) => 1.00m,\n        (false, TimeBand.EveningRush, false) => 1.00m,\n        (false, TimeBand.Overnight, true) => 1.00m,\n        (false, TimeBand.Overnight, false) => 1.00m,\n    };",
      "lines": 20
    },
    {
      "language": "csharp",
      "code": "public decimal PeakTimePremiumFull(DateTime timeOfToll, bool inbound) =>\n    (IsWeekDay(timeOfToll), GetTimeBand(timeOfToll), inbound) switch\n    {\n        (true, TimeBand.MorningRush, true) => 2.00m,\n        (true, TimeBand.MorningRush, false) => 1.00m,\n        (true, TimeBand.Daytime, true) => 1.50m,\n        (true, TimeBand.Daytime, false) => 1.50m,\n        (true, TimeBand.EveningRush, true) => 1.00m,\n        (true, TimeBand.EveningRush, false) => 2.00m,\n        (true, TimeBand.Overnight, true) => 0.75m,\n        (true, TimeBand.Overnight, false) => 0.75m,\n        (false, TimeBand.MorningRush, true) => 1.00m,\n        (false, TimeBand.MorningRush, false) => 1.00m,\n        (false, TimeBand.Daytime, true) => 1.00m,\n        (false, TimeBand.Daytime, false) => 1.00m,\n        (false, TimeBand.EveningRush, true) => 1.00m,\n        (false, TimeBand.EveningRush, false) => 1.00m,\n        (false, TimeBand.Overnight, true) => 1.00m,\n        (false, TimeBand.Overnight, false) => 1.00m,\n    };",
      "lines": 20
    },
    {
      "language": "csharp",
      "code": "(true, TimeBand.Overnight, _) => 0.75m,\n(true, TimeBand.Daytime, _)   => 1.5m,",
      "lines": 2
    },
    {
      "language": "csharp",
      "code": "(true, TimeBand.Overnight, _) => 0.75m,\n(true, TimeBand.Daytime, _)   => 1.5m,",
      "lines": 2
    },
    {
      "language": "csharp",
      "code": "public decimal PeakTimePremium(DateTime timeOfToll, bool inbound) =>\n    (IsWeekDay(timeOfToll), GetTimeBand(timeOfToll), inbound) switch\n    {\n        (true, TimeBand.MorningRush, true)  => 2.00m,\n        (true, TimeBand.MorningRush, false) => 1.00m,\n        (true, TimeBand.Daytime,     _)     => 1.50m,\n        (true, TimeBand.EveningRush, true)  => 1.00m,\n        (true, TimeBand.EveningRush, false) => 2.00m,\n        (true, TimeBand.Overnight,   _)     => 0.75m,\n        (false, _,                   _)     => 1.00m,\n    };",
      "lines": 11
    },
    {
      "language": "csharp",
      "code": "public decimal PeakTimePremium(DateTime timeOfToll, bool inbound) =>\n    (IsWeekDay(timeOfToll), GetTimeBand(timeOfToll), inbound) switch\n    {\n        (true, TimeBand.MorningRush, true)  => 2.00m,\n        (true, TimeBand.MorningRush, false) => 1.00m,\n        (true, TimeBand.Daytime,     _)     => 1.50m,\n        (true, TimeBand.EveningRush, true)  => 1.00m,\n        (true, TimeBand.EveningRush, false) => 2.00m,\n        (true, TimeBand.Overnight,   _)     => 0.75m,\n        (false, _,                   _)     => 1.00m,\n    };",
      "lines": 11
    },
    {
      "language": "csharp",
      "code": "public decimal PeakTimePremium(DateTime timeOfToll, bool inbound) =>\n    (IsWeekDay(timeOfToll), GetTimeBand(timeOfToll), inbound) switch\n    {\n        (true, TimeBand.Overnight, _) => 0.75m,\n        (true, TimeBand.Daytime, _) => 1.5m,\n        (true, TimeBand.MorningRush, true) => 2.0m,\n        (true, TimeBand.EveningRush, false) => 2.0m,\n        _ => 1.0m,\n    };",
      "lines": 9
    },
    {
      "language": "csharp",
      "code": "public decimal PeakTimePremium(DateTime timeOfToll, bool inbound) =>\n    (IsWeekDay(timeOfToll), GetTimeBand(timeOfToll), inbound) switch\n    {\n        (true, TimeBand.Overnight, _) => 0.75m,\n        (true, TimeBand.Daytime, _) => 1.5m,\n        (true, TimeBand.MorningRush, true) => 2.0m,\n        (true, TimeBand.EveningRush, false) => 2.0m,\n        _ => 1.0m,\n    };",
      "lines": 9
    }
  ],
  "collected_at": "2025-06-27T01:19:10.936911"
}