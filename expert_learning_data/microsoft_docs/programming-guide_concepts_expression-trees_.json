{
  "url": "https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/expression-trees/",
  "title": "Expression Trees",
  "topic": "programming-guide/concepts/expression-trees/",
  "content": "Table of contents\nExit focus mode\nAsk Learn\nAsk Learn\nTable of contents\nRead in English\nAdd\nAdd to plan\nEdit\nShare via\nFacebook\nx.com\nLinkedIn\nEmail\nPrint\nNote\nAccess to this page requires authorization. You can try\nsigning in\nor\nchanging directories\n.\nAccess to this page requires authorization. You can try\nchanging directories\n.\nExpression Trees\n2024-05-29\nFeedback\nIn this article\nExpression trees\nrepresent code in a tree-like data structure, where each node is an expression, for example, a method call or a binary operation such as\nx < y\n.\nIf you used LINQ, you have experience with a rich library where the\nFunc\ntypes are part of the API set. (If you aren't familiar with LINQ, you probably want to read\nthe LINQ tutorial\nand the article about\nlambda expressions\nbefore this one.) Expression Trees provide richer interaction with the arguments that are functions.\nYou write function arguments, typically using Lambda Expressions, when you create LINQ queries. In a typical LINQ query, those function arguments are transformed into a delegate the compiler creates.\nYou already write code that uses Expression trees. Entity Framework's LINQ APIs accept Expression trees as the arguments for the LINQ Query Expression Pattern. That enables\nEntity Framework\nto translate the query you wrote in C# into SQL that executes in the database engine. Another example is\nMoq\n, which is a popular mocking framework for .NET.\nWhen you want to have a richer interaction, you need to use\nExpression Trees\n. Expression Trees represent code as a structure that you examine, modify, or execute. These tools give you the power to manipulate code during run time. You write code that examines running algorithms, or injects new capabilities. In more advanced scenarios, you modify running algorithms and even translate C# expressions into another form for execution in another environment.\nYou compile and run code represented by expression trees. Building and running expression trees enables dynamic modification of executable code, the execution of LINQ queries in various databases, and the creation of dynamic queries. For more information about expression trees in LINQ, see\nHow to use expression trees to build dynamic queries\n.\nExpression trees are also used in the dynamic language runtime (DLR) to provide interoperability between dynamic languages and .NET and to enable compiler writers to emit expression trees instead of Microsoft intermediate language (CIL). For more information about the DLR, see\nDynamic Language Runtime Overview\n.\nYou can have the C# or Visual Basic compiler create an expression tree for you based on an anonymous lambda expression, or you can create expression trees manually by using the\nSystem.Linq.Expressions\nnamespace.\nWhen a lambda expression is assigned to a variable of type\nExpression<TDelegate>\n, the compiler emits code to build an expression tree that represents the lambda expression.\nThe following code examples demonstrate how to have the C# compiler create an expression tree that represents the lambda expression\nnum => num < 5\n.\nExpression<Func<int, bool>> lambda = num => num < 5;\nYou create expression trees in your code. You build the tree by creating each node and attaching the nodes into a tree structure. You learn how to create expressions in the article on\nbuilding expression trees\n.\nExpression trees are  immutable. If you want to modify an expression tree, you must construct a new expression tree by copying the existing one and replacing nodes in it. You use an expression tree visitor to traverse the existing expression tree. For more information, see the article on\ntranslating expression trees\n.\nOnce you build an expression tree, you\nexecute the code represented by the expression tree\n.\nLimitations\nThe C# compiler generates expression trees only from expression lambdas (or single-line lambdas). It can't parse statement lambdas (or multi-line lambdas). For more information about lambda expressions in C#, see\nLambda Expressions\n.\nThere are some newer C# language elements that don't translate well into expression trees. Expression trees can't contain\nawait\nexpressions, or\nasync\nlambda expressions. Many of the features added in C# 6 and later don't appear exactly as written in expression trees. Instead, newer features are exposed in expression trees in the equivalent, earlier syntax, where possible. Other constructs aren't available. It means that code that interprets expression trees works the same when new language features are introduced. However, even with these limitations, expression trees do enable you to create dynamic algorithms that rely on interpreting and modifying code that is represented as a data structure. It enables rich libraries such as Entity Framework to accomplish what they do.\nExpression trees won't support new expression node types. It would be a breaking change for all libraries interpreting expression trees to introduce new node types. The following list includes most C# language elements that can't be used:\nConditional methods\nremoved from the output\nbase\naccess\nMethod group expressions, including\naddress-of\n(\n&\n)\na method group, and anonymous method expressions\nReferences to\nlocal functions\nStatements, including assignment (\n=\n) and statement bodied expressions\nPartial methods\nwith only a defining declaration\nUnsafe pointer operations\ndynamic\noperations\nCoalescing operators with\nnull\nor\ndefault\nliteral left side, null coalescing assignment\n, and the\nnull propagating operator (\n?.\n)\nMulti-dimensional array initializers\n,\nindexed properties, and dictionary initializers\nCollection expressions\nthrow\nexpressions\nAccessing\nstatic virtual\nor\nabstract\ninterface members\nLambda expressions that have\nattributes\nInterpolated strings\nUTF-8 string conversions or\nUTF-8 string literals\nMethod invocations using\nvariable arguments\n,\nnamed arguments, or optional arguments\nExpressions using\nSystem.Index\nor\nSystem.Range\n,\nindex \"from end\" (\n^\n) operator\nor\nrange expressions (\n..\n)\nasync\nlambda expressions or\nawait\nexpressions\n, including\nawait foreach\nand\nawait using\nTuple literals, tuple conversions, tuple\n==\nor\n!=\n, or\nwith\nexpressions\nDiscards (\n_\n)\n,\ndeconstructing assignment\n,\npattern matching\nis\noperator, or the pattern matching\nswitch\nexpression\nCOM call with\nref\nomitted on the arguments\nref\n,\nin\nor\nout\nparameters,\nref\nreturn values,\nout\narguments, or any values of\nref struct\ntype\nCollaborate with us on GitHub\nThe source for this content can be found on GitHub, where you can also create and review issues and pull requests. For more information, see\nour contributor guide\n.\n.NET\nOpen a documentation issue\nProvide product feedback\nAdditional resources",
  "code_samples": [
    {
      "language": "csharp",
      "code": "Expression<Func<int, bool>> lambda = num => num < 5;",
      "lines": 1
    },
    {
      "language": "csharp",
      "code": "Expression<Func<int, bool>> lambda = num => num < 5;",
      "lines": 1
    }
  ],
  "collected_at": "2025-06-27T01:19:03.892025"
}