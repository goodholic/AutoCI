{
  "url": "https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/nullable-reference-types",
  "title": "Tutorial: Express your design intent more clearly with nullable and non-nullable reference types",
  "topic": "tutorials/nullable-reference-types",
  "content": "Table of contents\nExit focus mode\nAsk Learn\nAsk Learn\nTable of contents\nRead in English\nAdd\nAdd to plan\nEdit\nShare via\nFacebook\nx.com\nLinkedIn\nEmail\nPrint\nNote\nAccess to this page requires authorization. You can try\nsigning in\nor\nchanging directories\n.\nAccess to this page requires authorization. You can try\nchanging directories\n.\nTutorial: Express your design intent more clearly with nullable and non-nullable reference types\n2022-11-03\nFeedback\nIn this article\nNullable reference types\ncomplement reference types the same way nullable value types complement value types. You declare a variable to be a\nnullable reference type\nby appending a\n?\nto the type. For example,\nstring?\nrepresents a nullable\nstring\n. You can use these new types to more clearly express your design intent: some variables\nmust always have a value\n, others\nmay be missing a value\n.\nIn this tutorial, you'll learn how to:\nIncorporate nullable and non-nullable reference types into your designs\nEnable nullable reference type checks throughout your code.\nWrite code where the compiler enforces those design decisions.\nUse the nullable reference feature in your own designs\nPrerequisites\nThe latest\n.NET SDK\nVisual Studio Code\neditor\nThe\nC# DevKit\nThis tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET CLI.\nIncorporate nullable reference types into your designs\nIn this tutorial, you'll build a library that models running a survey. The code uses both nullable reference types and non-nullable reference types to represent the real-world concepts. The survey questions can never be null. A respondent might prefer not to answer a question. The responses might be\nnull\nin this case.\nThe code you'll write for this sample expresses that intent, and the compiler enforces that intent.\nCreate the application and enable nullable reference types\nCreate a new console application either in Visual Studio or from the command line using\ndotnet new console\n. Name the application\nNullableIntroduction\n. Once you've created the application, you'll need to specify that the entire project compiles in an enabled\nnullable annotation context\n. Open the\n.csproj\nfile and add a\nNullable\nelement to the\nPropertyGroup\nelement. Set its value to\nenable\n. You must opt in to the\nnullable reference types\nfeature in projects earlier than C# 11. That's because once the feature is turned on, existing reference variable declarations become\nnon-nullable reference types\n. While that decision will help find issues where existing code may not have proper null-checks, it may not accurately reflect your original design intent:\n<Nullable>enable</Nullable>\nPrior to .NET 6, new projects do not include the\nNullable\nelement. Beginning with .NET 6, new projects include the\n<Nullable>enable</Nullable>\nelement in the project file.\nDesign the types for the application\nThis survey application requires creating a number of classes:\nA class that models the list of questions.\nA class that models a list of people contacted for the survey.\nA class that models the answers from a person that took the survey.\nThese types will make use of both nullable and non-nullable reference types to express which members are required and which members are optional. Nullable reference types communicate that design intent clearly:\nThe questions that are part of the survey can never be null: It makes no sense to ask an empty question.\nThe respondents can never be null. You'll want to track people you contacted, even respondents that declined to participate.\nAny response to a question may be null. Respondents can decline to answer some or all questions.\nIf you've programmed in C#, you may be so accustomed to reference types that allow\nnull\nvalues that you may have missed other opportunities to declare non-nullable instances:\nThe collection of questions should be non-nullable.\nThe collection of respondents should be non-nullable.\nAs you write the code, you'll see that a non-nullable reference type as the default for references avoids common mistakes that could lead to\nNullReferenceException\ns. One lesson from this tutorial is that you made decisions about which variables could or could not be\nnull\n. The language didn't provide syntax to express those decisions. Now it does.\nThe app you'll build does the following steps:\nCreates a survey and adds questions to it.\nCreates a pseudo-random set of respondents for the survey.\nContacts respondents until the completed survey size reaches the goal number.\nWrites out important statistics on the survey responses.\nBuild the survey with nullable and non-nullable reference types\nThe first code you'll write creates the survey. You'll write classes to model a survey question and a survey run. Your survey has three types of questions, distinguished by the format of the answer: Yes/No answers, number answers, and text answers. Create a\npublic SurveyQuestion\nclass:\nnamespace NullableIntroduction\n{\n    public class SurveyQuestion\n    {\n    }\n}\nThe compiler interprets every reference type variable declaration as a\nnon-nullable\nreference type for code in an enabled nullable annotation context. You can see your first warning by adding properties for the question text and the type of question, as shown in the following code:\nnamespace NullableIntroduction\n{\n    public enum QuestionType\n    {\n        YesNo,\n        Number,\n        Text\n    }\n\n    public class SurveyQuestion\n    {\n        public string QuestionText { get; }\n        public QuestionType TypeOfQuestion { get; }\n    }\n}\nBecause you haven't initialized\nQuestionText\n, the compiler issues a warning that a non-nullable property hasn't been initialized. Your design requires the question text to be non-null, so you add a constructor to initialize it and the\nQuestionType\nvalue as well. The finished class definition looks like the following code:\nnamespace NullableIntroduction;\n\npublic enum QuestionType\n{\n    YesNo,\n    Number,\n    Text\n}\n\npublic class SurveyQuestion\n{\n    public string QuestionText { get; }\n    public QuestionType TypeOfQuestion { get; }\n\n    public SurveyQuestion(QuestionType typeOfQuestion, string text) =>\n        (TypeOfQuestion, QuestionText) = (typeOfQuestion, text);\n}\nAdding the constructor removes the warning. The constructor argument is also a non-nullable reference type, so the compiler doesn't issue any warnings.\nNext, create a\npublic\nclass named\nSurveyRun\n. This class contains a list of\nSurveyQuestion\nobjects and methods to add questions to the survey, as shown in the following code:\nusing System.Collections.Generic;\n\nnamespace NullableIntroduction\n{\n    public class SurveyRun\n    {\n        private List<SurveyQuestion> surveyQuestions = new List<SurveyQuestion>();\n\n        public void AddQuestion(QuestionType type, string question) =>\n            AddQuestion(new SurveyQuestion(type, question));\n        public void AddQuestion(SurveyQuestion surveyQuestion) => surveyQuestions.Add(surveyQuestion);\n    }\n}\nAs before, you must initialize the list object to a non-null value or the compiler issues a warning. There are no null checks in the second overload of\nAddQuestion\nbecause they aren't needed: You've declared that variable to be non-nullable. Its value can't be\nnull\n.\nSwitch to\nProgram.cs\nin your editor and replace the contents of\nMain\nwith the following lines of code:\nvar surveyRun = new SurveyRun();\nsurveyRun.AddQuestion(QuestionType.YesNo, \"Has your code ever thrown a NullReferenceException?\");\nsurveyRun.AddQuestion(new SurveyQuestion(QuestionType.Number, \"How many times (to the nearest 100) has that happened?\"));\nsurveyRun.AddQuestion(QuestionType.Text, \"What is your favorite color?\");\nBecause the entire project is in an enabled nullable annotation context, you'll get warnings when you pass\nnull\nto any method expecting a non-nullable reference type. Try it by adding the following line to\nMain\n:\nsurveyRun.AddQuestion(QuestionType.Text, default);\nCreate respondents and get answers to the survey\nNext, write the code that generates answers to the survey. This process involves several small tasks:\nBuild a method that generates respondent objects. These represent people asked to fill out the survey.\nBuild logic to simulate asking the questions to a respondent and collecting answers or noting that a respondent didn't answer.\nRepeat until enough respondents have answered the survey.\nYou'll need a class to represent a survey response, so add that now. Enable nullable support. Add an\nId\nproperty and a constructor that initializes it, as shown in the following code:\nnamespace NullableIntroduction\n{\n    public class SurveyResponse\n    {\n        public int Id { get; }\n\n        public SurveyResponse(int id) => Id = id;\n    }\n}\nNext, add a\nstatic\nmethod to create new participants by generating a random ID:\nprivate static readonly Random randomGenerator = new Random();\npublic static SurveyResponse GetRandomId() => new SurveyResponse(randomGenerator.Next());\nThe main responsibility of this class is to generate the responses for a participant to the questions in the survey. This responsibility has a few steps:\nAsk for participation in the survey. If the person doesn't consent, return a missing (or null) response.\nAsk each question and record the answer. Each answer may also be missing (or null).\nAdd the following code to your\nSurveyResponse\nclass:\nprivate Dictionary<int, string>? surveyResponses;\npublic bool AnswerSurvey(IEnumerable<SurveyQuestion> questions)\n{\n    if (ConsentToSurvey())\n    {\n        surveyResponses = new Dictionary<int, string>();\n        int index = 0;\n        foreach (var question in questions)\n        {\n            var answer = GenerateAnswer(question);\n            if (answer != null)\n            {\n                surveyResponses.Add(index, answer);\n            }\n            index++;\n        }\n    }\n    return surveyResponses != null;\n}\n\nprivate bool ConsentToSurvey() => randomGenerator.Next(0, 2) == 1;\n\nprivate string? GenerateAnswer(SurveyQuestion question)\n{\n    switch (question.TypeOfQuestion)\n    {\n        case QuestionType.YesNo:\n            int n = randomGenerator.Next(-1, 2);\n            return (n == -1) ? default : (n == 0) ? \"No\" : \"Yes\";\n        case QuestionType.Number:\n            n = randomGenerator.Next(-30, 101);\n            return (n < 0) ? default : n.ToString();\n        case QuestionType.Text:\n        default:\n            switch (randomGenerator.Next(0, 5))\n            {\n                case 0:\n                    return default;\n                case 1:\n                    return \"Red\";\n                case 2:\n                    return \"Green\";\n                case 3:\n                    return \"Blue\";\n            }\n            return \"Red. No, Green. Wait.. Blue... AAARGGGGGHHH!\";\n    }\n}\nThe storage for the survey answers is a\nDictionary<int, string>?\n, indicating that it may be null. You're using the new language feature to declare your design intent, both to the compiler and to anyone reading your code later. If you ever dereference\nsurveyResponses\nwithout checking for the\nnull\nvalue first, you'll get a compiler warning. You don't get a warning in the\nAnswerSurvey\nmethod because the compiler can determine the\nsurveyResponses\nvariable was set to a non-null value above.\nUsing\nnull\nfor missing answers highlights a key point for working with nullable reference types: your goal isn't to remove all\nnull\nvalues from your program. Rather, your goal is to ensure that the code you write expresses the intent of your design. Missing values are a necessary concept to express in your code. The\nnull\nvalue is a clear way to express those missing values. Trying to remove all\nnull\nvalues only leads to defining some other way to express those missing values without\nnull\n.\nNext, you need to write the\nPerformSurvey\nmethod in the\nSurveyRun\nclass. Add the following code in the\nSurveyRun\nclass:\nprivate List<SurveyResponse>? respondents;\npublic void PerformSurvey(int numberOfRespondents)\n{\n    int respondentsConsenting = 0;\n    respondents = new List<SurveyResponse>();\n    while (respondentsConsenting < numberOfRespondents)\n    {\n        var respondent = SurveyResponse.GetRandomId();\n        if (respondent.AnswerSurvey(surveyQuestions))\n            respondentsConsenting++;\n        respondents.Add(respondent);\n    }\n}\nHere again, your choice of a nullable\nList<SurveyResponse>?\nindicates the response may be null. That indicates the survey hasn't been given to any respondents yet. Notice that respondents are added until enough have consented.\nThe last step to run the survey is to add a call to perform the survey at the end of the\nMain\nmethod:\nsurveyRun.PerformSurvey(50);\nExamine survey responses\nThe last step is to display survey results. You'll add code to many of the classes you've written. This code demonstrates the value of distinguishing nullable and non-nullable reference types. Start by adding the following two expression-bodied members to the\nSurveyResponse\nclass:\npublic bool AnsweredSurvey => surveyResponses != null;\npublic string Answer(int index) => surveyResponses?.GetValueOrDefault(index) ?? \"No answer\";\nBecause\nsurveyResponses\nis a nullable reference type, null checks are necessary before de-referencing it. The\nAnswer\nmethod returns a non-nullable string, so we have to cover the case of a missing answer by using the null-coalescing operator.\nNext, add these three expression-bodied members to the\nSurveyRun\nclass:\npublic IEnumerable<SurveyResponse> AllParticipants => (respondents ?? Enumerable.Empty<SurveyResponse>());\npublic ICollection<SurveyQuestion> Questions => surveyQuestions;\npublic SurveyQuestion GetQuestion(int index) => surveyQuestions[index];\nThe\nAllParticipants\nmember must take into account that the\nrespondents\nvariable might be null, but the return value can't be null. If you change that expression by removing the\n??\nand the empty sequence that follows, the compiler warns you the method might return\nnull\nand its return signature returns a non-nullable type.\nFinally, add the following loop at the bottom of the\nMain\nmethod:\nforeach (var participant in surveyRun.AllParticipants)\n{\n    Console.WriteLine($\"Participant: {participant.Id}:\");\n    if (participant.AnsweredSurvey)\n    {\n        for (int i = 0; i < surveyRun.Questions.Count; i++)\n        {\n            var answer = participant.Answer(i);\n            Console.WriteLine($\"\\t{surveyRun.GetQuestion(i).QuestionText} : {answer}\");\n        }\n    }\n    else\n    {\n        Console.WriteLine(\"\\tNo responses\");\n    }\n}\nYou don't need any\nnull\nchecks in this code because you've designed the underlying interfaces so that they all return non-nullable reference types.\nGet the code\nYou can get the code for the finished tutorial from our\nsamples\nrepository in the\ncsharp/NullableIntroduction\nfolder.\nExperiment by changing the type declarations between nullable and non-nullable reference types. See how that generates different warnings to ensure you don't accidentally dereference a\nnull\n.\nNext steps\nLearn how to use nullable reference type when using Entity Framework:\nEntity Framework Core Fundamentals: Working with Nullable Reference Types\nCollaborate with us on GitHub\nThe source for this content can be found on GitHub, where you can also create and review issues and pull requests. For more information, see\nour contributor guide\n.\n.NET\nOpen a documentation issue\nProvide product feedback\nAdditional resources",
  "code_samples": [
    {
      "language": "csharp",
      "code": "namespace NullableIntroduction\n{\n    public class SurveyQuestion\n    {\n    }\n}",
      "lines": 6
    },
    {
      "language": "csharp",
      "code": "namespace NullableIntroduction\n{\n    public class SurveyQuestion\n    {\n    }\n}",
      "lines": 6
    },
    {
      "language": "csharp",
      "code": "namespace NullableIntroduction\n{\n    public enum QuestionType\n    {\n        YesNo,\n        Number,\n        Text\n    }\n\n    public class SurveyQuestion\n    {\n        public string QuestionText { get; }\n        public QuestionType TypeOfQuestion { get; }\n    }\n}",
      "lines": 15
    },
    {
      "language": "csharp",
      "code": "namespace NullableIntroduction\n{\n    public enum QuestionType\n    {\n        YesNo,\n        Number,\n        Text\n    }\n\n    public class SurveyQuestion\n    {\n        public string QuestionText { get; }\n        public QuestionType TypeOfQuestion { get; }\n    }\n}",
      "lines": 15
    },
    {
      "language": "csharp",
      "code": "namespace NullableIntroduction;\n\npublic enum QuestionType\n{\n    YesNo,\n    Number,\n    Text\n}\n\npublic class SurveyQuestion\n{\n    public string QuestionText { get; }\n    public QuestionType TypeOfQuestion { get; }\n\n    public SurveyQuestion(QuestionType typeOfQuestion, string text) =>\n        (TypeOfQuestion, QuestionText) = (typeOfQuestion, text);\n}",
      "lines": 17
    },
    {
      "language": "csharp",
      "code": "namespace NullableIntroduction;\n\npublic enum QuestionType\n{\n    YesNo,\n    Number,\n    Text\n}\n\npublic class SurveyQuestion\n{\n    public string QuestionText { get; }\n    public QuestionType TypeOfQuestion { get; }\n\n    public SurveyQuestion(QuestionType typeOfQuestion, string text) =>\n        (TypeOfQuestion, QuestionText) = (typeOfQuestion, text);\n}",
      "lines": 17
    },
    {
      "language": "csharp",
      "code": "using System.Collections.Generic;\n\nnamespace NullableIntroduction\n{\n    public class SurveyRun\n    {\n        private List<SurveyQuestion> surveyQuestions = new List<SurveyQuestion>();\n\n        public void AddQuestion(QuestionType type, string question) =>\n            AddQuestion(new SurveyQuestion(type, question));\n        public void AddQuestion(SurveyQuestion surveyQuestion) => surveyQuestions.Add(surveyQuestion);\n    }\n}",
      "lines": 13
    },
    {
      "language": "csharp",
      "code": "using System.Collections.Generic;\n\nnamespace NullableIntroduction\n{\n    public class SurveyRun\n    {\n        private List<SurveyQuestion> surveyQuestions = new List<SurveyQuestion>();\n\n        public void AddQuestion(QuestionType type, string question) =>\n            AddQuestion(new SurveyQuestion(type, question));\n        public void AddQuestion(SurveyQuestion surveyQuestion) => surveyQuestions.Add(surveyQuestion);\n    }\n}",
      "lines": 13
    },
    {
      "language": "csharp",
      "code": "var surveyRun = new SurveyRun();\nsurveyRun.AddQuestion(QuestionType.YesNo, \"Has your code ever thrown a NullReferenceException?\");\nsurveyRun.AddQuestion(new SurveyQuestion(QuestionType.Number, \"How many times (to the nearest 100) has that happened?\"));\nsurveyRun.AddQuestion(QuestionType.Text, \"What is your favorite color?\");",
      "lines": 4
    },
    {
      "language": "csharp",
      "code": "var surveyRun = new SurveyRun();\nsurveyRun.AddQuestion(QuestionType.YesNo, \"Has your code ever thrown a NullReferenceException?\");\nsurveyRun.AddQuestion(new SurveyQuestion(QuestionType.Number, \"How many times (to the nearest 100) has that happened?\"));\nsurveyRun.AddQuestion(QuestionType.Text, \"What is your favorite color?\");",
      "lines": 4
    },
    {
      "language": "csharp",
      "code": "namespace NullableIntroduction\n{\n    public class SurveyResponse\n    {\n        public int Id { get; }\n\n        public SurveyResponse(int id) => Id = id;\n    }\n}",
      "lines": 9
    },
    {
      "language": "csharp",
      "code": "namespace NullableIntroduction\n{\n    public class SurveyResponse\n    {\n        public int Id { get; }\n\n        public SurveyResponse(int id) => Id = id;\n    }\n}",
      "lines": 9
    },
    {
      "language": "csharp",
      "code": "private static readonly Random randomGenerator = new Random();\npublic static SurveyResponse GetRandomId() => new SurveyResponse(randomGenerator.Next());",
      "lines": 2
    },
    {
      "language": "csharp",
      "code": "private static readonly Random randomGenerator = new Random();\npublic static SurveyResponse GetRandomId() => new SurveyResponse(randomGenerator.Next());",
      "lines": 2
    },
    {
      "language": "csharp",
      "code": "private Dictionary<int, string>? surveyResponses;\npublic bool AnswerSurvey(IEnumerable<SurveyQuestion> questions)\n{\n    if (ConsentToSurvey())\n    {\n        surveyResponses = new Dictionary<int, string>();\n        int index = 0;\n        foreach (var question in questions)\n        {\n            var answer = GenerateAnswer(question);\n            if (answer != null)\n            {\n                surveyResponses.Add(index, answer);\n            }\n            index++;\n        }\n    }\n    return surveyResponses != null;\n}\n\nprivate bool ConsentToSurvey() => randomGenerator.Next(0, 2) == 1;\n\nprivate string? GenerateAnswer(SurveyQuestion question)\n{\n    switch (question.TypeOfQuestion)\n    {\n        case QuestionType.YesNo:\n            int n = randomGenerator.Next(-1, 2);\n            return (n == -1) ? default : (n == 0) ? \"No\" : \"Yes\";\n        case QuestionType.Number:\n            n = randomGenerator.Next(-30, 101);\n            return (n < 0) ? default : n.ToString();\n        case QuestionType.Text:\n        default:\n            switch (randomGenerator.Next(0, 5))\n            {\n                case 0:\n                    return default;\n                case 1:\n                    return \"Red\";\n                case 2:\n                    return \"Green\";\n                case 3:\n                    return \"Blue\";\n            }\n            return \"Red. No, Green. Wait.. Blue... AAARGGGGGHHH!\";\n    }\n}",
      "lines": 48
    },
    {
      "language": "csharp",
      "code": "private Dictionary<int, string>? surveyResponses;\npublic bool AnswerSurvey(IEnumerable<SurveyQuestion> questions)\n{\n    if (ConsentToSurvey())\n    {\n        surveyResponses = new Dictionary<int, string>();\n        int index = 0;\n        foreach (var question in questions)\n        {\n            var answer = GenerateAnswer(question);\n            if (answer != null)\n            {\n                surveyResponses.Add(index, answer);\n            }\n            index++;\n        }\n    }\n    return surveyResponses != null;\n}\n\nprivate bool ConsentToSurvey() => randomGenerator.Next(0, 2) == 1;\n\nprivate string? GenerateAnswer(SurveyQuestion question)\n{\n    switch (question.TypeOfQuestion)\n    {\n        case QuestionType.YesNo:\n            int n = randomGenerator.Next(-1, 2);\n            return (n == -1) ? default : (n == 0) ? \"No\" : \"Yes\";\n        case QuestionType.Number:\n            n = randomGenerator.Next(-30, 101);\n            return (n < 0) ? default : n.ToString();\n        case QuestionType.Text:\n        default:\n            switch (randomGenerator.Next(0, 5))\n            {\n                case 0:\n                    return default;\n                case 1:\n                    return \"Red\";\n                case 2:\n                    return \"Green\";\n                case 3:\n                    return \"Blue\";\n            }\n            return \"Red. No, Green. Wait.. Blue... AAARGGGGGHHH!\";\n    }\n}",
      "lines": 48
    },
    {
      "language": "csharp",
      "code": "private List<SurveyResponse>? respondents;\npublic void PerformSurvey(int numberOfRespondents)\n{\n    int respondentsConsenting = 0;\n    respondents = new List<SurveyResponse>();\n    while (respondentsConsenting < numberOfRespondents)\n    {\n        var respondent = SurveyResponse.GetRandomId();\n        if (respondent.AnswerSurvey(surveyQuestions))\n            respondentsConsenting++;\n        respondents.Add(respondent);\n    }\n}",
      "lines": 13
    },
    {
      "language": "csharp",
      "code": "private List<SurveyResponse>? respondents;\npublic void PerformSurvey(int numberOfRespondents)\n{\n    int respondentsConsenting = 0;\n    respondents = new List<SurveyResponse>();\n    while (respondentsConsenting < numberOfRespondents)\n    {\n        var respondent = SurveyResponse.GetRandomId();\n        if (respondent.AnswerSurvey(surveyQuestions))\n            respondentsConsenting++;\n        respondents.Add(respondent);\n    }\n}",
      "lines": 13
    },
    {
      "language": "csharp",
      "code": "public bool AnsweredSurvey => surveyResponses != null;\npublic string Answer(int index) => surveyResponses?.GetValueOrDefault(index) ?? \"No answer\";",
      "lines": 2
    },
    {
      "language": "csharp",
      "code": "public bool AnsweredSurvey => surveyResponses != null;\npublic string Answer(int index) => surveyResponses?.GetValueOrDefault(index) ?? \"No answer\";",
      "lines": 2
    },
    {
      "language": "csharp",
      "code": "public IEnumerable<SurveyResponse> AllParticipants => (respondents ?? Enumerable.Empty<SurveyResponse>());\npublic ICollection<SurveyQuestion> Questions => surveyQuestions;\npublic SurveyQuestion GetQuestion(int index) => surveyQuestions[index];",
      "lines": 3
    },
    {
      "language": "csharp",
      "code": "public IEnumerable<SurveyResponse> AllParticipants => (respondents ?? Enumerable.Empty<SurveyResponse>());\npublic ICollection<SurveyQuestion> Questions => surveyQuestions;\npublic SurveyQuestion GetQuestion(int index) => surveyQuestions[index];",
      "lines": 3
    },
    {
      "language": "csharp",
      "code": "foreach (var participant in surveyRun.AllParticipants)\n{\n    Console.WriteLine($\"Participant: {participant.Id}:\");\n    if (participant.AnsweredSurvey)\n    {\n        for (int i = 0; i < surveyRun.Questions.Count; i++)\n        {\n            var answer = participant.Answer(i);\n            Console.WriteLine($\"\\t{surveyRun.GetQuestion(i).QuestionText} : {answer}\");\n        }\n    }\n    else\n    {\n        Console.WriteLine(\"\\tNo responses\");\n    }\n}",
      "lines": 16
    },
    {
      "language": "csharp",
      "code": "foreach (var participant in surveyRun.AllParticipants)\n{\n    Console.WriteLine($\"Participant: {participant.Id}:\");\n    if (participant.AnsweredSurvey)\n    {\n        for (int i = 0; i < surveyRun.Questions.Count; i++)\n        {\n            var answer = participant.Answer(i);\n            Console.WriteLine($\"\\t{surveyRun.GetQuestion(i).QuestionText} : {answer}\");\n        }\n    }\n    else\n    {\n        Console.WriteLine(\"\\tNo responses\");\n    }\n}",
      "lines": 16
    }
  ],
  "collected_at": "2025-06-25T19:29:01.015552"
}