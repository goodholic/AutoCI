{
  "url": "https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/",
  "title": "Asynchronous programming scenarios",
  "topic": "programming-guide/concepts/async/",
  "content": "Table of contents\nExit focus mode\nAsk Learn\nAsk Learn\nTable of contents\nRead in English\nAdd\nAdd to plan\nEdit\nShare via\nFacebook\nx.com\nLinkedIn\nEmail\nPrint\nNote\nAccess to this page requires authorization. You can try\nsigning in\nor\nchanging directories\n.\nAccess to this page requires authorization. You can try\nchanging directories\n.\nAsynchronous programming scenarios\n2025-03-14\nFeedback\nIn this article\nIf your code implements I/O-bound scenarios to support network data requests, database access, or file system read/writes, asynchronous programming is the best approach. You can also write asynchronous code for CPU-bound scenarios like expensive calculations.\nC# has a language-level asynchronous programming model that allows you to easily write asynchronous code without having to juggle callbacks or conform to a library that supports asynchrony. The model follows what is known as the\nTask-based asynchronous pattern (TAP)\n.\nExplore the asynchronous programming model\nThe\nTask\nand\nTask<T>\nobjects represent the core of asynchronous programming. These objects are used to model asynchronous operations by supporting the\nasync\nand\nawait\nkeywords. In most cases, the model is fairly simple for both I/O-bound and CPU-bound scenarios. Inside an\nasync\nmethod:\nI/O-bound code\nstarts an operation represented by a\nTask\nor\nTask<T>\nobject within the\nasync\nmethod.\nCPU-bound code\nstarts an operation on a background thread with the\nTask.Run\nmethod.\nIn both cases, an active\nTask\nrepresents an asynchronous operation that might not be complete.\nThe\nawait\nkeyword is where the magic happens. It yields control to the caller of the method that contains the\nawait\nexpression, and ultimately allows the UI to be responsive or a service to be elastic. While\nthere are ways\nto approach asynchronous code other than by using the\nasync\nand\nawait\nexpressions, this article focuses on the language-level constructs.\nNote\nSome examples presented in this article use the\nSystem.Net.Http.HttpClient\nclass to download data from a web service. In the example code, the\ns_httpClient\nobject is a static field of type\nProgram\nclass:\nprivate static readonly HttpClient s_httpClient = new();\nFor more information, see the\ncomplete example code\nat the end of this article.\nReview underlying concepts\nWhen you implement asynchronous programming in your C# code, the compiler transforms your program into a state machine. This construct tracks various operations and state in your code, such as yielding execution when the code reaches an\nawait\nexpression, and resuming execution when a background job completes.\nIn terms of computer science theory, asynchronous programming is an implementation of the\nPromise model of asynchrony\n.\nIn the asynchronous programming model, there are several key concepts to understand:\nYou can use asynchronous code for both I/O-bound and CPU-bound code, but the implementation is different.\nAsynchronous code uses\nTask<T>\nand\nTask\nobjects as constructs to model work running in the background.\nThe\nasync\nkeyword declares a method as an asynchronous method, which allows you to use the\nawait\nkeyword in the method body.\nWhen you apply the\nawait\nkeyword, the code suspends the calling method and yields control back to its caller until the task completes.\nYou can only use the\nawait\nexpression in an asynchronous method.\nI/O-bound example: Download data from web service\nIn this example, when the user selects a button, the app downloads data from a web service. You don't want to block the UI thread for the app during the download process. The following code accomplishes this task:\ns_downloadButton.Clicked += async (o, e) =>\n{\n    // This line will yield control to the UI as the request\n    // from the web service is happening.\n    //\n    // The UI thread is now free to perform other work.\n    var stringData = await s_httpClient.GetStringAsync(URL);\n    DoSomethingWithData(stringData);\n};\nThe code expresses the intent (downloading data asynchronously) without getting bogged down in interacting with\nTask\nobjects.\nCPU-bound example: Run game calculation\nIn the next example, a mobile game inflicts damage on several agents on the screen in response to a button event. Performing the damage calculation can be expensive. Running the calculation on the UI thread can cause display and UI interaction issues during the calculation.\nThe best way to handle the task is to start a background thread to complete the work with the\nTask.Run\nmethod. The operation yields by using an\nawait\nexpression. The operation resumes when the task completes. This approach allows the UI to run smoothly while the work completes in the background.\nstatic DamageResult CalculateDamageDone()\n{\n    return new DamageResult()\n    {\n        // Code omitted:\n        //\n        // Does an expensive calculation and returns\n        // the result of that calculation.\n    };\n}\n\ns_calculateButton.Clicked += async (o, e) =>\n{\n    // This line will yield control to the UI while CalculateDamageDone()\n    // performs its work. The UI thread is free to perform other work.\n    var damageResult = await Task.Run(() => CalculateDamageDone());\n    DisplayDamage(damageResult);\n};\nThe code clearly expresses the intent of the button\nClicked\nevent. It doesn't require managing a background thread manually, and it completes the task in a nonblocking manner.\nRecognize CPU-bound and I/O-bound scenarios\nThe previous examples demonstrate how to use the\nasync\nmodifier and\nawait\nexpression for I/O-bound and CPU-bound work. An example for each scenario showcases how the code is different based on where the operation is bound. To prepare for your implementation, you need to understand how to identify when an operation is I/O-bound or CPU-bound. Your implementation choice can greatly affect the performance of your code and potentially lead to misusing constructs.\nThere are two primary questions to address before you write any code:\nQuestion\nScenario\nImplementation\nShould the code wait for a result or action, such as data from a database?\nI/O-bound\nUse the\nasync\nmodifier and\nawait\nexpression\nwithout\nthe\nTask.Run\nmethod.\nAvoid using the Task Parallel Library.\nShould the code run an expensive computation?\nCPU-bound\nUse the\nasync\nmodifier and\nawait\nexpression, but spawn off the work on another thread with the\nTask.Run\nmethod. This approach addresses concerns with CPU responsiveness.\nIf the work is appropriate for concurrency and parallelism, also consider using the\nTask Parallel Library\n.\nAlways measure the execution of your code. You might discover that your CPU-bound work isn't costly enough compared with the overhead of context switches when multithreading. Every choice has tradeoffs. Pick the correct tradeoff for your situation.\nExplore other examples\nThe examples in this section demonstrate several ways you can write asynchronous code in C#. They cover a few scenarios you might encounter.\nExtract data from a network\nThe following code downloads HTML from a given URL and counts the number of times the string \".NET\" occurs in the HTML. The code uses ASP.NET to define a Web API controller method, which performs the task and returns the count.\nNote\nIf you plan on doing HTML parsing in production code, don't use regular expressions. Use a parsing library instead.\n[HttpGet, Route(\"DotNetCount\")]\nstatic public async Task<int> GetDotNetCount(string URL)\n{\n    // Suspends GetDotNetCount() to allow the caller (the web server)\n    // to accept another request, rather than blocking on this one.\n    var html = await s_httpClient.GetStringAsync(URL);\n    return Regex.Matches(html, @\"\\.NET\").Count;\n}\nYou can write similar code for a Universal Windows App and perform the counting task after a button press:\nprivate readonly HttpClient _httpClient = new HttpClient();\n\nprivate async void OnSeeTheDotNetsButtonClick(object sender, RoutedEventArgs e)\n{\n    // Capture the task handle here so we can await the background task later.\n    var getDotNetFoundationHtmlTask = _httpClient.GetStringAsync(\"https://dotnetfoundation.org\");\n\n    // Any other work on the UI thread can be done here, such as enabling a Progress Bar.\n    // It's important to do the extra work here before the \"await\" call,\n    // so the user sees the progress bar before execution of this method is yielded.\n    NetworkProgressBar.IsEnabled = true;\n    NetworkProgressBar.Visibility = Visibility.Visible;\n\n    // The await operator suspends OnSeeTheDotNetsButtonClick(), returning control to its caller.\n    // This action is what allows the app to be responsive and not block the UI thread.\n    var html = await getDotNetFoundationHtmlTask;\n    int count = Regex.Matches(html, @\"\\.NET\").Count;\n\n    DotNetCountLabel.Text = $\"Number of .NETs on dotnetfoundation.org: {count}\";\n\n    NetworkProgressBar.IsEnabled = false;\n    NetworkProgressBar.Visibility = Visibility.Collapsed;\n}\nWait for multiple tasks to complete\nIn some scenarios, the code needs to retrieve multiple pieces of data concurrently. The\nTask\nAPIs provide methods that enable you to write asynchronous code that performs a nonblocking wait on multiple background jobs:\nTask.WhenAll\nmethod\nTask.WhenAny\nmethod\nThe following example shows how you might grab\nUser\nobject data for a set of\nuserId\nobjects.\nprivate static async Task<User> GetUserAsync(int userId)\n{\n    // Code omitted:\n    //\n    // Given a user Id {userId}, retrieves a User object corresponding\n    // to the entry in the database with {userId} as its Id.\n\n    return await Task.FromResult(new User() { id = userId });\n}\n\nprivate static async Task<IEnumerable<User>> GetUsersAsync(IEnumerable<int> userIds)\n{\n    var getUserTasks = new List<Task<User>>();\n    foreach (int userId in userIds)\n    {\n        getUserTasks.Add(GetUserAsync(userId));\n    }\n\n    return await Task.WhenAll(getUserTasks);\n}\nYou can write this code more succinctly by using LINQ:\nprivate static async Task<User[]> GetUsersAsyncByLINQ(IEnumerable<int> userIds)\n{\n    var getUserTasks = userIds.Select(id => GetUserAsync(id)).ToArray();\n    return await Task.WhenAll(getUserTasks);\n}\nAlthough you write less code by using LINQ, exercise caution when mixing LINQ with asynchronous code. LINQ uses deferred (or lazy) execution. Asynchronous calls don't happen immediately as they do in a\nforeach\nloop, unless you force the generated sequence to iterate with a call to the\n.ToList()\nor\n.ToArray()\nmethod. This example uses the\nEnumerable.ToArray\nmethod to perform the query eagerly and store the results in an array. This approach forces the\nid => GetUserAsync(id)\nstatement to run and initiate the task.\nReview considerations for asynchronous programming\nWith asynchronous programming, there are several details to keep in mind that can prevent unexpected behavior.\nUse await inside async() method body\nWhen you use the\nasync\nmodifier, you should include one or more\nawait\nexpressions in the method body. If the compiler doesn't encounter an\nawait\nexpression, the method fails to yield. Although the compiler generates a warning, the code still compiles and the compiler runs the method. The state machine generated by the C# compiler for the asynchronous method doesn't accomplish anything, so the entire process is highly inefficient.\nAdd \"Async\" suffix to asynchronous method names\nThe .NET style convention is to add the \"Async\" suffix to all asynchronous method names. This approach helps to more easily differentiate between synchronous and asynchronous methods. Certain methods that aren't explicitly called by your code (such as event handlers or web controller methods) don't necessarily apply in this scenario. Because these items aren't explicitly called by your code, using explicit naming isn't as important.\nReturn 'async void' only from event handlers\nEvent handlers must declare\nvoid\nreturn types and can't use or return\nTask\nand\nTask<T>\nobjects as other methods do. When you write asynchronous event handlers, you need to use the\nasync\nmodifier on a\nvoid\nreturning method for the handlers. Other implementations of\nasync void\nreturning methods don't follow the TAP model and can present challenges:\nExceptions thrown in an\nasync void\nmethod can't be caught outside of that method\nasync void\nmethods are difficult to test\nasync void\nmethods can cause negative side effects if the caller isn't expecting them to be asynchronous\nUse caution with asynchronous lambdas in LINQ\nIt's important to use caution when you implement asynchronous lambdas in LINQ expressions. Lambda expressions in LINQ use deferred execution, which means the code can execute at an unexpected time. The introduction of blocking tasks into this scenario can easily result in a deadlock, if the code isn't written correctly. Moreover, the nesting of asynchronous code can also make it difficult to reason about the execution of the code. Async and LINQ are powerful, but these techniques should be used together as carefully and clearly as possible.\nYield for tasks in a nonblocking manner\nIf your program needs the result of a task, write code that implements the\nawait\nexpression in a nonblocking manner. Blocking the current thread as a means to wait synchronously for a\nTask\nitem to complete can result in deadlocks and blocked context threads. This programming approach can require more complex error-handling. The following table provides guidance on how access results from tasks in a nonblocking way:\nTask scenario\nCurrent code\nReplace with 'await'\nRetrieve the result of a background task\nTask.Wait\nor\nTask.Result\nawait\nContinue when any task completes\nTask.WaitAny\nawait Task.WhenAny\nContinue when\nall\ntasks complete\nTask.WaitAll\nawait Task.WhenAll\nContinue after some amount of time\nThread.Sleep\nawait Task.Delay\nConsider using ValueTask type\nWhen an asynchronous method returns a\nTask\nobject, performance bottlenecks might be introduced in certain paths. Because\nTask\nis a reference type, a\nTask\nobject is allocated from the heap. If a method declared with the\nasync\nmodifier returns a cached result or completes synchronously, the extra allocations can accrue significant time costs in performance critical sections of code. This scenario can become costly when the allocations occur in tight loops. For more information, see\ngeneralized async return types\n.\nUnderstand when to set ConfigureAwait(false)\nDevelopers often inquire about when to use the\nTask.ConfigureAwait(Boolean)\nboolean. This API allows for a\nTask\ninstance to configure the context for the state machine that implements any\nawait\nexpression. When the boolean isn't set correctly, performance can degrade or deadlocks can occur. For more information, see\nConfigureAwait FAQ\n.\nWrite less-stateful code\nAvoid writing code that depends on the state of global objects or the execution of certain methods. Instead, depend only on the return values of methods. There are many benefits to writing code that is less-stateful:\nEasier to reason about code\nEasier to test code\nMore simple to mix asynchronous and synchronous code\nAble to avoid race conditions in code\nSimple to coordinate asynchronous code that depends on return values\n(Bonus) Works well with dependency injection in code\nA recommended goal is to achieve complete or near-complete\nReferential Transparency\nin your code. This approach results in a predictable, testable, and maintainable codebase.\nReview the complete example\nThe following code represents the complete example, which is available in the\nProgram.cs\nexample file.\nusing System.Text.RegularExpressions;\nusing System.Windows;\nusing Microsoft.AspNetCore.Mvc;\n\nclass Button\n{\n    public Func<object, object, Task>? Clicked\n    {\n        get;\n        internal set;\n    }\n}\n\nclass DamageResult\n{\n    public int Damage\n    {\n        get { return 0; }\n    }\n}\n\nclass User\n{\n    public bool isEnabled\n    {\n        get;\n        set;\n    }\n\n    public int id\n    {\n        get;\n        set;\n    }\n}\n\npublic class Program\n{\n    private static readonly Button s_downloadButton = new();\n    private static readonly Button s_calculateButton = new();\n\n    private static readonly HttpClient s_httpClient = new();\n\n    private static readonly IEnumerable<string> s_urlList = new string[]\n    {\n            \"https://learn.microsoft.com\",\n            \"https://learn.microsoft.com/aspnet/core\",\n            \"https://learn.microsoft.com/azure\",\n            \"https://learn.microsoft.com/azure/devops\",\n            \"https://learn.microsoft.com/dotnet\",\n            \"https://learn.microsoft.com/dotnet/desktop/wpf/get-started/create-app-visual-studio\",\n            \"https://learn.microsoft.com/education\",\n            \"https://learn.microsoft.com/shows/net-core-101/what-is-net\",\n            \"https://learn.microsoft.com/enterprise-mobility-security\",\n            \"https://learn.microsoft.com/gaming\",\n            \"https://learn.microsoft.com/graph\",\n            \"https://learn.microsoft.com/microsoft-365\",\n            \"https://learn.microsoft.com/office\",\n            \"https://learn.microsoft.com/powershell\",\n            \"https://learn.microsoft.com/sql\",\n            \"https://learn.microsoft.com/surface\",\n            \"https://dotnetfoundation.org\",\n            \"https://learn.microsoft.com/visualstudio\",\n            \"https://learn.microsoft.com/windows\",\n            \"https://learn.microsoft.com/maui\"\n    };\n\n    private static void Calculate()\n    {\n        // <PerformGameCalculation>\n        static DamageResult CalculateDamageDone()\n        {\n            return new DamageResult()\n            {\n                // Code omitted:\n                //\n                // Does an expensive calculation and returns\n                // the result of that calculation.\n            };\n        }\n\n        s_calculateButton.Clicked += async (o, e) =>\n        {\n            // This line will yield control to the UI while CalculateDamageDone()\n            // performs its work. The UI thread is free to perform other work.\n            var damageResult = await Task.Run(() => CalculateDamageDone());\n            DisplayDamage(damageResult);\n        };\n        // </PerformGameCalculation>\n    }\n\n    private static void DisplayDamage(DamageResult damage)\n    {\n        Console.WriteLine(damage.Damage);\n    }\n\n    private static void Download(string URL)\n    {\n        // <UnblockingDownload>\n        s_downloadButton.Clicked += async (o, e) =>\n        {\n            // This line will yield control to the UI as the request\n            // from the web service is happening.\n            //\n            // The UI thread is now free to perform other work.\n            var stringData = await s_httpClient.GetStringAsync(URL);\n            DoSomethingWithData(stringData);\n        };\n        // </UnblockingDownload>\n    }\n\n    private static void DoSomethingWithData(object stringData)\n    {\n        Console.WriteLine($\"Displaying data: {stringData}\");\n    }\n\n    // <GetUsersForDataset>\n    private static async Task<User> GetUserAsync(int userId)\n    {\n        // Code omitted:\n        //\n        // Given a user Id {userId}, retrieves a User object corresponding\n        // to the entry in the database with {userId} as its Id.\n\n        return await Task.FromResult(new User() { id = userId });\n    }\n\n    private static async Task<IEnumerable<User>> GetUsersAsync(IEnumerable<int> userIds)\n    {\n        var getUserTasks = new List<Task<User>>();\n        foreach (int userId in userIds)\n        {\n            getUserTasks.Add(GetUserAsync(userId));\n        }\n\n        return await Task.WhenAll(getUserTasks);\n    }\n    // </GetUsersForDataset>\n\n    // <GetUsersForDatasetByLINQ>\n    private static async Task<User[]> GetUsersAsyncByLINQ(IEnumerable<int> userIds)\n    {\n        var getUserTasks = userIds.Select(id => GetUserAsync(id)).ToArray();\n        return await Task.WhenAll(getUserTasks);\n    }\n    // </GetUsersForDatasetByLINQ>\n\n    // <ExtractDataFromNetwork>\n    [HttpGet, Route(\"DotNetCount\")]\n    static public async Task<int> GetDotNetCount(string URL)\n    {\n        // Suspends GetDotNetCount() to allow the caller (the web server)\n        // to accept another request, rather than blocking on this one.\n        var html = await s_httpClient.GetStringAsync(URL);\n        return Regex.Matches(html, @\"\\.NET\").Count;\n    }\n    // </ExtractDataFromNetwork>\n\n    static async Task Main()\n    {\n        Console.WriteLine(\"Application started.\");\n\n        Console.WriteLine(\"Counting '.NET' phrase in websites...\");\n        int total = 0;\n        foreach (string url in s_urlList)\n        {\n            var result = await GetDotNetCount(url);\n            Console.WriteLine($\"{url}: {result}\");\n            total += result;\n        }\n        Console.WriteLine(\"Total: \" + total);\n\n        Console.WriteLine(\"Retrieving User objects with list of IDs...\");\n        IEnumerable<int> ids = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n        var users = await GetUsersAsync(ids);\n        foreach (User? user in users)\n        {\n            Console.WriteLine($\"{user.id}: isEnabled={user.isEnabled}\");\n        }\n\n        Console.WriteLine(\"Application ending.\");\n    }\n}\n\n// Example output:\n//\n// Application started.\n// Counting '.NET' phrase in websites...\n// https://learn.microsoft.com: 0\n// https://learn.microsoft.com/aspnet/core: 57\n// https://learn.microsoft.com/azure: 1\n// https://learn.microsoft.com/azure/devops: 2\n// https://learn.microsoft.com/dotnet: 83\n// https://learn.microsoft.com/dotnet/desktop/wpf/get-started/create-app-visual-studio: 31\n// https://learn.microsoft.com/education: 0\n// https://learn.microsoft.com/shows/net-core-101/what-is-net: 42\n// https://learn.microsoft.com/enterprise-mobility-security: 0\n// https://learn.microsoft.com/gaming: 0\n// https://learn.microsoft.com/graph: 0\n// https://learn.microsoft.com/microsoft-365: 0\n// https://learn.microsoft.com/office: 0\n// https://learn.microsoft.com/powershell: 0\n// https://learn.microsoft.com/sql: 0\n// https://learn.microsoft.com/surface: 0\n// https://dotnetfoundation.org: 16\n// https://learn.microsoft.com/visualstudio: 0\n// https://learn.microsoft.com/windows: 0\n// https://learn.microsoft.com/maui: 6\n// Total: 238\n// Retrieving User objects with list of IDs...\n// 1: isEnabled= False\n// 2: isEnabled= False\n// 3: isEnabled= False\n// 4: isEnabled= False\n// 5: isEnabled= False\n// 6: isEnabled= False\n// 7: isEnabled= False\n// 8: isEnabled= False\n// 9: isEnabled= False\n// 0: isEnabled= False\n// Application ending.\nRelated links\nThe Task asynchronous programming model (C#)\nCollaborate with us on GitHub\nThe source for this content can be found on GitHub, where you can also create and review issues and pull requests. For more information, see\nour contributor guide\n.\n.NET\nOpen a documentation issue\nProvide product feedback\nAdditional resources",
  "code_samples": [
    {
      "language": "csharp",
      "code": "private static readonly HttpClient s_httpClient = new();",
      "lines": 1
    },
    {
      "language": "csharp",
      "code": "s_downloadButton.Clicked += async (o, e) =>\n{\n    // This line will yield control to the UI as the request\n    // from the web service is happening.\n    //\n    // The UI thread is now free to perform other work.\n    var stringData = await s_httpClient.GetStringAsync(URL);\n    DoSomethingWithData(stringData);\n};",
      "lines": 9
    },
    {
      "language": "csharp",
      "code": "s_downloadButton.Clicked += async (o, e) =>\n{\n    // This line will yield control to the UI as the request\n    // from the web service is happening.\n    //\n    // The UI thread is now free to perform other work.\n    var stringData = await s_httpClient.GetStringAsync(URL);\n    DoSomethingWithData(stringData);\n};",
      "lines": 9
    },
    {
      "language": "csharp",
      "code": "static DamageResult CalculateDamageDone()\n{\n    return new DamageResult()\n    {\n        // Code omitted:\n        //\n        // Does an expensive calculation and returns\n        // the result of that calculation.\n    };\n}\n\ns_calculateButton.Clicked += async (o, e) =>\n{\n    // This line will yield control to the UI while CalculateDamageDone()\n    // performs its work. The UI thread is free to perform other work.\n    var damageResult = await Task.Run(() => CalculateDamageDone());\n    DisplayDamage(damageResult);\n};",
      "lines": 18
    },
    {
      "language": "csharp",
      "code": "static DamageResult CalculateDamageDone()\n{\n    return new DamageResult()\n    {\n        // Code omitted:\n        //\n        // Does an expensive calculation and returns\n        // the result of that calculation.\n    };\n}\n\ns_calculateButton.Clicked += async (o, e) =>\n{\n    // This line will yield control to the UI while CalculateDamageDone()\n    // performs its work. The UI thread is free to perform other work.\n    var damageResult = await Task.Run(() => CalculateDamageDone());\n    DisplayDamage(damageResult);\n};",
      "lines": 18
    },
    {
      "language": "csharp",
      "code": "[HttpGet, Route(\"DotNetCount\")]\nstatic public async Task<int> GetDotNetCount(string URL)\n{\n    // Suspends GetDotNetCount() to allow the caller (the web server)\n    // to accept another request, rather than blocking on this one.\n    var html = await s_httpClient.GetStringAsync(URL);\n    return Regex.Matches(html, @\"\\.NET\").Count;\n}",
      "lines": 8
    },
    {
      "language": "csharp",
      "code": "[HttpGet, Route(\"DotNetCount\")]\nstatic public async Task<int> GetDotNetCount(string URL)\n{\n    // Suspends GetDotNetCount() to allow the caller (the web server)\n    // to accept another request, rather than blocking on this one.\n    var html = await s_httpClient.GetStringAsync(URL);\n    return Regex.Matches(html, @\"\\.NET\").Count;\n}",
      "lines": 8
    },
    {
      "language": "csharp",
      "code": "private readonly HttpClient _httpClient = new HttpClient();\n\nprivate async void OnSeeTheDotNetsButtonClick(object sender, RoutedEventArgs e)\n{\n    // Capture the task handle here so we can await the background task later.\n    var getDotNetFoundationHtmlTask = _httpClient.GetStringAsync(\"https://dotnetfoundation.org\");\n\n    // Any other work on the UI thread can be done here, such as enabling a Progress Bar.\n    // It's important to do the extra work here before the \"await\" call,\n    // so the user sees the progress bar before execution of this method is yielded.\n    NetworkProgressBar.IsEnabled = true;\n    NetworkProgressBar.Visibility = Visibility.Visible;\n\n    // The await operator suspends OnSeeTheDotNetsButtonClick(), returning control to its caller.\n    // This action is what allows the app to be responsive and not block the UI thread.\n    var html = await getDotNetFoundationHtmlTask;\n    int count = Regex.Matches(html, @\"\\.NET\").Count;\n\n    DotNetCountLabel.Text = $\"Number of .NETs on dotnetfoundation.org: {count}\";\n\n    NetworkProgressBar.IsEnabled = false;\n    NetworkProgressBar.Visibility = Visibility.Collapsed;\n}",
      "lines": 23
    },
    {
      "language": "csharp",
      "code": "private readonly HttpClient _httpClient = new HttpClient();\n\nprivate async void OnSeeTheDotNetsButtonClick(object sender, RoutedEventArgs e)\n{\n    // Capture the task handle here so we can await the background task later.\n    var getDotNetFoundationHtmlTask = _httpClient.GetStringAsync(\"https://dotnetfoundation.org\");\n\n    // Any other work on the UI thread can be done here, such as enabling a Progress Bar.\n    // It's important to do the extra work here before the \"await\" call,\n    // so the user sees the progress bar before execution of this method is yielded.\n    NetworkProgressBar.IsEnabled = true;\n    NetworkProgressBar.Visibility = Visibility.Visible;\n\n    // The await operator suspends OnSeeTheDotNetsButtonClick(), returning control to its caller.\n    // This action is what allows the app to be responsive and not block the UI thread.\n    var html = await getDotNetFoundationHtmlTask;\n    int count = Regex.Matches(html, @\"\\.NET\").Count;\n\n    DotNetCountLabel.Text = $\"Number of .NETs on dotnetfoundation.org: {count}\";\n\n    NetworkProgressBar.IsEnabled = false;\n    NetworkProgressBar.Visibility = Visibility.Collapsed;\n}",
      "lines": 23
    },
    {
      "language": "csharp",
      "code": "private static async Task<User> GetUserAsync(int userId)\n{\n    // Code omitted:\n    //\n    // Given a user Id {userId}, retrieves a User object corresponding\n    // to the entry in the database with {userId} as its Id.\n\n    return await Task.FromResult(new User() { id = userId });\n}\n\nprivate static async Task<IEnumerable<User>> GetUsersAsync(IEnumerable<int> userIds)\n{\n    var getUserTasks = new List<Task<User>>();\n    foreach (int userId in userIds)\n    {\n        getUserTasks.Add(GetUserAsync(userId));\n    }\n\n    return await Task.WhenAll(getUserTasks);\n}",
      "lines": 20
    },
    {
      "language": "csharp",
      "code": "private static async Task<User> GetUserAsync(int userId)\n{\n    // Code omitted:\n    //\n    // Given a user Id {userId}, retrieves a User object corresponding\n    // to the entry in the database with {userId} as its Id.\n\n    return await Task.FromResult(new User() { id = userId });\n}\n\nprivate static async Task<IEnumerable<User>> GetUsersAsync(IEnumerable<int> userIds)\n{\n    var getUserTasks = new List<Task<User>>();\n    foreach (int userId in userIds)\n    {\n        getUserTasks.Add(GetUserAsync(userId));\n    }\n\n    return await Task.WhenAll(getUserTasks);\n}",
      "lines": 20
    },
    {
      "language": "csharp",
      "code": "private static async Task<User[]> GetUsersAsyncByLINQ(IEnumerable<int> userIds)\n{\n    var getUserTasks = userIds.Select(id => GetUserAsync(id)).ToArray();\n    return await Task.WhenAll(getUserTasks);\n}",
      "lines": 5
    },
    {
      "language": "csharp",
      "code": "private static async Task<User[]> GetUsersAsyncByLINQ(IEnumerable<int> userIds)\n{\n    var getUserTasks = userIds.Select(id => GetUserAsync(id)).ToArray();\n    return await Task.WhenAll(getUserTasks);\n}",
      "lines": 5
    },
    {
      "language": "csharp",
      "code": "using System.Text.RegularExpressions;\nusing System.Windows;\nusing Microsoft.AspNetCore.Mvc;\n\nclass Button\n{\n    public Func<object, object, Task>? Clicked\n    {\n        get;\n        internal set;\n    }\n}\n\nclass DamageResult\n{\n    public int Damage\n    {\n        get { return 0; }\n    }\n}\n\nclass User\n{\n    public bool isEnabled\n    {\n        get;\n        set;\n    }\n\n    public int id\n    {\n        get;\n        set;\n    }\n}\n\npublic class Program\n{\n    private static readonly Button s_downloadButton = new();\n    private static readonly Button s_calculateButton = new();\n\n    private static readonly HttpClient s_httpClient = new();\n\n    private static readonly IEnumerable<string> s_urlList = new string[]\n    {\n            \"https://learn.microsoft.com\",\n            \"https://learn.microsoft.com/aspnet/core\",\n            \"https://learn.microsoft.com/azure\",\n            \"https://learn.microsoft.com/azure/devops\",\n            \"https://learn.microsoft.com/dotnet\",\n            \"https://learn.microsoft.com/dotnet/desktop/wpf/get-started/create-app-visual-studio\",\n            \"https://learn.microsoft.com/education\",\n            \"https://learn.microsoft.com/shows/net-core-101/what-is-net\",\n            \"https://learn.microsoft.com/enterprise-mobility-security\",\n            \"https://learn.microsoft.com/gaming\",\n            \"https://learn.microsoft.com/graph\",\n            \"https://learn.microsoft.com/microsoft-365\",\n            \"https://learn.microsoft.com/office\",\n            \"https://learn.microsoft.com/powershell\",\n            \"https://learn.microsoft.com/sql\",\n            \"https://learn.microsoft.com/surface\",\n            \"https://dotnetfoundation.org\",\n            \"https://learn.microsoft.com/visualstudio\",\n            \"https://learn.microsoft.com/windows\",\n            \"https://learn.microsoft.com/maui\"\n    };\n\n    private static void Calculate()\n    {\n        // <PerformGameCalculation>\n        static DamageResult CalculateDamageDone()\n        {\n            return new DamageResult()\n            {\n                // Code omitted:\n                //\n                // Does an expensive calculation and returns\n                // the result of that calculation.\n            };\n        }\n\n        s_calculateButton.Clicked += async (o, e) =>\n        {\n            // This line will yield control to the UI while CalculateDamageDone()\n            // performs its work. The UI thread is free to perform other work.\n            var damageResult = await Task.Run(() => CalculateDamageDone());\n            DisplayDamage(damageResult);\n        };\n        // </PerformGameCalculation>\n    }\n\n    private static void DisplayDamage(DamageResult damage)\n    {\n        Console.WriteLine(damage.Damage);\n    }\n\n    private static void Download(string URL)\n    {\n        // <UnblockingDownload>\n        s_downloadButton.Clicked += async (o, e) =>\n        {\n            // This line will yield control to the UI as the request\n            // from the web service is happening.\n            //\n            // The UI thread is now free to perform other work.\n            var stringData = await s_httpClient.GetStringAsync(URL);\n            DoSomethingWithData(stringData);\n        };\n        // </UnblockingDownload>\n    }\n\n    private static void DoSomethingWithData(object stringData)\n    {\n        Console.WriteLine($\"Displaying data: {stringData}\");\n    }\n\n    // <GetUsersForDataset>\n    private static async Task<User> GetUserAsync(int userId)\n    {\n        // Code omitted:\n        //\n        // Given a user Id {userId}, retrieves a User object corresponding\n        // to the entry in the database with {userId} as its Id.\n\n        return await Task.FromResult(new User() { id = userId });\n    }\n\n    private static async Task<IEnumerable<User>> GetUsersAsync(IEnumerable<int> userIds)\n    {\n        var getUserTasks = new List<Task<User>>();\n        foreach (int userId in userIds)\n        {\n            getUserTasks.Add(GetUserAsync(userId));\n        }\n\n        return await Task.WhenAll(getUserTasks);\n    }\n    // </GetUsersForDataset>\n\n    // <GetUsersForDatasetByLINQ>\n    private static async Task<User[]> GetUsersAsyncByLINQ(IEnumerable<int> userIds)\n    {\n        var getUserTasks = userIds.Select(id => GetUserAsync(id)).ToArray();\n        return await Task.WhenAll(getUserTasks);\n    }\n    // </GetUsersForDatasetByLINQ>\n\n    // <ExtractDataFromNetwork>\n    [HttpGet, Route(\"DotNetCount\")]\n    static public async Task<int> GetDotNetCount(string URL)\n    {\n        // Suspends GetDotNetCount() to allow the caller (the web server)\n        // to accept another request, rather than blocking on this one.\n        var html = await s_httpClient.GetStringAsync(URL);\n        return Regex.Matches(html, @\"\\.NET\").Count;\n    }\n    // </ExtractDataFromNetwork>\n\n    static async Task Main()\n    {\n        Console.WriteLine(\"Application started.\");\n\n        Console.WriteLine(\"Counting '.NET' phrase in websites...\");\n        int total = 0;\n        foreach (string url in s_urlList)\n        {\n            var result = await GetDotNetCount(url);\n            Console.WriteLine($\"{url}: {result}\");\n            total += result;\n        }\n        Console.WriteLine(\"Total: \" + total);\n\n        Console.WriteLine(\"Retrieving User objects with list of IDs...\");\n        IEnumerable<int> ids = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n        var users = await GetUsersAsync(ids);\n        foreach (User? user in users)\n        {\n            Console.WriteLine($\"{user.id}: isEnabled={user.isEnabled}\");\n        }\n\n        Console.WriteLine(\"Application ending.\");\n    }\n}\n\n// Example output:\n//\n// Application started.\n// Counting '.NET' phrase in websites...\n// https://learn.microsoft.com: 0\n// https://learn.microsoft.com/aspnet/core: 57\n// https://learn.microsoft.com/azure: 1\n// https://learn.microsoft.com/azure/devops: 2\n// https://learn.microsoft.com/dotnet: 83\n// https://learn.microsoft.com/dotnet/desktop/wpf/get-started/create-app-visual-studio: 31\n// https://learn.microsoft.com/education: 0\n// https://learn.microsoft.com/shows/net-core-101/what-is-net: 42\n// https://learn.microsoft.com/enterprise-mobility-security: 0\n// https://learn.microsoft.com/gaming: 0\n// https://learn.microsoft.com/graph: 0\n// https://learn.microsoft.com/microsoft-365: 0\n// https://learn.microsoft.com/office: 0\n// https://learn.microsoft.com/powershell: 0\n// https://learn.microsoft.com/sql: 0\n// https://learn.microsoft.com/surface: 0\n// https://dotnetfoundation.org: 16\n// https://learn.microsoft.com/visualstudio: 0\n// https://learn.microsoft.com/windows: 0\n// https://learn.microsoft.com/maui: 6\n// Total: 238\n// Retrieving User objects with list of IDs...\n// 1: isEnabled= False\n// 2: isEnabled= False\n// 3: isEnabled= False\n// 4: isEnabled= False\n// 5: isEnabled= False\n// 6: isEnabled= False\n// 7: isEnabled= False\n// 8: isEnabled= False\n// 9: isEnabled= False\n// 0: isEnabled= False\n// Application ending.",
      "lines": 221
    },
    {
      "language": "csharp",
      "code": "using System.Text.RegularExpressions;\nusing System.Windows;\nusing Microsoft.AspNetCore.Mvc;\n\nclass Button\n{\n    public Func<object, object, Task>? Clicked\n    {\n        get;\n        internal set;\n    }\n}\n\nclass DamageResult\n{\n    public int Damage\n    {\n        get { return 0; }\n    }\n}\n\nclass User\n{\n    public bool isEnabled\n    {\n        get;\n        set;\n    }\n\n    public int id\n    {\n        get;\n        set;\n    }\n}\n\npublic class Program\n{\n    private static readonly Button s_downloadButton = new();\n    private static readonly Button s_calculateButton = new();\n\n    private static readonly HttpClient s_httpClient = new();\n\n    private static readonly IEnumerable<string> s_urlList = new string[]\n    {\n            \"https://learn.microsoft.com\",\n            \"https://learn.microsoft.com/aspnet/core\",\n            \"https://learn.microsoft.com/azure\",\n            \"https://learn.microsoft.com/azure/devops\",\n            \"https://learn.microsoft.com/dotnet\",\n            \"https://learn.microsoft.com/dotnet/desktop/wpf/get-started/create-app-visual-studio\",\n            \"https://learn.microsoft.com/education\",\n            \"https://learn.microsoft.com/shows/net-core-101/what-is-net\",\n            \"https://learn.microsoft.com/enterprise-mobility-security\",\n            \"https://learn.microsoft.com/gaming\",\n            \"https://learn.microsoft.com/graph\",\n            \"https://learn.microsoft.com/microsoft-365\",\n            \"https://learn.microsoft.com/office\",\n            \"https://learn.microsoft.com/powershell\",\n            \"https://learn.microsoft.com/sql\",\n            \"https://learn.microsoft.com/surface\",\n            \"https://dotnetfoundation.org\",\n            \"https://learn.microsoft.com/visualstudio\",\n            \"https://learn.microsoft.com/windows\",\n            \"https://learn.microsoft.com/maui\"\n    };\n\n    private static void Calculate()\n    {\n        // <PerformGameCalculation>\n        static DamageResult CalculateDamageDone()\n        {\n            return new DamageResult()\n            {\n                // Code omitted:\n                //\n                // Does an expensive calculation and returns\n                // the result of that calculation.\n            };\n        }\n\n        s_calculateButton.Clicked += async (o, e) =>\n        {\n            // This line will yield control to the UI while CalculateDamageDone()\n            // performs its work. The UI thread is free to perform other work.\n            var damageResult = await Task.Run(() => CalculateDamageDone());\n            DisplayDamage(damageResult);\n        };\n        // </PerformGameCalculation>\n    }\n\n    private static void DisplayDamage(DamageResult damage)\n    {\n        Console.WriteLine(damage.Damage);\n    }\n\n    private static void Download(string URL)\n    {\n        // <UnblockingDownload>\n        s_downloadButton.Clicked += async (o, e) =>\n        {\n            // This line will yield control to the UI as the request\n            // from the web service is happening.\n            //\n            // The UI thread is now free to perform other work.\n            var stringData = await s_httpClient.GetStringAsync(URL);\n            DoSomethingWithData(stringData);\n        };\n        // </UnblockingDownload>\n    }\n\n    private static void DoSomethingWithData(object stringData)\n    {\n        Console.WriteLine($\"Displaying data: {stringData}\");\n    }\n\n    // <GetUsersForDataset>\n    private static async Task<User> GetUserAsync(int userId)\n    {\n        // Code omitted:\n        //\n        // Given a user Id {userId}, retrieves a User object corresponding\n        // to the entry in the database with {userId} as its Id.\n\n        return await Task.FromResult(new User() { id = userId });\n    }\n\n    private static async Task<IEnumerable<User>> GetUsersAsync(IEnumerable<int> userIds)\n    {\n        var getUserTasks = new List<Task<User>>();\n        foreach (int userId in userIds)\n        {\n            getUserTasks.Add(GetUserAsync(userId));\n        }\n\n        return await Task.WhenAll(getUserTasks);\n    }\n    // </GetUsersForDataset>\n\n    // <GetUsersForDatasetByLINQ>\n    private static async Task<User[]> GetUsersAsyncByLINQ(IEnumerable<int> userIds)\n    {\n        var getUserTasks = userIds.Select(id => GetUserAsync(id)).ToArray();\n        return await Task.WhenAll(getUserTasks);\n    }\n    // </GetUsersForDatasetByLINQ>\n\n    // <ExtractDataFromNetwork>\n    [HttpGet, Route(\"DotNetCount\")]\n    static public async Task<int> GetDotNetCount(string URL)\n    {\n        // Suspends GetDotNetCount() to allow the caller (the web server)\n        // to accept another request, rather than blocking on this one.\n        var html = await s_httpClient.GetStringAsync(URL);\n        return Regex.Matches(html, @\"\\.NET\").Count;\n    }\n    // </ExtractDataFromNetwork>\n\n    static async Task Main()\n    {\n        Console.WriteLine(\"Application started.\");\n\n        Console.WriteLine(\"Counting '.NET' phrase in websites...\");\n        int total = 0;\n        foreach (string url in s_urlList)\n        {\n            var result = await GetDotNetCount(url);\n            Console.WriteLine($\"{url}: {result}\");\n            total += result;\n        }\n        Console.WriteLine(\"Total: \" + total);\n\n        Console.WriteLine(\"Retrieving User objects with list of IDs...\");\n        IEnumerable<int> ids = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n        var users = await GetUsersAsync(ids);\n        foreach (User? user in users)\n        {\n            Console.WriteLine($\"{user.id}: isEnabled={user.isEnabled}\");\n        }\n\n        Console.WriteLine(\"Application ending.\");\n    }\n}\n\n// Example output:\n//\n// Application started.\n// Counting '.NET' phrase in websites...\n// https://learn.microsoft.com: 0\n// https://learn.microsoft.com/aspnet/core: 57\n// https://learn.microsoft.com/azure: 1\n// https://learn.microsoft.com/azure/devops: 2\n// https://learn.microsoft.com/dotnet: 83\n// https://learn.microsoft.com/dotnet/desktop/wpf/get-started/create-app-visual-studio: 31\n// https://learn.microsoft.com/education: 0\n// https://learn.microsoft.com/shows/net-core-101/what-is-net: 42\n// https://learn.microsoft.com/enterprise-mobility-security: 0\n// https://learn.microsoft.com/gaming: 0\n// https://learn.microsoft.com/graph: 0\n// https://learn.microsoft.com/microsoft-365: 0\n// https://learn.microsoft.com/office: 0\n// https://learn.microsoft.com/powershell: 0\n// https://learn.microsoft.com/sql: 0\n// https://learn.microsoft.com/surface: 0\n// https://dotnetfoundation.org: 16\n// https://learn.microsoft.com/visualstudio: 0\n// https://learn.microsoft.com/windows: 0\n// https://learn.microsoft.com/maui: 6\n// Total: 238\n// Retrieving User objects with list of IDs...\n// 1: isEnabled= False\n// 2: isEnabled= False\n// 3: isEnabled= False\n// 4: isEnabled= False\n// 5: isEnabled= False\n// 6: isEnabled= False\n// 7: isEnabled= False\n// 8: isEnabled= False\n// 9: isEnabled= False\n// 0: isEnabled= False\n// Application ending.",
      "lines": 221
    }
  ],
  "collected_at": "2025-06-25T19:28:47.173486"
}