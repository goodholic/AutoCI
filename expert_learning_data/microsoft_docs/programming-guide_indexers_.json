{
  "url": "https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/indexers/",
  "title": "Indexers",
  "topic": "programming-guide/indexers/",
  "content": "Table of contents\nExit focus mode\nAsk Learn\nAsk Learn\nTable of contents\nRead in English\nAdd\nAdd to plan\nEdit\nShare via\nFacebook\nx.com\nLinkedIn\nEmail\nPrint\nNote\nAccess to this page requires authorization. You can try\nsigning in\nor\nchanging directories\n.\nAccess to this page requires authorization. You can try\nchanging directories\n.\nIndexers\n2024-08-23\nFeedback\nIn this article\nYou define\nindexers\nwhen instances of a class or struct can be indexed like an array or other collection. The indexed value can be set or retrieved without explicitly specifying a type or instance member. Indexers resemble\nproperties\nexcept that their accessors take parameters.\nThe following example defines a generic class with\nget\nand\nset\naccessor methods to assign and retrieve values.\nnamespace Indexers;\n\npublic class SampleCollection<T>\n{\n   // Declare an array to store the data elements.\n   private T[] arr = new T[100];\n\n   // Define the indexer to allow client code to use [] notation.\n   public T this[int i]\n   {\n      get => arr[i];\n      set => arr[i] = value;\n   }\n}\nThe preceding example shows a read / write indexer. It contains both the\nget\nand\nset\naccessors. You can define read only indexers as an expression bodied member, as shown in the following examples:\nnamespace Indexers;\n\npublic class ReadOnlySampleCollection<T>(params IEnumerable<T> items)\n{\n   // Declare an array to store the data elements.\n   private T[] arr = [.. items];\n\n   public T this[int i] => arr[i];\n\n}\nThe\nget\nkeyword isn't used;\n=>\nintroduces the expression body.\nIndexers enable\nindexed\nproperties: properties referenced using one or more arguments. Those arguments provide an index into some collection of values.\nIndexers enable objects to be indexed similar to arrays.\nA\nget\naccessor returns a value. A\nset\naccessor assigns a value.\nThe\nthis\nkeyword defines the indexer.\nThe\nvalue\nkeyword is the argument to the\nset\naccessor.\nIndexers don't require an integer index value; it's up to you how to define the specific look-up mechanism.\nIndexers can be overloaded.\nIndexers can have one or more formal parameters, for example, when accessing a two-dimensional array.\nYou can declare\npartial\nindexers\nin\npartial\ntypes\n.\nYou can apply almost everything you learned from working with properties to indexers. The only exception to that rule is\nautomatically implemented properties\n. The compiler can't always generate the correct storage for an indexer. You can define multiple indexers on a type, as long as the argument lists for each indexer is unique.\nUses of indexers\nYou define\nindexers\nin your type when its API models some collection. Your indexer isn't required to map directly to the collection types that are part of the .NET core framework. Indexers enable you to provide the API that matches your type's abstraction without exposing the inner details of how the values for that abstraction are stored or computed.\nArrays and Vectors\nYour type might model an array or a vector. The advantage of creating your own indexer is that you can define the storage for that collection to suit your needs. Imagine a scenario where your type models historical data that is too large to load into memory at once. You need to load and unload sections of the collection based on usage. The example following models this behavior. It reports on how many data points exist. It creates pages to hold sections of the data on demand. It removes pages from memory to make room for pages needed by more recent requests.\nnamespace Indexers;\n\npublic record Measurements(double HiTemp, double LoTemp, double AirPressure);\n\npublic class DataSamples\n{\n    private class Page\n    {\n        private readonly List<Measurements> pageData = new ();\n        private readonly int _startingIndex;\n        private readonly int _length;\n\n        public Page(int startingIndex, int length)\n        {\n            _startingIndex = startingIndex;\n            _length = length;\n\n            // This stays as random stuff:\n            var generator = new Random();\n            for (int i = 0; i < length; i++)\n            {\n                var m = new Measurements(HiTemp: generator.Next(50, 95),\n                    LoTemp: generator.Next(12, 49),\n                    AirPressure: 28.0 + generator.NextDouble() * 4\n                );\n                pageData.Add(m);\n            }\n        }\n        public bool HasItem(int index) =>\n            ((index >= _startingIndex) &&\n            (index < _startingIndex + _length));\n\n        public Measurements this[int index]\n        {\n            get\n            {\n                LastAccess = DateTime.Now;\n                return pageData[index - _startingIndex];\n            }\n            set\n            {\n                pageData[index - _startingIndex] = value;\n                Dirty = true;\n                LastAccess = DateTime.Now;\n            }\n        }\n\n        public bool Dirty { get; private set; } = false;\n        public DateTime LastAccess { get; set; } = DateTime.Now;\n    }\n\n    private readonly int _totalSize;\n    private readonly List<Page> pagesInMemory = new ();\n\n    public DataSamples(int totalSize)\n    {\n        this._totalSize = totalSize;\n    }\n\n    public Measurements this[int index]\n    {\n        get\n        {\n            if (index < 0) throw new IndexOutOfRangeException(\"Cannot index less than 0\");\n            if (index >= _totalSize) throw new IndexOutOfRangeException(\"Cannot index past the end of storage\");\n\n            var page = updateCachedPagesForAccess(index);\n            return page[index];\n        }\n        set\n        {\n            if (index < 0) throw new IndexOutOfRangeException(\"Cannot index less than 0\");\n            if (index >= _totalSize) throw new IndexOutOfRangeException(\"Cannot index past the end of storage\");\n            var page = updateCachedPagesForAccess(index);\n\n            page[index] = value;\n        }\n    }\n\n    private Page updateCachedPagesForAccess(int index)\n    {\n        foreach (var p in pagesInMemory)\n        {\n            if (p.HasItem(index))\n            {\n                return p;\n            }\n        }\n        var startingIndex = (index / 1000) * 1000;\n        var newPage = new Page(startingIndex, 1000);\n        addPageToCache(newPage);\n        return newPage;\n    }\n\n    private void addPageToCache(Page p)\n    {\n        if (pagesInMemory.Count > 4)\n        {\n            // remove oldest non-dirty page:\n            var oldest = pagesInMemory\n                .Where(page => !page.Dirty)\n                .OrderBy(page => page.LastAccess)\n                .FirstOrDefault();\n            // Note that this may keep more than 5 pages in memory\n            // if too much is dirty\n            if (oldest != null)\n                pagesInMemory.Remove(oldest);\n        }\n        pagesInMemory.Add(p);\n    }\n}\nYou can follow this design idiom to model any sort of collection where there are good reasons not to load the entire set of data into an in-memory collection. Notice that the\nPage\nclass is a private nested class that isn't part of the public interface. Those details are hidden from users of this class.\nDictionaries\nAnother common scenario is when you need to model a dictionary or a map. This scenario is when your type stores values based on key, possibly text keys. This example creates a dictionary that maps command line arguments to\nlambda expressions\nthat manage those options. The following example shows two classes: an\nArgsActions\nclass that maps a command line option to an\nSystem.Action\ndelegate, and an\nArgsProcessor\nthat uses the\nArgsActions\nto execute each\nAction\nwhen it encounters that option.\nnamespace Indexers;\npublic class ArgsProcessor\n{\n    private readonly ArgsActions _actions;\n\n    public ArgsProcessor(ArgsActions actions)\n    {\n        _actions = actions;\n    }\n\n    public void Process(string[] args)\n    {\n        foreach (var arg in args)\n        {\n            _actions[arg]?.Invoke();\n        }\n    }\n\n}\npublic class ArgsActions\n{\n    readonly private Dictionary<string, Action> _argsActions = new();\n\n    public Action this[string s]\n    {\n        get\n        {\n            Action? action;\n            Action defaultAction = () => { };\n            return _argsActions.TryGetValue(s, out action) ? action : defaultAction;\n        }\n    }\n\n    public void SetOption(string s, Action a)\n    {\n        _argsActions[s] = a;\n    }\n}\nIn this example, the\nArgsAction\ncollection maps closely to the underlying collection. The\nget\ndetermines if a given option is configured. If so, it returns the\nAction\nassociated with that option. If not, it returns an\nAction\nthat does nothing. The public accessor doesn't include a\nset\naccessor. Rather, the design is using a public method for setting options.\nMulti-Dimensional Maps\nYou can create indexers that use multiple arguments. In addition, those arguments aren't constrained to be the same type.\nThe following example shows a class that generates values for a Mandelbrot set. For more information on the mathematics behind the set, read\nthis article\n. The indexer uses two doubles to define a point in the X, Y plane. The\nget\naccessor computes the number of iterations until a point is determined to be not in the set. When the maximum number of iterations is reached, the point is in the set, and the class's maxIterations value is returned. (The computer generated images popularized for the Mandelbrot set define colors for the number of iterations necessary to determine that a point is outside the set.)\nnamespace Indexers;\npublic class Mandelbrot(int maxIterations)\n{\n\n    public int this[double x, double y]\n    {\n        get\n        {\n            var iterations = 0;\n            var x0 = x;\n            var y0 = y;\n\n            while ((x * x + y * y < 4) &&\n                (iterations < maxIterations))\n            { \n                (x, y) = (x * x - y * y + x0, 2 * x * y + y0);\n                iterations++;\n            }\n            return iterations;\n        }\n    }\n}\nThe Mandelbrot Set defines values at every (x,y) coordinate for real number values. That defines a dictionary that could contain an infinite number of values. Therefore, there's no storage behind the set. Instead, this class computes the value for each point when code calls the\nget\naccessor. There's no underlying storage used.\nSumming Up\nYou create indexers anytime you have a property-like element in your class where that property represents not a single value, but rather a set of values. One or more arguments identify each individual item. Those arguments can uniquely identify which item in the set should be referenced. Indexers extend the concept of\nproperties\n, where a member is treated like a data item from outside the class, but like a method on the inside. Indexers allow arguments to find a single item in a property that represents a set of items.\nYou can access the\nsample folder for indexers\n. For download instructions, see\nSamples and Tutorials\n.\nC# Language Specification\nFor more information, see\nIndexers\nin the\nC# Language Specification\n. The language specification is the definitive source for C# syntax and usage.\nCollaborate with us on GitHub\nThe source for this content can be found on GitHub, where you can also create and review issues and pull requests. For more information, see\nour contributor guide\n.\n.NET\nOpen a documentation issue\nProvide product feedback\nAdditional resources",
  "code_samples": [
    {
      "language": "csharp",
      "code": "namespace Indexers;\n\npublic class SampleCollection<T>\n{\n   // Declare an array to store the data elements.\n   private T[] arr = new T[100];\n\n   // Define the indexer to allow client code to use [] notation.\n   public T this[int i]\n   {\n      get => arr[i];\n      set => arr[i] = value;\n   }\n}",
      "lines": 14
    },
    {
      "language": "csharp",
      "code": "namespace Indexers;\n\npublic class SampleCollection<T>\n{\n   // Declare an array to store the data elements.\n   private T[] arr = new T[100];\n\n   // Define the indexer to allow client code to use [] notation.\n   public T this[int i]\n   {\n      get => arr[i];\n      set => arr[i] = value;\n   }\n}",
      "lines": 14
    },
    {
      "language": "csharp",
      "code": "namespace Indexers;\n\npublic class ReadOnlySampleCollection<T>(params IEnumerable<T> items)\n{\n   // Declare an array to store the data elements.\n   private T[] arr = [.. items];\n\n   public T this[int i] => arr[i];\n\n}",
      "lines": 10
    },
    {
      "language": "csharp",
      "code": "namespace Indexers;\n\npublic class ReadOnlySampleCollection<T>(params IEnumerable<T> items)\n{\n   // Declare an array to store the data elements.\n   private T[] arr = [.. items];\n\n   public T this[int i] => arr[i];\n\n}",
      "lines": 10
    },
    {
      "language": "csharp",
      "code": "namespace Indexers;\n\npublic record Measurements(double HiTemp, double LoTemp, double AirPressure);\n\npublic class DataSamples\n{\n    private class Page\n    {\n        private readonly List<Measurements> pageData = new ();\n        private readonly int _startingIndex;\n        private readonly int _length;\n\n        public Page(int startingIndex, int length)\n        {\n            _startingIndex = startingIndex;\n            _length = length;\n\n            // This stays as random stuff:\n            var generator = new Random();\n            for (int i = 0; i < length; i++)\n            {\n                var m = new Measurements(HiTemp: generator.Next(50, 95),\n                    LoTemp: generator.Next(12, 49),\n                    AirPressure: 28.0 + generator.NextDouble() * 4\n                );\n                pageData.Add(m);\n            }\n        }\n        public bool HasItem(int index) =>\n            ((index >= _startingIndex) &&\n            (index < _startingIndex + _length));\n\n        public Measurements this[int index]\n        {\n            get\n            {\n                LastAccess = DateTime.Now;\n                return pageData[index - _startingIndex];\n            }\n            set\n            {\n                pageData[index - _startingIndex] = value;\n                Dirty = true;\n                LastAccess = DateTime.Now;\n            }\n        }\n\n        public bool Dirty { get; private set; } = false;\n        public DateTime LastAccess { get; set; } = DateTime.Now;\n    }\n\n    private readonly int _totalSize;\n    private readonly List<Page> pagesInMemory = new ();\n\n    public DataSamples(int totalSize)\n    {\n        this._totalSize = totalSize;\n    }\n\n    public Measurements this[int index]\n    {\n        get\n        {\n            if (index < 0) throw new IndexOutOfRangeException(\"Cannot index less than 0\");\n            if (index >= _totalSize) throw new IndexOutOfRangeException(\"Cannot index past the end of storage\");\n\n            var page = updateCachedPagesForAccess(index);\n            return page[index];\n        }\n        set\n        {\n            if (index < 0) throw new IndexOutOfRangeException(\"Cannot index less than 0\");\n            if (index >= _totalSize) throw new IndexOutOfRangeException(\"Cannot index past the end of storage\");\n            var page = updateCachedPagesForAccess(index);\n\n            page[index] = value;\n        }\n    }\n\n    private Page updateCachedPagesForAccess(int index)\n    {\n        foreach (var p in pagesInMemory)\n        {\n            if (p.HasItem(index))\n            {\n                return p;\n            }\n        }\n        var startingIndex = (index / 1000) * 1000;\n        var newPage = new Page(startingIndex, 1000);\n        addPageToCache(newPage);\n        return newPage;\n    }\n\n    private void addPageToCache(Page p)\n    {\n        if (pagesInMemory.Count > 4)\n        {\n            // remove oldest non-dirty page:\n            var oldest = pagesInMemory\n                .Where(page => !page.Dirty)\n                .OrderBy(page => page.LastAccess)\n                .FirstOrDefault();\n            // Note that this may keep more than 5 pages in memory\n            // if too much is dirty\n            if (oldest != null)\n                pagesInMemory.Remove(oldest);\n        }\n        pagesInMemory.Add(p);\n    }\n}",
      "lines": 111
    },
    {
      "language": "csharp",
      "code": "namespace Indexers;\n\npublic record Measurements(double HiTemp, double LoTemp, double AirPressure);\n\npublic class DataSamples\n{\n    private class Page\n    {\n        private readonly List<Measurements> pageData = new ();\n        private readonly int _startingIndex;\n        private readonly int _length;\n\n        public Page(int startingIndex, int length)\n        {\n            _startingIndex = startingIndex;\n            _length = length;\n\n            // This stays as random stuff:\n            var generator = new Random();\n            for (int i = 0; i < length; i++)\n            {\n                var m = new Measurements(HiTemp: generator.Next(50, 95),\n                    LoTemp: generator.Next(12, 49),\n                    AirPressure: 28.0 + generator.NextDouble() * 4\n                );\n                pageData.Add(m);\n            }\n        }\n        public bool HasItem(int index) =>\n            ((index >= _startingIndex) &&\n            (index < _startingIndex + _length));\n\n        public Measurements this[int index]\n        {\n            get\n            {\n                LastAccess = DateTime.Now;\n                return pageData[index - _startingIndex];\n            }\n            set\n            {\n                pageData[index - _startingIndex] = value;\n                Dirty = true;\n                LastAccess = DateTime.Now;\n            }\n        }\n\n        public bool Dirty { get; private set; } = false;\n        public DateTime LastAccess { get; set; } = DateTime.Now;\n    }\n\n    private readonly int _totalSize;\n    private readonly List<Page> pagesInMemory = new ();\n\n    public DataSamples(int totalSize)\n    {\n        this._totalSize = totalSize;\n    }\n\n    public Measurements this[int index]\n    {\n        get\n        {\n            if (index < 0) throw new IndexOutOfRangeException(\"Cannot index less than 0\");\n            if (index >= _totalSize) throw new IndexOutOfRangeException(\"Cannot index past the end of storage\");\n\n            var page = updateCachedPagesForAccess(index);\n            return page[index];\n        }\n        set\n        {\n            if (index < 0) throw new IndexOutOfRangeException(\"Cannot index less than 0\");\n            if (index >= _totalSize) throw new IndexOutOfRangeException(\"Cannot index past the end of storage\");\n            var page = updateCachedPagesForAccess(index);\n\n            page[index] = value;\n        }\n    }\n\n    private Page updateCachedPagesForAccess(int index)\n    {\n        foreach (var p in pagesInMemory)\n        {\n            if (p.HasItem(index))\n            {\n                return p;\n            }\n        }\n        var startingIndex = (index / 1000) * 1000;\n        var newPage = new Page(startingIndex, 1000);\n        addPageToCache(newPage);\n        return newPage;\n    }\n\n    private void addPageToCache(Page p)\n    {\n        if (pagesInMemory.Count > 4)\n        {\n            // remove oldest non-dirty page:\n            var oldest = pagesInMemory\n                .Where(page => !page.Dirty)\n                .OrderBy(page => page.LastAccess)\n                .FirstOrDefault();\n            // Note that this may keep more than 5 pages in memory\n            // if too much is dirty\n            if (oldest != null)\n                pagesInMemory.Remove(oldest);\n        }\n        pagesInMemory.Add(p);\n    }\n}",
      "lines": 111
    },
    {
      "language": "csharp",
      "code": "namespace Indexers;\npublic class ArgsProcessor\n{\n    private readonly ArgsActions _actions;\n\n    public ArgsProcessor(ArgsActions actions)\n    {\n        _actions = actions;\n    }\n\n    public void Process(string[] args)\n    {\n        foreach (var arg in args)\n        {\n            _actions[arg]?.Invoke();\n        }\n    }\n\n}\npublic class ArgsActions\n{\n    readonly private Dictionary<string, Action> _argsActions = new();\n\n    public Action this[string s]\n    {\n        get\n        {\n            Action? action;\n            Action defaultAction = () => { };\n            return _argsActions.TryGetValue(s, out action) ? action : defaultAction;\n        }\n    }\n\n    public void SetOption(string s, Action a)\n    {\n        _argsActions[s] = a;\n    }\n}",
      "lines": 38
    },
    {
      "language": "csharp",
      "code": "namespace Indexers;\npublic class ArgsProcessor\n{\n    private readonly ArgsActions _actions;\n\n    public ArgsProcessor(ArgsActions actions)\n    {\n        _actions = actions;\n    }\n\n    public void Process(string[] args)\n    {\n        foreach (var arg in args)\n        {\n            _actions[arg]?.Invoke();\n        }\n    }\n\n}\npublic class ArgsActions\n{\n    readonly private Dictionary<string, Action> _argsActions = new();\n\n    public Action this[string s]\n    {\n        get\n        {\n            Action? action;\n            Action defaultAction = () => { };\n            return _argsActions.TryGetValue(s, out action) ? action : defaultAction;\n        }\n    }\n\n    public void SetOption(string s, Action a)\n    {\n        _argsActions[s] = a;\n    }\n}",
      "lines": 38
    },
    {
      "language": "csharp",
      "code": "namespace Indexers;\npublic class Mandelbrot(int maxIterations)\n{\n\n    public int this[double x, double y]\n    {\n        get\n        {\n            var iterations = 0;\n            var x0 = x;\n            var y0 = y;\n\n            while ((x * x + y * y < 4) &&\n                (iterations < maxIterations))\n            { \n                (x, y) = (x * x - y * y + x0, 2 * x * y + y0);\n                iterations++;\n            }\n            return iterations;\n        }\n    }\n}",
      "lines": 22
    },
    {
      "language": "csharp",
      "code": "namespace Indexers;\npublic class Mandelbrot(int maxIterations)\n{\n\n    public int this[double x, double y]\n    {\n        get\n        {\n            var iterations = 0;\n            var x0 = x;\n            var y0 = y;\n\n            while ((x * x + y * y < 4) &&\n                (iterations < maxIterations))\n            { \n                (x, y) = (x * x - y * y + x0, 2 * x * y + y0);\n                iterations++;\n            }\n            return iterations;\n        }\n    }\n}",
      "lines": 22
    }
  ],
  "collected_at": "2025-06-25T19:28:54.648799"
}