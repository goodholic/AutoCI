{
  "url": "https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/",
  "title": "Interfaces - define behavior for multiple types",
  "topic": "programming-guide/interfaces/",
  "content": "Table of contents\nExit focus mode\nAsk Learn\nAsk Learn\nTable of contents\nRead in English\nAdd\nAdd to plan\nEdit\nShare via\nFacebook\nx.com\nLinkedIn\nEmail\nPrint\nNote\nAccess to this page requires authorization. You can try\nsigning in\nor\nchanging directories\n.\nAccess to this page requires authorization. You can try\nchanging directories\n.\nInterfaces - define behavior for multiple types\n2023-03-18\nFeedback\nIn this article\nAn interface contains definitions for a group of related functionalities that a non-abstract\nclass\nor a\nstruct\nmust implement. An interface may define\nstatic\nmethods, which must have an implementation. An interface may define a default implementation for members. An interface may not declare instance data such as fields, automatically implemented properties, or property-like events.\nBy using interfaces, you can, for example, include behavior from multiple sources in a class. That capability is important in C# because the language doesn't support multiple inheritance of classes. In addition, you must use an interface if you want to simulate inheritance for structs, because they can't actually inherit from another struct or class.\nYou define an interface by using the\ninterface\nkeyword as the following example shows.\ninterface IEquatable<T>\n{\n    bool Equals(T obj);\n}\nThe name of an interface must be a valid C#\nidentifier name\n. By convention, interface names begin with a capital\nI\n.\nAny class or struct that implements the\nIEquatable<T>\ninterface must contain a definition for an\nEquals\nmethod that matches the signature that the interface specifies. As a result, you can count on a class of type\nT\nthat implements\nIEquatable<T>\nto contain an\nEquals\nmethod with which an instance of this class can determine whether it's equal to another instance of the same class.\nThe definition of\nIEquatable<T>\ndoesn't provide an implementation for\nEquals\n. A class or struct can implement multiple interfaces, but a class can only inherit from a single class.\nFor more information about abstract classes, see\nAbstract and Sealed Classes and Class Members\n.\nInterfaces can contain instance methods, properties, events, indexers, or any combination of those four member types. Interfaces may contain static constructors, fields, constants, or operators. Beginning with C# 11, interface members that aren't fields may be\nstatic abstract\n. An interface can't contain instance fields, instance constructors, or finalizers. Interface members are public by default, and you can explicitly specify accessibility modifiers, such as\npublic\n,\nprotected\n,\ninternal\n,\nprivate\n,\nprotected internal\n, or\nprivate protected\n. A\nprivate\nmember must have a default implementation.\nTo implement an interface member, the corresponding member of the implementing class must be public, non-static, and have the same name and signature as the interface member.\nNote\nWhen an interface declares static members, a type implementing that interface may also declare static members with the same signature. Those are distinct and uniquely identified by the type declaring the member. The static member declared in a type\ndoesn't\noverride the static member declared in the interface.\nA class or struct that implements an interface must provide an implementation for all declared members without a default implementation provided by the interface. However, if a base class implements an interface, any class that's derived from the base class inherits that implementation.\nThe following example shows an implementation of the\nIEquatable<T>\ninterface. The implementing class,\nCar\n, must provide an implementation of the\nEquals\nmethod.\npublic class Car : IEquatable<Car>\n{\n    public string? Make { get; set; }\n    public string? Model { get; set; }\n    public string? Year { get; set; }\n\n    // Implementation of IEquatable<T> interface\n    public bool Equals(Car? car)\n    {\n        return (this.Make, this.Model, this.Year) ==\n            (car?.Make, car?.Model, car?.Year);\n    }\n}\nProperties and indexers of a class can define extra accessors for a property or indexer that's defined in an interface. For example, an interface might declare a property that has a\nget\naccessor. The class that implements the interface can declare the same property with both a\nget\nand\nset\naccessor. However, if the property or indexer uses explicit implementation, the accessors must match. For more information about explicit implementation, see\nExplicit Interface Implementation\nand\nInterface Properties\n.\nInterfaces can inherit from one or more interfaces. The derived interface inherits the members from its base interfaces. A class that implements a derived interface must implement all members in the derived interface, including all members of the derived interface's base interfaces. That class may be implicitly converted to the derived interface or any of its base interfaces. A class might include an interface multiple times through base classes that it inherits or through interfaces that other interfaces inherit. However, the class can provide an implementation of an interface only one time and only if the class declares the interface as part of the definition of the class (\nclass ClassName : InterfaceName\n). If the interface is inherited because you inherited a base class that implements the interface, the base class provides the implementation of the members of the interface. However, the derived class can reimplement any virtual interface members instead of using the inherited implementation. When interfaces declare a default implementation of a method, any class implementing that interface inherits that implementation (You need to cast the class instance to the interface type to access the default implementation on the Interface member).\nA base class can also implement interface members by using virtual members. In that case, a derived class can change the interface behavior by overriding the virtual members. For more information about virtual members, see\nPolymorphism\n.\nInterfaces summary\nAn interface has the following properties:\nIn C# versions earlier than 8.0, an interface is like an abstract base class with only abstract members. A class or struct that implements the interface must implement all its members.\nBeginning with C# 8.0, an interface may define default implementations for some or all of its members. A class or struct that implements the interface doesn't have to implement members that have default implementations. For more information, see\ndefault interface methods\n.\nAn interface can't be instantiated directly. Its members are implemented by any class or struct that implements the interface.\nA class or struct can implement multiple interfaces. A class can inherit a base class and also implement one or more interfaces.\nCollaborate with us on GitHub\nThe source for this content can be found on GitHub, where you can also create and review issues and pull requests. For more information, see\nour contributor guide\n.\n.NET\nOpen a documentation issue\nProvide product feedback\nAdditional resources",
  "code_samples": [
    {
      "language": "csharp",
      "code": "interface IEquatable<T>\n{\n    bool Equals(T obj);\n}",
      "lines": 4
    },
    {
      "language": "csharp",
      "code": "interface IEquatable<T>\n{\n    bool Equals(T obj);\n}",
      "lines": 4
    },
    {
      "language": "csharp",
      "code": "public class Car : IEquatable<Car>\n{\n    public string? Make { get; set; }\n    public string? Model { get; set; }\n    public string? Year { get; set; }\n\n    // Implementation of IEquatable<T> interface\n    public bool Equals(Car? car)\n    {\n        return (this.Make, this.Model, this.Year) ==\n            (car?.Make, car?.Model, car?.Year);\n    }\n}",
      "lines": 13
    },
    {
      "language": "csharp",
      "code": "public class Car : IEquatable<Car>\n{\n    public string? Make { get; set; }\n    public string? Model { get; set; }\n    public string? Year { get; set; }\n\n    // Implementation of IEquatable<T> interface\n    public bool Equals(Car? car)\n    {\n        return (this.Make, this.Model, this.Year) ==\n            (car?.Make, car?.Model, car?.Year);\n    }\n}",
      "lines": 13
    }
  ],
  "collected_at": "2025-06-25T19:28:55.553979"
}