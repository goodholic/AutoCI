{
  "source": "github_patterns",
  "url": "https://github.com/rebus-org/Rebus",
  "type": "project_documentation",
  "content": "# Rebus\n\n![](https://raw.githubusercontent.com/rebus-org/Rebus/master/artwork/little_rebusbus2_copy-200x200.png)\n\nLatest stable: [![NuGet stable](https://img.shields.io/nuget/v/Rebus.svg?style=flat-square)](https://www.nuget.org/packages/Rebus)\n\nCurrent prerelease: [![NuGet pre](https://img.shields.io/nuget/vpre/Rebus.svg?style=flat-square)](https://www.nuget.org/packages/Rebus)\n\nTests: [![Build status](https://ci.appveyor.com/api/projects/status/gk13466i0o57o4rp?svg=true)](https://ci.appveyor.com/project/mookid8000/rebus)\n\nThis repository contains Rebus \"core\". You may also be interested in one of [the many integration libraries](https://github.com/rebus-org?utf8=%E2%9C%93&q=rebus.). \n\nFor information about the commercial add-on (support, tooling, etc.) to Rebus, please visit [Rebus FM's page about Rebus Pro](https://rebus.fm/rebus-pro/).\n\n\nWhat?\n====\n\nRebus is a lean service bus implementation for .NET. It is what ThoughtWorks in 2010 called a \n[\"message bus without smarts\"](https://www.thoughtworks.com/radar/tools/message-buses-without-smarts) - a library \nthat works well as the \"dumb pipes\" when you need asynchronous communication in your microservices that follow\nthe [\"smart endpoints, dumb pipes\"](https://martinfowler.com/articles/microservices.html#SmartEndpointsAndDumbPipes) \nprinciple.\n\nRebus aims to have\n\n* a simple and intuitive configuration story\n* a few well-selected options\n* no doodleware\n* as few dependencies as possible (currently only [JSON.NET][JSON])\n* a broad reach (targets .NET Standard 2.0, i.e. .NET Framework 4.6.1, .NET Core 2, and .NET 5 and onwards)\n* integration with external dependencies via small, dedicated projects\n* the best error messages in the world\n* a frictionless getting-up-and-running-experience\n\nand in doing this, Rebus should try to align itself with common, proven asynchronous messaging patterns.\n\nOh, and Rebus is FREE as in beer üç∫ and speech üí¨, and it will stay that way forever.\n\nMore information\n====\n\nIf you want to read more, check out [the official Rebus documentation wiki][REBUS_WIKI] or check out [my blog][REBUS_PAGE_ON_BLOG].\n\nYou can also follow me on Twitter: [@mookid8000][MOOKID8000_ON_TWITTER]\n\nGetting started\n====\n\nRebus is a simple .NET library, and everything revolves around the `RebusBus` class. One way to get Rebus\nup and running, is to manually go\n\n```csharp\nvar bus = new RebusBus(...);\nbus.Start(1); //< 1 worker thread\n\n// use the bus for the duration of the application lifetime\n\n// remember to dispose the bus when your application exits\nbus.Dispose();\n```\n\nwhere `...` is a bunch of dependencies that vary depending on how you want to send/receive messages etc.\nAnother way is to use the configuration API, in which case you would go\n\n\n```csharp\nvar someContainerAdapter = new BuiltinHandlerActivator();\n```\n\nfor the built-in container adapter, or\n\n```csharp\nvar someContainerAdapter = new AdapterForMyFavoriteIocContainer(myFavoriteIocContainer);\n```\n\nto integrate with your favorite IoC container, and then\n\n```csharp\nConfigure.With(someContainerAdapter)\n    .Logging(l => l.Serilog())\n    .Transport(t => t.UseMsmq(\"myInputQueue\"))\n    .Routing(r => r.TypeBased().MapAssemblyOf<SomeMessageType>(\"anotherInputQueue\"))\n    .Start();\n\n// have IBus injected in application services for the duration of the application lifetime    \n\n// let the container dispose the bus when your application exits\nmyFavoriteIocContainer.Dispose();\n```\n\nwhich will stuff the resulting `IBus` in the container as a singleton and use the container to look up\nmessage handlers. Check out the Configuration section on [the official Rebus documentation wiki][REBUS_WIKI] for\nmore information on how to do this.\n\nIf you want to be more specific about what types you map in an assembly, such as if the assembly is shared with other code you can map all the types under a specific namespace like this:\n\n```csharp\nConfigure.With(someContainerAdapter)\n    .(...)\n    .Routing(r => r.TypeBased().MapAssemblyNamespaceOf<SomeMessageType>(\"namespaceInputQueue\"))\n    .(...);\n\n// have IBus injected in application services for the duration of the application lifetime    \n\n// let the container dispose the bus when your application exits\nmyFavoriteIocContainer.Dispose();\n```\n\n\nLicense\n====\n\nRebus is licensed under [The MIT License (MIT)][MITLICENSE]. Basically, this license grants you the right to use\nRebus in any way you see fit. See [LICENSE.md](/LICENSE.md) for more info.\n\nThe purpose of the license is to make it easy for everyone to use Rebus and its accompanying integration\nlibraries. If that is not the case, please get in touch with [hello@rebus.fm](mailto:hello@rebus.fm)\nand then we will work something out.\n\n\n[MITLICENSE]: https://raw.githubusercontent.com/rebus-org/Rebus/batches/LICENSE.md\n[MOOKID8000_ON_TWITTER]: https://twitter.com/mookid8000\n[REBUS_WIKI]: https://github.com/rebus-org/Rebus/wiki\n[REBUS_PAGE_ON_BLOG]: http://mookid.dk/oncode/rebus\n\n[JSON]: https://github.com/JamesNK/Newtonsoft.Json\n\n[//]: [![downloads](http://img.shields.io/nuget/dt/Rebus.svg?style=flat-square)](https://www.nuget.org/packages/Rebus)\n",
  "stars": 2494,
  "timestamp": "2025-06-27T00:14:22.073238",
  "category": "advanced_patterns"
}