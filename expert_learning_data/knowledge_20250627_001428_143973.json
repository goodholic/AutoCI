{
  "source": "github_patterns",
  "url": "https://github.com/neuecc/UniRx",
  "type": "project_documentation",
  "content": "> [!IMPORTANT]\n> I have started distributing an evolved version of UniRx in [Cysharp/R3](https://github.com/Cysharp/R3), please use it instead of UniRx.\n\nUniRx - Reactive Extensions for Unity\n===\nCreated by Yoshifumi Kawai(neuecc)\n\nWhat is UniRx?\n---\nUniRx (Reactive Extensions for Unity) is a reimplementation of the .NET Reactive Extensions. The Official Rx implementation is great but doesn't work on Unity and has issues with iOS IL2CPP compatibility. This library fixes those issues and adds some specific utilities for Unity. Supported platforms are PC/Mac/Android/iOS/WebGL/WindowsStore/etc and the library.\n\nUniRx is available on the Unity Asset Store (FREE) - http://u3d.as/content/neuecc/uni-rx-reactive-extensions-for-unity/7tT\n\nBlog for update info - https://medium.com/@neuecc\n\nSupport thread on the Unity Forums: Ask me any question - http://forum.unity3d.com/threads/248535-UniRx-Reactive-Extensions-for-Unity\n\nRelease Notes, see [UniRx/releases](https://github.com/neuecc/UniRx/releases)\n\nUniRx is Core Library (Port of Rx) + Platform Adaptor (MainThreadScheduler/FromCoroutine/etc) + Framework (ObservableTriggers/ReactiveProeperty/etc).\n\n> Note: async/await integration(UniRx.Async) is separated to [Cysharp/UniTask](https://github.com/Cysharp/UniTask) after ver. 7.0.\n\nWhy Rx?\n---\nOrdinarily, Network operations in Unity require the use of `WWW` and `Coroutine`. That said, using `Coroutine` is not good practice for asynchronous operations for the following (and other) reasons:\n\n1. Coroutines can't return any values, since its return type must be IEnumerator.\n2. Coroutines can't handle exceptions, because yield return statements cannot be surrounded with a try-catch construction.\n\nThis kind of lack of composability causes operations to be close-coupled, which often results in huge monolithic IEnumerators.\n\nRx cures that kind of \"asynchronous blues\". Rx is a library for composing asynchronous and event-based programs using observable collections and LINQ-style query operators. \n  \nThe game loop (every Update, OnCollisionEnter, etc), sensor data (Kinect, Leap Motion, VR Input, etc.) are all types of events. Rx represents events as reactive sequences which are both easily composable and support time-based operations by using LINQ query operators.\n\nUnity is generally single threaded but UniRx facilitates multithreading for joins, cancels, accessing GameObjects, etc.\n\nUniRx helps UI programming with uGUI. All UI events (clicked, valuechanged, etc) can be converted to UniRx event streams. \n\nUnity supports async/await from 2017 with C# upgrades, UniRx family prjects provides more lightweight, more powerful async/await integration with Unity. Please see  [Cysharp/UniTask](https://github.com/Cysharp/UniTask).\n\nIntroduction\n---\nGreat introduction to Rx article: [The introduction to Reactive Programming you've been missing](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754).\n\nThe following code implements the double click detection example from the article in UniRx:\n\n```csharp\nvar clickStream = Observable.EveryUpdate()\n    .Where(_ => Input.GetMouseButtonDown(0));\n\nclickStream.Buffer(clickStream.Throttle(TimeSpan.FromMilliseconds(250)))\n    .Where(xs => xs.Count >= 2)\n    .Subscribe(xs => Debug.Log(\"DoubleClick Detected! Count:\" + xs.Count));\n```\n\nThis example demonstrates the following features (in only five lines!):\n\n* The game loop (Update) as an event stream\n* Composable event streams\n* Merging self stream\n* Easy handling of time based operations   \n\nNetwork operations\n---\nUse ObservableWWW for asynchronous network operations. Its Get/Post functions return subscribable IObservables:\n\n```csharp\nObservableWWW.Get(\"http://google.co.jp/\")\n    .Subscribe(\n        x => Debug.Log(x.Substring(0, 100)), // onSuccess\n        ex => Debug.LogException(ex)); // onError\n```\n\nRx is composable and cancelable. You can also query with LINQ expressions:\n\n```csharp\n// composing asynchronous sequence with LINQ query expressions\nvar query = from google in ObservableWWW.Get(\"http://google.com/\")\n            from bing in ObservableWWW.Get(\"http://bing.com/\")\n            from unknown in ObservableWWW.Get(google + bing)\n            select new { google, bing, unknown };\n\nvar cancel = query.Subscribe(x => Debug.Log(x));\n\n// Call Dispose is cancel.\ncancel.Dispose();\n```\n\nUse Observable.WhenAll for parallel requests:\n\n```csharp\n// Observable.WhenAll is for parallel asynchronous operation\n// (It's like Observable.Zip but specialized for single async operations like Task.WhenAll)\nvar parallel = Observable.WhenAll(\n    ObservableWWW.Get(\"http://google.com/\"),\n    ObservableWWW.Get(\"http://bing.com/\"),\n    ObservableWWW.Get(\"http://unity3d.com/\"));\n\nparallel.Subscribe(xs =>\n{\n    Debug.Log(xs[0].Substring(0, 100)); // google\n    Debug.Log(xs[1].Substring(0, 100)); // bing\n    Debug.Log(xs[2].Substring(0, 100)); // unity\n});\n```\n\nProgress information is available:\n\n```csharp\n// notifier for progress use ScheduledNotifier or new Progress<float>(/* action */)\nvar progressNotifier = new ScheduledNotifier<float>();\nprogressNotifier.Subscribe(x => Debug.Log(x)); // write www.progress\n\n// pass notifier to WWW.Get/Post\nObservableWWW.Get(\"http://google.com/\", progress: progressNotifier).Subscribe();\n```\n\nError handling:\n\n```csharp\n// If WWW has .error, ObservableWWW throws WWWErrorException to onError pipeline.\n// WWWErrorException has RawErrorMessage, HasResponse, StatusCode, ResponseHeaders\nObservableWWW.Get(\"http://www.google.com/404\")\n    .CatchIgnore((WWWErrorException ex) =>\n    {\n        Debug.Log(ex.RawErrorMessage);\n        if (ex.HasResponse)\n        {\n            Debug.Log(ex.StatusCode);\n        }\n        foreach (var item in ex.ResponseHeaders)\n        {\n            Debug.Log(item.Key + \":\" + item.Value);\n        }\n    })\n    .Subscribe();\n```\n\nUsing with IEnumerators (Coroutines)\n---\nIEnumerator (Coroutine) is Unity's primitive asynchronous tool. UniRx integrates coroutines and IObservables. You can write asynchronious code in coroutines, and orchestrate them using UniRx. This is best way to control asynchronous flow.\n\n```csharp\n// two coroutines\n\nIEnumerator AsyncA()\n{\n    Debug.Log(\"a start\");\n    yield return new WaitForSeconds(1);\n    Debug.Log(\"a end\");\n}\n\nIEnumerator AsyncB()\n{\n    Debug.Log(\"b start\");\n    yield return new WaitForEndOfFrame();\n    Debug.Log(\"b end\");\n}\n\n// main code\n// Observable.FromCoroutine converts IEnumerator to Observable<Unit>.\n// You can also use the shorthand, AsyncA().ToObservable()\n        \n// after AsyncA completes, run AsyncB as a continuous routine.\n// UniRx expands SelectMany(IEnumerator) as SelectMany(IEnumerator.ToObservable())\nvar cancel = Observable.FromCoroutine(AsyncA)\n    .SelectMany(AsyncB)\n    .Subscribe();\n\n// you can stop a coroutine by calling your subscription's Dispose.\ncancel.Dispose();\n```\n\nIf in Unity 5.3, you can use ToYieldInstruction for Observable to Coroutine.\n\n```csharp\nIEnumerator TestNewCustomYieldInstruction()\n{\n    // wait Rx Observable.\n    yield return Observable.Timer(TimeSpan.FromSeconds(1)).ToYieldInstruction();\n\n    // you can change the scheduler(this is ignore Time.scale)\n    yield return Observable.Timer(TimeSpan.FromSeconds(1), Scheduler.MainThreadIgnoreTimeScale).ToYieldInstruction();\n\n    // get return value from ObservableYieldInstruction\n    var o = ObservableWWW.Get(\"http://unity3d.com/\").ToYieldInstruction(throwOnError: false);\n    yield return o;\n\n    if (o.HasError) { Debug.Log(o.Error.ToString()); }\n    if (o.HasResult) { Debug.Log(o.Result); }\n\n    // other sample(wait until transform.position.y >= 100) \n    yield return this.transform.ObserveEveryValueChanged(x => x.position).FirstOrDefault(p => p.y >= 100).ToYieldInstruction();\n}\n```\nNormally, we have to use callbacks when we require a coroutine to return a value. Observable.FromCoroutine can convert coroutines to cancellable IObservable[T] instead.\n\n```csharp\n// public method\npublic static IObservable<string> GetWWW(string url)\n{\n    // convert coroutine to IObservable\n    return Observable.FromCoroutine<string>((observer, cancellationToken) => GetWWWCore(url, observer, cancellationToken));\n}\n\n// IObserver is a callback publisher\n// Note: IObserver's basic scheme is \"OnNext* (OnError | Oncompleted)?\" \nstatic IEnumerator GetWWWCore(string url, IObserver<string> observer, CancellationToken cancellationToken)\n{\n    var www = new UnityEngine.WWW(url);\n    while (!www.isDone && !cancellationToken.IsCancellationRequested)\n    {\n        yield return null;\n    }\n\n    if (cancellationToken.IsCancellationRequested) yield break;\n\n    if (www.error != null)\n    {\n        observer.OnError(new Exception(www.error));\n    }\n    else\n    {\n        observer.OnNext(www.text);\n        observer.OnCompleted(); // IObserver needs OnCompleted after OnNext!\n    }\n}\n```\n\nHere are some more examples. Next is a multiple OnNext pattern.\n\n```csharp\npublic static IObservable<float> ToObservable(this UnityEngine.AsyncOperation asyncOperation)\n{\n    if (asyncOperation == null) throw new ArgumentNullException(\"asyncOperation\");\n\n    return Observable.FromCoroutine<float>((observer, cancellationToken) => RunAsyncOperation(asyncOperation, observer, cancellationToken));\n}\n\nstatic IEnumerator RunAsyncOperation(UnityEngine.AsyncOperation asyncOperation, IObserver<float> observer, CancellationToken cancellationToken)\n{\n    while (!asyncOperation.isDone && !cancellationToken.IsCancellationRequested)\n    {\n        observer.OnNext(asyncOperation.progress);\n        yield return null;\n    }\n    if (!cancellationToken.IsCancellationRequested)\n    {\n        observer.OnNext(asyncOperation.progress); // push 100%\n        observer.OnCompleted();\n    }\n}\n\n// usecase\nApplication.LoadLevelAsync(\"testscene\")\n    .ToObservable()\n    .Do(x => Debug.Log(x)) // output progress\n    .Last() // last sequence is load completed\n    .Subscribe();\n```\n\nUsing for MultiThreading\n---\n\n```csharp\n// Observable.Start is start factory methods on specified scheduler\n// default is on ThreadPool\nvar heavyMethod = Observable.Start(() =>\n{\n    // heavy method...\n    System.Threading.Thread.Sleep(TimeSpan.FromSeconds(1));\n    return 10;\n});\n\nvar heavyMethod2 = Observable.Start(() =>\n{\n    // heavy method...\n    System.Threading.Thread.Sleep(TimeSpan.FromSeconds(3));\n    return 10;\n});\n\n// Join and await two other thread values\nObservable.WhenAll(heavyMethod, heavyMethod2)\n    .ObserveOnMainThread() // return to main thread\n    .Subscribe(xs =>\n    {\n        // Unity can't touch GameObject from other thread\n        // but use ObserveOnMainThread, you can touch GameObject naturally.\n        (GameObject.Find(\"myGuiText\")).guiText.text = xs[0] + \":\" + xs[1];\n    }); \n```\n\nDefaultScheduler\n---\nUniRx's default time based operations (Interval, Timer, Buffer(timeSpan), etc) use `Scheduler.MainThread` as their scheduler. That means most operators (except for `Observable.Start`) work on a single thread, so ObserverOn isn't needed and thread safety measures can be ignored. This is differet from the standard RxNet implementation but better suited to the Unity environment.  \n\n`Scheduler.MainThread` runs under Time.timeScale's influence. If you want to ignore the time scale, use ` Scheduler.MainThreadIgnoreTimeScale` instead.\n\nMonoBehaviour triggers\n---\nUniRx can handle MonoBehaviour events with `UniRx.Triggers`:\n\n```csharp\nusing UniRx;\nusing UniRx.Triggers; // need UniRx.Triggers namespace\n\npublic class MyComponent : MonoBehaviour\n{\n    void Start()\n    {\n        // Get the plain object\n        var cube = GameObject.CreatePrimitive(PrimitiveType.Cube);\n\n        // Add ObservableXxxTrigger for handle MonoBehaviour's event as Observable\n        cube.AddComponent<ObservableUpdateTrigger>()\n            .UpdateAsObservable()\n            .SampleFrame(30)\n            .Subscribe(x => Debug.Log(\"cube\"), () => Debug.Log(\"destroy\"));\n\n        // destroy after 3 second:)\n        GameObject.Destroy(cube, 3f);\n    }\n}\n```\n\nSupported triggers are listed in [UniRx.wiki#UniRx.Triggers](https://github.com/neuecc/UniRx/wiki#unirxtriggers).\n\nThese can also be handled more easily by directly subscribing to observables returned by extension methods on Component/GameObject. These methods inject ObservableTrigger automaticaly (except for `ObservableEventTrigger` and `ObservableStateMachineTrigger`):\n\n```csharp\nusing UniRx;\nusing UniRx.Triggers; // need UniRx.Triggers namespace for extend gameObejct\n\npublic class DragAndDropOnce : MonoBehaviour\n{\n    void Start()\n    {\n        // All events can subscribe by ***AsObservable\n        this.OnMouseDownAsObservable()\n            .SelectMany(_ => this.UpdateAsObservable())\n            .TakeUntil(this.OnMouseUpAsObservable())\n            .Select(_ => Input.mousePosition)\n            .Subscribe(x => Debug.Log(x));\n    }\n}\n```\n\n> Previous versions of UniRx provided `ObservableMonoBehaviour`. This is a legacy interface that is no longer supported. Please use UniRx.Triggers instead.\n\nCreating custom triggers\n---\nConverting to Observable is the best way to handle Unity events. If the standard triggers supplied by UniRx are not enough, you can create custom triggers. To demonstrate, here's a LongTap trigger for uGUI:\n\n```csharp\npublic class ObservableLongPointerDownTrigger : ObservableTriggerBase, IPointerDownHandler, IPointerUpHandler\n{\n    public float IntervalSecond = 1f;\n\n    Subject<Unit> onLongPointerDown;\n\n    float? raiseTime;\n\n    void Update()\n    {\n        if (raiseTime != null && raiseTime <= Time.realtimeSinceStartup)\n        {\n            if (onLongPointerDown != null) onLongPointerDown.OnNext(Unit.Default);\n            raiseTime = null;\n        }\n    }\n\n    void IPointerDownHandler.OnPointerDown(PointerEventData eventData)\n    {\n        raiseTime = Time.realtimeSinceStartup + IntervalSecond;\n    }\n\n    void IPointerUpHandler.OnPointerUp(PointerEventData eventData)\n    {\n        raiseTime = null;\n    }\n\n    public IObservable<Unit> OnLongPointerDownAsObservable()\n    {\n        return onLongPointerDown ?? (onLongPointerDown = new Subject<Unit>());\n    }\n\n    protected override void RaiseOnCompletedOnDestroy()\n    {\n        if (onLongPointerDown != null)\n        {\n            onLongPointerDown.OnCompleted();\n        }\n    }\n}\n```\n\nIt can be used as easily as the standard triggers:\n\n```csharp\nvar trigger = button.AddComponent<ObservableLongPointerDownTrigger>();\n\ntrigger.OnLongPointerDownAsObservable().Subscribe();\n```\n\nObservable Lifecycle Management\n---\nWhen is OnCompleted called? Subscription lifecycle management is very important to consider when using UniRx. `ObservableTriggers` call OnCompleted when the GameObject they are attached to is destroyed. Other static generator methods (`Observable.Timer`, `Observable.EveryUpdate`, etc...) do not stop automatically, and their subscriptions should be managed manually.\n\nRx provides some helper methods, such as `IDisposable.AddTo` which allows you to dispose of several subscriptions at once:\n\n```csharp\n// CompositeDisposable is similar with List<IDisposable>, manage multiple IDisposable\nCompositeDisposable disposables = new CompositeDisposable(); // field\n\nvoid Start()\n{\n    Observable.EveryUpdate().Subscribe(x => Debug.Log(x)).AddTo(disposables);\n}\n\nvoid OnTriggerEnter(Collider other)\n{\n    // .Clear() => Dispose is called for all inner disposables, and the list is cleared.\n    // .Dispose() => Dispose is called for all inner disposables, and Dispose is called immediately after additional Adds.\n    disposables.Clear();\n}\n```\n\nIf you want to automatically Dispose when a GameObjects is destroyed, use AddTo(GameObject/Component):\n\n```csharp\nvoid Start()\n{\n    Observable.IntervalFrame(30).Subscribe(x => Debug.Log(x)).AddTo(this);\n}\n```\n\nAddTo calls facilitate automatic Dispose. If you needs special OnCompleted handling in the pipeline, however, use `TakeWhile`, `TakeUntil`, `TakeUntilDestroy` and `TakeUntilDisable` instead:\n\n```csharp\nObservable.IntervalFrame(30).TakeUntilDisable(this)\n    .Subscribe(x => Debug.Log(x), () => Debug.Log(\"completed!\"));\n```\n\nIf you handle events, `Repeat` is an important but dangerous method. It may cause an infinite loop, so handle with care:\n\n```csharp\nusing UniRx;\nusing UniRx.Triggers;\n\npublic class DangerousDragAndDrop : MonoBehaviour\n{\n    void Start()\n    {\n        this.gameObject.OnMouseDownAsObservable()\n            .SelectMany(_ => this.gameObject.UpdateAsObservable())\n            .TakeUntil(this.gameObject.OnMouseUpAsObservable())\n            .Select(_ => Input.mousePosition)\n            .Repeat() // dangerous!!! Repeat cause infinite repeat subscribe at GameObject was destroyed.(If in UnityEditor, Editor is freezed)\n            .Subscribe(x => Debug.Log(x));\n    }\n}\n```\n\nUniRx provides an additional safe Repeat method. `RepeatSafe`: if contiguous \"OnComplete\" are called repeat stops. `RepeatUntilDestroy(gameObject/component)`, `RepeatUntilDisable(gameObject/component)` allows to stop when a target GameObject has been destroyed:\n\n```csharp\nthis.gameObject.OnMouseDownAsObservable()\n    .SelectMany(_ => this.gameObject.UpdateAsObservable())\n    .TakeUntil(this.gameObject.OnMouseUpAsObservable())\n    .Select(_ => Input.mousePosition)\n    .RepeatUntilDestroy(this) // safety way\n    .Subscribe(x => Debug.Log(x));            \n```\n\nUniRx gurantees hot observable(FromEvent/Subject/ReactiveProperty/UnityUI.AsObservable..., there are like event) have unhandled exception durability. What is it? If subscribe in subcribe, does not detach event.\n\n```csharp\nbutton.OnClickAsObservable().Subscribe(_ =>\n{\n    // If throws error in inner subscribe, but doesn't detached OnClick event.\n    ObservableWWW.Get(\"htttp://error/\").Subscribe(x =>\n    {\n        Debug.Log(x);\n    });\n});\n```\n\nThis behaviour is sometimes useful such as user event handling.\n\n\nAll class instances provide an `ObserveEveryValueChanged` method, which watches for changing values every frame:\n\n```csharp\n// watch position change\nthis.transform.ObserveEveryValueChanged(x => x.position).Subscribe(x => Debug.Log(x));\n```\n\nIt's very useful. If the watch target is a GameObject, it will stop observing when the target is destroyed, and call OnCompleted. If the watch target is a plain C# Object, OnCompleted will be called on GC.\n\nConverting Unity callbacks to IObservables\n---\nUse Subject (or AsyncSubject for asynchronious operations):\n\n```csharp\npublic class LogCallback\n{\n    public string Condition;\n    public string StackTrace;\n    public UnityEngine.LogType LogType;\n}\n\npublic static class LogHelper\n{\n    static Subject<LogCallback> subject;\n\n    public static IObservable<LogCallback> LogCallbackAsObservable()\n    {\n        if (subject == null)\n        {\n            subject = new Subject<LogCallback>();\n\n            // Publish to Subject in callback\n            UnityEngine.Application.RegisterLogCallback((condition, stackTrace, type) =>\n            {\n                subject.OnNext(new LogCallback { Condition = condition, StackTrace = stackTrace, LogType = type });\n            });\n        }\n\n        return subject.AsObservable();\n    }\n}\n\n// method is separatable and composable\nLogHelper.LogCallbackAsObservable()\n    .Where(x => x.LogType == LogType.Warning)\n    .Subscribe();\n\nLogHelper.LogCallbackAsObservable()\n    .Where(x => x.LogType == LogType.Error)\n    .Subscribe();\n```\n\nIn Unity5, `Application.RegisterLogCallback` was removed in favor of `Application.logMessageReceived`, so we can now simply use `Observable.FromEvent`.\n\n```csharp\npublic static IObservable<LogCallback> LogCallbackAsObservable()\n{\n    return Observable.FromEvent<Application.LogCallback, LogCallback>(\n        h => (condition, stackTrace, type) => h(new LogCallback { Condition = condition, StackTrace = stackTrace, LogType = type }),\n        h => Application.logMessageReceived += h, h => Application.logMessageReceived -= h);\n}\n```\n\nStream Logger\n---\n```csharp\n// using UniRx.Diagnostics;\n\n// logger is threadsafe, define per class with name.\nstatic readonly Logger logger = new Logger(\"Sample11\");\n\n// call once at applicationinit\npublic static void ApplicationInitialize()\n{\n    // Log as Stream, UniRx.Diagnostics.ObservableLogger.Listener is IObservable<LogEntry>\n    // You can subscribe and output to any place.\n    ObservableLogger.Listener.LogToUnityDebug();\n\n    // for example, filter only Exception and upload to web.\n    // (make custom sink(IObserver<EventEntry>) is better to use)\n    ObservableLogger.Listener\n        .Where(x => x.LogType == LogType.Exception)\n        .Subscribe(x =>\n        {\n            // ObservableWWW.Post(\"\", null).Subscribe();\n        });\n}\n\n// Debug is write only DebugBuild.\nlogger.Debug(\"Debug Message\");\n\n// or other logging methods\nlogger.Log(\"Message\");\nlogger.Exception(new Exception(\"test exception\"));\n```\n\nDebugging\n---\n`Debug` operator in `UniRx.Diagnostics` namespace helps debugging.\n\n```csharp\n// needs Diagnostics using\nusing UniRx.Diagnostics;\n\n---\n\n// [DebugDump, Normal]OnSubscribe\n// [DebugDump, Normal]OnNext(1)\n// [DebugDump, Normal]OnNext(10)\n// [DebugDump, Normal]OnCompleted()\n{\n    var subject = new Subject<int>();\n\n    subject.Debug(\"DebugDump, Normal\").Subscribe();\n\n    subject.OnNext(1);\n    subject.OnNext(10);\n    subject.OnCompleted();\n}\n\n// [DebugDump, Cancel]OnSubscribe\n// [DebugDump, Cancel]OnNext(1)\n// [DebugDump, Cancel]OnCancel\n{\n    var subject = new Subject<int>();\n\n    var d = subject.Debug(\"DebugDump, Cancel\").Subscribe();\n\n    subject.OnNext(1);\n    d.Dispose();\n}\n\n// [DebugDump, Error]OnSubscribe\n// [DebugDump, Error]OnNext(1)\n// [DebugDump, Error]OnError(System.Exception)\n{\n    var subject = new Subject<int>();\n\n    subject.Debug(\"DebugDump, Error\").Subscribe();\n\n    subject.OnNext(1);\n    subject.OnError(new Exception());\n}\n```\n\nshows sequence element on `OnNext`, `OnError`, `OnCompleted`, `OnCancel`, `OnSubscribe` timing to Debug.Log. It enables only `#if DEBUG`.\n\nUnity-specific Extra Gems\n---\n```csharp\n// Unity's singleton UiThread Queue Scheduler\nScheduler.MainThreadScheduler \nObserveOnMainThread()/SubscribeOnMainThread()\n\n// Global StartCoroutine runner\nMainThreadDispatcher.StartCoroutine(enumerator)\n\n// convert Coroutine to IObservable\nObservable.FromCoroutine((observer, token) => enumerator(observer, token)); \n\n// convert IObservable to Coroutine\nyield return Observable.Range(1, 10).ToYieldInstruction(); // after Unity 5.3, before can use StartAsCoroutine()\n\n// Lifetime hooks\nObservable.EveryApplicationPause();\nObservable.EveryApplicationFocus();\nObservable.OnceApplicationQuit();\n```\n\nFramecount-based time operators\n---\nUniRx provides a few framecount-based time operators:\n\nMethod | \n-------|\nEveryUpdate|\nEveryFixedUpdate|\nEveryEndOfFrame|\nEveryGameObjectUpdate|\nEveryLateUpdate|\nObserveOnMainThread|\nNextFrame|\nIntervalFrame|\nTimerFrame|\nDelayFrame|\nSampleFrame|\nThrottleFrame|\nThrottleFirstFrame|\nTimeoutFrame|\nDelayFrameSubscription|\nFrameInterval|\nFrameTimeInterval|\nBatchFrame|\n\nFor example, delayed invoke once:\n\n```csharp\nObservable.TimerFrame(100).Subscribe(_ => Debug.Log(\"after 100 frame\"));\n```\n\nEvery* Method's execution order is\n\n```\nEveryGameObjectUpdate(in MainThreadDispatcher's Execution Order) ->\nEveryUpdate -> \nEveryLateUpdate -> \nEveryEndOfFrame\n```\n\nEveryGameObjectUpdate invoke from same frame if caller is called before MainThreadDispatcher.Update(I recommend MainThreadDispatcher called first than others(ScriptExecutionOrder makes -32000)      \nEveryLateUpdate, EveryEndOfFrame invoke from same frame.  \nEveryUpdate, invoke from next frame.  \n\nMicroCoroutine\n---\nMicroCoroutine is memory efficient and fast coroutine worker. This implemantation is based on [Unity blog's 10000 UPDATE() CALLS](http://blogs.unity3d.com/2015/12/23/1k-update-calls/), avoid managed-unmanaged overhead so gets 10x faster iteration. MicroCoroutine is automaticaly used on Framecount-based time operators and ObserveEveryValueChanged.\n\nIf you want to use MicroCoroutine instead of standard unity coroutine, use `MainThreadDispatcher.StartUpdateMicroCoroutine` or `Observable.FromMicroCoroutine`.\n\n```csharp\nint counter;\n\nIEnumerator Worker()\n{\n    while(true)\n    {\n        counter++;\n        yield return null;\n    }\n}\n\nvoid Start()\n{\n    for(var i = 0; i < 10000; i++)\n    {\n        // fast, memory efficient\n        MainThreadDispatcher.StartUpdateMicroCoroutine(Worker());\n\n        // slow...\n        // StartCoroutine(Worker());\n    }\n}\n```\n\n![image](https://cloud.githubusercontent.com/assets/46207/15267997/86e9ed5c-1a0c-11e6-8371-14b61a09c72c.png)\n\nMicroCoroutine's limitation, only supports `yield return null` and update timing is determined start method(`StartUpdateMicroCoroutine`, `StartFixedUpdateMicroCoroutine`, `StartEndOfFrameMicroCoroutine`). \n\nIf you combine with other IObservable, you can check completed property like isDone.\n\n```csharp\nIEnumerator MicroCoroutineWithToYieldInstruction()\n{\n    var www = ObservableWWW.Get(\"http://aaa\").ToYieldInstruction();\n    while (!www.IsDone)\n    {\n        yield return null;\n    }\n\n    if (www.HasResult)\n    {\n        UnityEngine.Debug.Log(www.Result);\n    }\n}\n```\n\nuGUI Integration\n---\nUniRx can handle `UnityEvent`s easily. Use `UnityEvent.AsObservable` to subscribe to events:\n\n```csharp\npublic Button MyButton;\n// ---\nMyButton.onClick.AsObservable().Subscribe(_ => Debug.Log(\"clicked\"));\n```\n\nTreating Events as Observables enables declarative UI programming. \n\n```csharp\npublic Toggle MyToggle;\npublic InputField MyInput;\npublic Text MyText;\npublic Slider MySlider;\n\n// On Start, you can write reactive rules for declaretive/reactive ui programming\nvoid Start()\n{\n    // Toggle, Input etc as Observable (OnValueChangedAsObservable is a helper providing isOn value on subscribe)\n    // SubscribeToInteractable is an Extension Method, same as .interactable = x)\n    MyToggle.OnValueChangedAsObservable().SubscribeToInteractable(MyButton);\n    \n    // Input is displayed after a 1 second delay\n    MyInput.OnValueChangedAsObservable()\n        .Where(x => x != null)\n        .Delay(TimeSpan.FromSeconds(1))\n        .SubscribeToText(MyText); // SubscribeToText is helper for subscribe to text\n    \n    // Converting for human readability\n    MySlider.OnValueChangedAsObservable()\n        .SubscribeToText(MyText, x => Math.Round(x, 2).ToString());\n}\n```\n\nFor more on reactive UI programming please consult Sample12, Sample13 and the ReactiveProperty section below. \n\nReactiveProperty, ReactiveCollection\n---\nGame data often requires notification. Should we use properties and events (callbacks)? That's often too complex. UniRx provides ReactiveProperty, a lightweight property broker.\n\n```csharp\n// Reactive Notification Model\npublic class Enemy\n{\n    public ReactiveProperty<long> CurrentHp { get; private set; }\n\n    public ReactiveProperty<bool> IsDead { get; private set; }\n\n    public Enemy(int initialHp)\n    {\n        // Declarative Property\n        CurrentHp = new ReactiveProperty<long>(initialHp);\n        IsDead = CurrentHp.Select(x => x <= 0).ToReactiveProperty();\n    }\n}\n\n// ---\n// onclick, HP decrement\nMyButton.OnClickAsObservable().Subscribe(_ => enemy.CurrentHp.Value -= 99);\n// subscribe from notification model.\nenemy.CurrentHp.SubscribeToText(MyText);\nenemy.IsDead.Where(isDead => isDead == true)\n    .Subscribe(_ =>\n    {\n        MyButton.interactable = false;\n    });\n```\n\nYou can combine ReactiveProperties, ReactiveCollections and observables returned by UnityEvent.AsObservable. All UI elements are observable.\n\nGeneric ReactiveProperties are not serializable or inspecatble in the Unity editor, but UniRx provides specialized subclasses of ReactiveProperty that are. These include classes such as Int/LongReactiveProperty, Float/DoubleReactiveProperty, StringReactiveProperty, BoolReactiveProperty and more (Browse them here: [InspectableReactiveProperty.cs](https://github.com/neuecc/UniRx/blob/master/Assets/Plugins/UniRx/Scripts/UnityEngineBridge/InspectableReactiveProperty.cs)). All are fully editable in the inspector. For custom Enum ReactiveProperty, it's easy to write a custom inspectable ReactiveProperty[T].\n\nIf you needs `[Multiline]` or `[Range]` attach to ReactiveProperty, you can use `MultilineReactivePropertyAttribute` and `RangeReactivePropertyAttribute` instead of `Multiline` and `Range`.\n\nThe provided derived InpsectableReactiveProperties are displayed in the inspector naturally and notify when their value is changed even when it is changed in the inspector.\n\n![](StoreDocument/RxPropInspector.png)\n\nThis functionality is provided by [InspectorDisplayDrawer](https://github.com/neuecc/UniRx/blob/master/Assets/Plugins/UniRx/Scripts/UnityEngineBridge/InspectorDisplayDrawer.cs). You can supply your own custom specialized ReactiveProperties by inheriting from it:\n\n```csharp\npublic enum Fruit\n{\n    Apple, Grape\n}\n\n[Serializable]\npublic class FruitReactiveProperty : ReactiveProperty<Fruit>\n{\n    public FruitReactiveProperty()\n    {\n    }\n\n    public FruitReactiveProperty(Fruit initialValue)\n        :base(initialValue)\n    {\n    }\n}\n\n[UnityEditor.CustomPropertyDrawer(typeof(FruitReactiveProperty))]\n[UnityEditor.CustomPropertyDrawer(typeof(YourSpecializedReactiveProperty2))] // and others...\npublic class ExtendInspectorDisplayDrawer : InspectorDisplayDrawer\n{\n}\n```\n\nIf a ReactiveProperty value is only updated within a stream, you can make it read only by using from `ReadOnlyReactiveProperty`.\n\n```csharp\npublic class Person\n{\n    public ReactiveProperty<string> GivenName { get; private set; }\n    public ReactiveProperty<string> FamilyName { get; private set; }\n    public ReadOnlyReactiveProperty<string> FullName { get; private set; }\n\n    public Person(string givenName, string familyName)\n    {\n        GivenName = new ReactiveProperty<string>(givenName);\n        FamilyName = new ReactiveProperty<string>(familyName);\n        // If change the givenName or familyName, notify with fullName!\n        FullName = GivenName.CombineLatest(FamilyName, (x, y) => x + \" \" + y).ToReadOnlyReactiveProperty();\n    }\n}\n```\n\nModel-View-(Reactive)Presenter Pattern\n---\nUniRx makes it possible to implement the MVP(MVRP) Pattern.\n\n![](StoreDocument/MVP_Pattern.png)\n\nWhy should we use MVP instead of MVVM? Unity doesn't provide a UI binding mechanism and creating a binding layer is too complex and loss and affects performance. Still, Views need updating. Presenters are aware of their view's components and can update them. Although there is no real binding, Observables enables subscription to notification, which can act much like the real thing. This pattern is called a Reactive Presenter: \n\n```csharp\n// Presenter for scene(canvas) root.\npublic class ReactivePresenter : MonoBehaviour\n{\n    // Presenter is aware of its View (binded in the inspector)\n    public Button MyButton;\n    public Toggle MyToggle;\n    \n    // State-Change-Events from Model by ReactiveProperty\n    Enemy enemy = new Enemy(1000);\n\n    void Start()\n    {\n        // Rx supplies user events from Views and Models in a reactive manner \n        MyButton.OnClickAsObservable().Subscribe(_ => enemy.CurrentHp.Value -= 99);\n        MyToggle.OnValueChangedAsObservable().SubscribeToInteractable(MyButton);\n\n        // Models notify Presenters via Rx, and Presenters update their views\n        enemy.CurrentHp.SubscribeToText(MyText);\n        enemy.IsDead.Where(isDead => isDead == true)\n            .Subscribe(_ =>\n            {\n                MyToggle.interactable = MyButton.interactable = false;\n            });\n    }\n}\n\n// The Model. All property notify when their values change\npublic class Enemy\n{\n    public ReactiveProperty<long> CurrentHp { get; private set; }\n\n    public ReactiveProperty<bool> IsDead { get; private set; }\n\n    public Enemy(int initialHp)\n    {\n        // Declarative Property\n        CurrentHp = new ReactiveProperty<long>(initialHp);\n        IsDead = CurrentHp.Select(x => x <= 0).ToReactiveProperty();\n    }\n}\n```\n\nA View is a scene, that is a Unity hierarchy. Views are associated with Presenters by the Unity Engine on initialize. The XxxAsObservable methods make creating event signals simple, without any overhead. SubscribeToText and SubscribeToInteractable are simple binding-like helpers. These may be simple tools, but they are very powerful. They feel natural in the Unity environment and provide high performance and a clean architecture.\n\n![](StoreDocument/MVRP_Loop.png)\n\nV -> RP -> M -> RP -> V completely connected in a reactive way. UniRx provides all of the adaptor methods and classes, but other MVVM(or MV*) frameworks can be used instead. UniRx/ReactiveProperty is only simple toolkit. \n\nGUI programming also benefits from ObservableTriggers. ObservableTriggers convert Unity events to Observables, so the MV(R)P pattern can be composed using them. For example, `ObservableEventTrigger` converts uGUI events to Observable:\n\n```csharp\nvar eventTrigger = this.gameObject.AddComponent<ObservableEventTrigger>();\neventTrigger.OnBeginDragAsObservable()\n    .SelectMany(_ => eventTrigger.OnDragAsObservable(), (start, current) => UniRx.Tuple.Create(start, current))\n    .TakeUntil(eventTrigger.OnEndDragAsObservable())\n    .RepeatUntilDestroy(this)\n    .Subscribe(x => Debug.Log(x));\n```\n\n(Obsolete)PresenterBase\n---\n> Note:\n> PresenterBase works enough, but too complex.  \n> You can use simple `Initialize` method and call parent to child, it works for most scenario.  \n> So I don't recommend using `PresenterBase`, sorry.   \n\nReactiveCommand, AsyncReactiveCommand\n----\nReactiveCommand abstraction of button command with boolean interactable.\n             \n```csharp\npublic class Player\n{\t\t\n   public ReactiveProperty<int> Hp;\t\t\n   public ReactiveCommand Resurrect;\t\t\n\t\t\n   public Player()\n   {\t\t\n        Hp = new ReactiveProperty<int>(1000);\t\t\n        \t\t\n        // If dead, can not execute.\t\t\n        Resurrect = Hp.Select(x => x <= 0).ToReactiveCommand();\t\t\n        // Execute when clicked\t\t\n        Resurrect.Subscribe(_ =>\t\t\n        {\t\t\n             Hp.Value = 1000;\t\t\n        }); \t\t\n    }\t\t\n}\t\t\n\t\t\npublic class Presenter : MonoBehaviour\t\t\n{\t\t\n    public Button resurrectButton;\t\t\n\t\t\n    Player player;\t\t\n\t\t\n    void Start()\n    {\t\t\n      player = new Player();\t\t\n\t\t\n      // If Hp <= 0, can't press button.\t\t\n      player.Resurrect.BindTo(resurrectButton);\t\t\n    }\t\t\n}\t\t\n```\t\t\n\t\t\nAsyncReactiveCommand is a variation of ReactiveCommand that `CanExecute`(in many cases bind to button's interactable) is changed to false until asynchronous execution was finished.\t\t\n\t\t\n```csharp\t\t\npublic class Presenter : MonoBehaviour\t\t\n{\t\t\n    public UnityEngine.UI.Button button;\t\t\n\t\t\n    void Start()\n    {\t\t\n        var command = new AsyncReactiveCommand();\t\t\n\t\t\n        command.Subscribe(_ =>\t\t\n        {\t\t\n            // heavy, heavy, heavy method....\t\t\n            return Observable.Timer(TimeSpan.FromSeconds(3)).AsUnitObservable();\t\t\n        });\t\t\n\t\t\n        // after clicked, button shows disable for 3 seconds\t\t\n        command.BindTo(button);\t\t\n\t\t\n        // Note:shortcut extension, bind aync onclick directly\t\t\n        button.BindToOnClick(_ =>\t\t\n        {\t\t\n            return Observable.Timer(TimeSpan.FromSeconds(3)).AsUnitObservable();\t\t\n        });\t\t\n    }\t\t\n}\t\t\n```\n\n`AsyncReactiveCommand` has three constructor.\n\n* `()` - CanExecute is changed to false until async execution finished\n* `(IObservable<bool> canExecuteSource)` - Mixed with empty, CanExecute becomes true when canExecuteSource send to true and does not executing \n* `(IReactiveProperty<bool> sharedCanExecute)` - share execution status between multiple AsyncReactiveCommands, if one AsyncReactiveCommand is executing, other AsyncReactiveCommands(with same sharedCanExecute property) becomes CanExecute false until async execution finished\n\n```csharp\npublic class Presenter : MonoBehaviour\n{\n    public UnityEngine.UI.Button button1;\n    public UnityEngine.UI.Button button2;\n\n    void Start()\n    {\n        // share canExecute status.\n        // when clicked button1, button1 and button2 was disabled for 3 seconds.\n\n        var sharedCanExecute = new ReactiveProperty<bool>();\n\n        button1.BindToOnClick(sharedCanExecute, _ =>\n        {\n            return Observable.Timer(TimeSpan.FromSeconds(3)).AsUnitObservable();\n        });\n\n        button2.BindToOnClick(sharedCanExecute, _ =>\n        {\n            return Observable.Timer(TimeSpan.FromSeconds(3)).AsUnitObservable();\n        });\n    }\n}\n```\n\nMessageBroker, AsyncMessageBroker\n---\nMessageBroker is Rx based in-memory pubsub system filtered by type.\n\n```csharp\npublic class TestArgs\n{\n    public int Value { get; set; }\n}\n\n---\n\n// Subscribe message on global-scope.\nMessageBroker.Default.Receive<TestArgs>().Subscribe(x => UnityEngine.Debug.Log(x));\n\n// Publish message\nMessageBroker.Default.Publish(new TestArgs { Value = 1000 });\n```\n\nAsyncMessageBroker is variation of MessageBroker, can await Publish call.\n\n```csharp\nAsyncMessageBroker.Default.Subscribe<TestArgs>(x =>\n{\n    // show after 3 seconds.\n    return Observable.Timer(TimeSpan.FromSeconds(3))\n        .ForEachAsync(_ =>\n        {\n            UnityEngine.Debug.Log(x);\n        });\n});\n\nAsyncMessageBroker.Default.PublishAsync(new TestArgs { Value = 3000 })\n    .Subscribe(_ =>\n    {\n        UnityEngine.Debug.Log(\"called all subscriber completed\");\n    });\n```\n\nUniRx.Toolkit\n---\n`UniRx.Toolkit` includes serveral Rx-ish tools. Currently includes `ObjectPool` and `AsyncObjectPool`.  It can `Rent`, `Return` and `PreloadAsync` for fill pool before rent operation.\n\n```csharp\n// sample class\npublic class Foobar : MonoBehaviour\n{\n    public IObservable<Unit> ActionAsync()\n    {\n        // heavy, heavy, action...\n        return Observable.Timer(TimeSpan.FromSeconds(3)).AsUnitObservable();\n    }\n}\n\npublic class FoobarPool : ObjectPool<Foobar>\n{\n    readonly Foobar prefab;\n    readonly Transform hierarchyParent;\n\n    public FoobarPool(Foobar prefab, Transform hierarchyParent)\n    {\n        this.prefab = prefab;\n        this.hierarchyParent = hierarchyParent;\n    }\n\n    protected override Foobar CreateInstance()\n    {\n        var foobar = GameObject.Instantiate<Foobar>(prefab);\n        foobar.transform.SetParent(hierarchyParent);\n\n        return foobar;\n    }\n\n    // You can overload OnBeforeRent, OnBeforeReturn, OnClear for customize action.\n    // In default, OnBeforeRent = SetActive(true), OnBeforeReturn = SetActive(false)\n\n    // protected override void OnBeforeRent(Foobar instance)\n    // protected override void OnBeforeReturn(Foobar instance)\n    // protected override void OnClear(Foobar instance)\n}\n\npublic class Presenter : MonoBehaviour\n{\n    FoobarPool pool = null;\n\n    public Foobar prefab;\n    public Button rentButton;\n\n    void Start()\n    {\n        pool = new FoobarPool(prefab, this.transform);\n\n        rentButton.OnClickAsObservable().Subscribe(_ =>\n        {\n            var foobar = pool.Rent();\n            foobar.ActionAsync().Subscribe(__ =>\n            {\n                // if action completed, return to pool\n                pool.Return(foobar);\n            });\n        });\n    }\n}\n```\n\nVisual Studio Analyzer\n---\nFor Visual Studio 2015 users, a custom analyzer, UniRxAnalyzer, is provided. It can, for example, detect when streams aren't subscribed to.\n\n![](StoreDocument/AnalyzerReference.jpg)\n\n![](StoreDocument/VSAnalyzer.jpg)\n\n`ObservableWWW` doesn't fire until it's subscribed to, so the analyzer warns about incorrect usage. It can be downloaded from NuGet.\n\n* Install-Package [UniRxAnalyzer](http://www.nuget.org/packages/UniRxAnalyzer)\n\nPlease submit new analyzer ideas on GitHub Issues!\n\nSamples\n---\nSee [UniRx/Examples](https://github.com/neuecc/UniRx/tree/master/Assets/Plugins/UniRx/Examples)  \n\nThe samples demonstrate how to do resource management (Sample09_EventHandling), what is the MainThreadDispatcher, among other things.\n\nWindows Store/Phone App (NETFX_CORE)\n---\nSome interfaces, such as  `UniRx.IObservable<T>` and `System.IObservable<T>`, cause conflicts when submitting to the Windows Store App.\nTherefore, when using NETFX_CORE, please refrain from using such constructs as `UniRx.IObservable<T>` and refer to the UniRx components by their short name, without adding the namespace. This solves the conflicts.\n\nDLL Separation\n---\nIf you want to pre-build UniRx, you can build own dll. clone project and open `UniRx.sln`, you can see `UniRx`, it is fullset separated project of UniRx. You should define compile symbol like  `UNITY;UNITY_5_4_OR_NEWER;UNITY_5_4_0;UNITY_5_4;UNITY_5;` + `UNITY_EDITOR`, `UNITY_IPHONE` or other platform symbol. We can not provides pre-build binary to release page, asset store because compile symbol is different each other.\n\nUPM Package\n---\nAfter Unity 2019.3.4f1, Unity 2020.1a21, that support path query parameter of git package. You can add `https://github.com/neuecc/UniRx.git?path=Assets/Plugins/UniRx/Scripts` to Package Manager\n\nor add `\"com.neuecc.unirx\": \"https://github.com/neuecc/UniRx.git?path=Assets/Plugins/UniRx/Scripts\"` to `Packages/manifest.json`.\n\nReference\n---\n* [UniRx/wiki](https://github.com/neuecc/UniRx/wiki)\n\nUniRx API documents.\n\n* [ReactiveX](http://reactivex.io/)\n\nThe home of ReactiveX. [Introduction](http://reactivex.io/intro.html), [All operators](http://reactivex.io/documentation/operators.html) are illustrated with graphical marble diagrams, there makes easy to understand. And UniRx is official [ReactiveX Languages](http://reactivex.io/languages.html).\n\n* [Introduction to Rx](http://introtorx.com/)\n\nA great online tutorial and eBook.\n\n* [Beginner's Guide to the Reactive Extensions](http://msdn.microsoft.com/en-us/data/gg577611)\n\nMany videos, slides and documents for Rx.NET.\n\n* [The future of programming technology in Unity - UniRx -(JPN)](http://www.slideshare.net/torisoup/unity-unirx) \n  - [Korean translation](http://www.slideshare.net/agebreak/160402-unirx)\n\nIntro slide by [@torisoup](https://github.com/torisoup)\n\n* [Reactive Programming, â€‹Unity 3D and you](http://slides.com/sammegidov/unirx#/)\n  - [Repository of UniRxSimpleGame](https://github.com/Xerios/UniRxSimpleGame)\n\nIntro slide and sample game by [@Xerios](https://github.com/Xerios)\n\n* [GDC 2016 Sessions of Adventure Capialist](https://www.youtube.com/watch?v=j3YhG91mPsU&feature=youtu.be&t=9m12s)\n\nHow to integrate with PlayFab API\n\nHelp & Contribute\n---\nSupport thread on the Unity forum. Ask me any question - [http://forum.unity3d.com/threads/248535-UniRx-Reactive-Extensions-for-Unity](http://forum.unity3d.com/threads/248535-UniRx-Reactive-Extensions-for-Unity)  \n\nWe welcome any contributions, be they bug reports, requests or pull request.  \nPlease consult and submit your reports or requests on GitHub issues.  \nSource code is available in `Assets/Plugins/UniRx/Scripts`.  \n\nAuthor's other Unity + LINQ Assets\n---\n[LINQ to GameObject](https://github.com/neuecc/LINQ-to-GameObject-for-Unity/) is a group of GameObject extensions for Unity that allows traversing the hierarchy and appending GameObject to it like LINQ to XML. It's free and opensource on GitHub.\n\n![](https://raw.githubusercontent.com/neuecc/LINQ-to-GameObject-for-Unity/master/Images/axis.jpg)\n\nAuthor Info\n---\nYoshifumi Kawai(a.k.a. neuecc) is a software developer in Japan.  \nCurrently founded consulting company [New World, Inc.](http://new-world.co/)  \nHe is awarding Microsoft MVP for Visual C# since 2011.  \n\nBlog: https://medium.com/@neuecc (English)  \nBlog: http://neue.cc/ (Japanese)   \nTwitter: https://twitter.com/neuecc (Japanese)\n\nLicense\n---\nThis library is under the MIT License.\n\nSome code is borrowed from [Rx.NET](https://github.com/dotnet/reactive/) and [mono/mcs](https://github.com/mono/mono).\n",
  "stars": 7248,
  "timestamp": "2025-06-27T00:14:28.143963",
  "category": "advanced_patterns"
}