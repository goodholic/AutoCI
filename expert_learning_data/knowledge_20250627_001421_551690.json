{
  "source": "github_patterns",
  "url": "https://github.com/dotnetcore/CAP",
  "type": "project_documentation",
  "content": "<p align=\"center\">\n  <img height=\"140\" src=\"https://raw.githubusercontent.com/dotnetcore/CAP/master/docs/content/img/logo.svg\">\n</p>\n\n# CAP 　　　　　　　　　　　　　　　　　　　　[中文](https://github.com/dotnetcore/CAP/blob/master/README.zh-cn.md)\n[![Docs&Dashboard](https://github.com/dotnetcore/CAP/actions/workflows/deploy-docs-and-dashboard.yml/badge.svg?branch=master)](https://github.com/dotnetcore/CAP/actions/workflows/deploy-docs-and-dashboard.yml)\n[![AppVeyor](https://ci.appveyor.com/api/projects/status/v8gfh6pe2u2laqoa/branch/master?svg=true)](https://ci.appveyor.com/project/yang-xiaodong/cap/branch/master)\n[![NuGet](https://img.shields.io/nuget/v/DotNetCore.CAP.svg)](https://www.nuget.org/packages/DotNetCore.CAP/)\n[![NuGet Preview](https://img.shields.io/nuget/vpre/DotNetCore.CAP.svg?label=nuget-pre)](https://www.nuget.org/packages/DotNetCore.CAP/)\n[![Member project of .NET Core Community](https://img.shields.io/badge/member%20project%20of-NCC-9e20c9.svg)](https://github.com/dotnetcore)\n[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://raw.githubusercontent.com/dotnetcore/CAP/master/LICENSE.txt)\n\nCAP is a library based on .Net standard, which is a solution to deal with distributed transactions, has the function of EventBus, it is lightweight, easy to use, and efficient.\n\nIn the process of building an SOA or MicroService system, we usually need to use the event to integrate each service. In the process, simple use of message queue does not guarantee reliability. CAP adopts local message table program integrated with the current database to solve exceptions that may occur in the process of the distributed system calling each other. It can ensure that the event messages are not lost in any case.\n\nYou can also use CAP as an EventBus. CAP provides a simpler way to implement event publishing and subscriptions. You do not need to inherit or implement any interface during subscription and sending process.\n\n## Architecture overview\n\n![cap.png](https://raw.githubusercontent.com/dotnetcore/CAP/master/docs/content/img/architecture-new.png)\n\n> CAP implements the Outbox Pattern described in the [eShop ebook](https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/subscribe-events#designing-atomicity-and-resiliency-when-publishing-to-the-event-bus).\n\n## Getting Started\n\n### NuGet\n\nCAP can be installed in your project with the following command.\n\n```\nPM> Install-Package DotNetCore.CAP\n```\n\nCAP supports most popular message queue as transport, following packages are available to install:\n\n```\nPM> Install-Package DotNetCore.CAP.Kafka\nPM> Install-Package DotNetCore.CAP.RabbitMQ\nPM> Install-Package DotNetCore.CAP.AzureServiceBus\nPM> Install-Package DotNetCore.CAP.AmazonSQS\nPM> Install-Package DotNetCore.CAP.NATS\nPM> Install-Package DotNetCore.CAP.RedisStreams\nPM> Install-Package DotNetCore.CAP.Pulsar\n```\n\nCAP supports most popular database as event storage, following packages are available to install:\n\n```\n// select a database provider you are using, event log table will integrate into.\n\nPM> Install-Package DotNetCore.CAP.SqlServer\nPM> Install-Package DotNetCore.CAP.MySql\nPM> Install-Package DotNetCore.CAP.PostgreSql\nPM> Install-Package DotNetCore.CAP.MongoDB     //need MongoDB 4.0+ cluster\n```\n\n### Configuration\n\nFirst, you need to configure CAP in your Startup.cs：\n\n```cs\npublic void ConfigureServices(IServiceCollection services)\n{\n    //......\n\n    services.AddDbContext<AppDbContext>(); //Options, If you are using EF as the ORM\n    services.AddSingleton<IMongoClient>(new MongoClient(\"\")); //Options, If you are using MongoDB\n\n    services.AddCap(x =>\n    {\n        // If you are using EF, you need to add the configuration：\n        x.UseEntityFramework<AppDbContext>(); //Options, Notice: You don't need to config x.UseSqlServer(\"\"\") again! CAP can autodiscovery.\n\n        // If you are using ADO.NET, choose to add configuration you needed：\n        x.UseSqlServer(\"Your ConnectionStrings\");\n        x.UseMySql(\"Your ConnectionStrings\");\n        x.UsePostgreSql(\"Your ConnectionStrings\");\n\n        // If you are using MongoDB, you need to add the configuration：\n        x.UseMongoDB(\"Your ConnectionStrings\");  //MongoDB 4.0+ cluster\n\n        // CAP support RabbitMQ,Kafka,AzureService as the MQ, choose to add configuration you needed：\n        x.UseRabbitMQ(\"HostName\");\n        x.UseKafka(\"ConnectionString\");\n        x.UseAzureServiceBus(\"ConnectionString\");\n        x.UseAmazonSQS();\n    });\n}\n\n```\n\n### Publish\n\nInject `ICapPublisher` in your Controller, then use the `ICapPublisher` to send messages.\n\n> The version 7.0+ supports publish delay messages.\n\n```c#\npublic class PublishController : Controller\n{\n    private readonly ICapPublisher _capBus;\n\n    public PublishController(ICapPublisher capPublisher)\n    {\n        _capBus = capPublisher;\n    }\n\n    [Route(\"~/adonet/transaction\")]\n    public IActionResult AdonetWithTransaction()\n    {\n        using (var connection = new MySqlConnection(ConnectionString))\n        {\n            using (var transaction = connection.BeginTransaction(_capBus, autoCommit: true))\n            {\n                //your business logic code\n\n                _capBus.Publish(\"xxx.services.show.time\", DateTime.Now);\n\n                // Publish delay message\n                _capBus.PublishDelayAsync(TimeSpan.FromSeconds(delaySeconds), \"xxx.services.show.time\", DateTime.Now);\n            }\n        }\n\n        return Ok();\n    }\n\n    [Route(\"~/ef/transaction\")]\n    public IActionResult EntityFrameworkWithTransaction([FromServices]AppDbContext dbContext)\n    {\n        using (var trans = dbContext.Database.BeginTransaction(_capBus, autoCommit: true))\n        {\n            //your business logic code\n\n            _capBus.Publish(\"xxx.services.show.time\", DateTime.Now);\n        }\n\n        return Ok();\n    }\n}\n\n```\n\n### Subscribe\n\n**In Controller Action**\n\nAdd the Attribute `[CapSubscribe()]` on Action to subscribe to messages:\n\n```c#\npublic class PublishController : Controller\n{\n    [CapSubscribe(\"xxx.services.show.time\")]\n    public void CheckReceivedMessage(DateTime datetime)\n    {\n        Console.WriteLine(datetime);\n    }\n}\n\n```\n\n**In Business Logic Service**\n\nIf your subscription method is not in the Controller, then your subscribe class needs to implement `ICapSubscribe` interface:\n\n```c#\n\nnamespace BusinessCode.Service\n{\n    public interface ISubscriberService\n    {\n        void CheckReceivedMessage(DateTime datetime);\n    }\n\n    public class SubscriberService: ISubscriberService, ICapSubscribe\n    {\n        [CapSubscribe(\"xxx.services.show.time\")]\n        public void CheckReceivedMessage(DateTime datetime)\n        {\n        }\n    }\n}\n\n```\n\nThen register your class that implements `ISubscriberService` in Startup.cs\n\n```c#\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddTransient<ISubscriberService,SubscriberService>();\n\n    services.AddCap(x=>\n    {\n        //...\n    });\n}\n```\n#### Async subscription\n\nYou are able to implement async subscription. Subscription's method should return Task and receive CancellationToken as parameter.\n\n```c#\npublic class AsyncSubscriber : ICapSubscribe\n{\n    [CapSubscribe(\"name\")]\n    public async Task ProcessAsync(Message message, CancellationToken cancellationToken)\n    {\n        await SomeOperationAsync(message, cancellationToken);\n    }\n}\n```\n#### Use partials for topic subscriptions\n\nTo group topic subscriptions on class level you're able to define a subscription on a method as a partial. Subscriptions on the message queue will then be a combination of the topic defined on the class and the topic defined on the method. In the following example the `Create(..)` function will be invoked when receiving a message on `customers.create`\n\n```c#\n[CapSubscribe(\"customers\")]\npublic class CustomersSubscriberService : ICapSubscribe\n{\n    [CapSubscribe(\"create\", isPartial: true)]\n    public void Create(Customer customer)\n    {\n    }\n}\n```\n\n#### Subscribe Group\n\nThe concept of a subscription group is similar to that of a consumer group in Kafka. it is the same as the broadcast mode in the message queue, which is used to process the same message between multiple different microservice instances.\n\nWhen CAP startups, it will use the current assembly name as the default group name, if multiple same group subscribers subscribe to the same topic name, there is only one subscriber that can receive the message.\nConversely, if subscribers are in different groups, they will all receive messages.\n\nIn the same application, you can specify `Group` property to keep subscriptions in different subscribe groups:\n\n```C#\n\n[CapSubscribe(\"xxx.services.show.time\", Group = \"group1\" )]\npublic void ShowTime1(DateTime datetime)\n{\n}\n\n[CapSubscribe(\"xxx.services.show.time\", Group = \"group2\")]\npublic void ShowTime2(DateTime datetime)\n{\n}\n\n```\n`ShowTime1` and `ShowTime2` will be called at the same time.\n\nBTW, You can specify the default group name in the configuration:\n\n```C#\nservices.AddCap(x =>\n{\n    x.DefaultGroup = \"default-group-name\";  \n});\n\n```\n\n### Dashboard\n\nCAP also provides dashboard pages, you can easily view messages that were sent and received. In addition, you can also view the message status in real time in the dashboard. Use the following command to install the Dashboard in your project.\n\n```\nPM> Install-Package DotNetCore.CAP.Dashboard\n```\n\nIn the distributed environment, the dashboard built-in integrates [Consul](http://consul.io) as a node discovery, while the realization of the gateway agent function, you can also easily view the node or other node data, It's like you are visiting local resources.\n\n[View Consul config docs](https://cap.dotnetcore.xyz/user-guide/en/monitoring/consul)\n\nIf your service is deployed in Kubernetes, please use our Kubernetes discovery package.\n\n```\nPM> Install-Package DotNetCore.CAP.Dashboard.K8s\n```\n\n[View Kubernetes config docs](https://cap.dotnetcore.xyz/user-guide/en/monitoring/kubernetes/)\n\nThe dashboard default address is: [http://localhost:xxx/cap](http://localhost:xxx/cap) , you can configure relative path `/cap` with `x.UseDashboard(opt =>{ opt.MatchPath=\"/mycap\"; })`.\n\n\n## Contribute\n\nOne of the easiest ways to contribute is to participate in discussions and discuss issues. You can also contribute by submitting pull requests with code changes.\n\n### License\n\n[MIT](https://github.com/dotnetcore/CAP/blob/master/LICENSE.txt)\n",
  "stars": 6913,
  "timestamp": "2025-06-27T00:14:21.551681",
  "category": "advanced_patterns"
}