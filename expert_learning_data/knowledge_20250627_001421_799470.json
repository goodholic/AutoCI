{
  "source": "github_patterns",
  "url": "https://github.com/microsurging/surging",
  "type": "project_documentation",
  "content": "﻿# surging 　　　　　　　　　　　　　　　　　　　　[English](https://github.com/dotnetcore/surging/blob/master/README.EN.md)\n[![Member project of .NET Core Community](https://img.shields.io/badge/member%20project%20of-NCC-9e20c9.svg)](https://github.com/dotnetcore)\n[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://mit-license.org/)\n### surging 是一个分布式微服务框架,提供高性能RPC远程服务调用，采用Zookeeper、Consul作为surging服务的注册中心，集成了哈希，随机，轮询，压力最小优先作为负载均衡的算法，RPC可以选择采用netty或thrift框架，采用异步非阻塞传输。\n\n<br />\n\n### 名字由来\n\n英文名：surging\n\n中文名：滔滔\n\n中文名来自周星驰的经典台词\n\n我对阁下的景仰犹如滔滔江水,连绵不绝,犹如黄河泛滥,一发而不可收拾，而取名英文的含义也希望此框架能流行起来，也能像《.net core surging》这句英文语句含义一样，.net core技术风起云涌,冲击整个软件生态系统。\n\n### 微服务定义\n微服务应该是可以自由组合拆分，对于每个业务都是独立的，针对于业务模块的 CRUD 可以注册为服务，而每个服务都是高度自治的，从开发，部署都是独立，而每个服务只做单一功能，利用领域驱动设计去更好的拆分成粒度更小的模块\n\n### 微服务边界\n微服务是针对业务的松耦合，也是粒度最小的功能业务模块，针对于行业解决方案，集成相应的service host,而针对于业务需要一些中间件来辅助，比如缓存中间件，eventbus中间件（消息中间件），数据储存中间件,而各个服务又可以互相通过rpc进行可靠性通信。\n\n引擎是微服务的容器，而docker 是服务引擎的容器，而利用k8s或rancher可以针对docker集群化管理，可以服务编排弹性扩容，熟知工具，让工具物尽其用。\n\n### 能做什么\n1.简化的服务调用，通过服务规则的指定，就可以做到服务之间的远程调用，无需其它方式的侵入\n\n2.服务自动注册与发现，不需要配置服务提供方地址，注册中心基于ServiceId 或者RoutePath查询服务提供者的地址和元数据，并且能够平滑添加或删除服务提供者。\n\n3.软负载均衡及容错机制，通过surging内部负载算法和容错规则的设定，从而达到内部调用的负载和容错\n\n4.分布式缓存中间件：通过哈希一致性算法来实现负载，并且有健康检查能够平滑的把不健康的服务从列表中删除\n\n5. 事件总线：通过对于事件总线的适配可以实现发布订阅交互模式\n\n6.容器化持续集成与持续交付 ：通过构建一体化Devops平台,实现项目的自动化构建、部署、测试和发布，从而提高生产环境的可靠性、稳定性、弹性和安全性。\n\n7. 业务模块化驱动引擎，通过加载指定业务模块，能够更加灵活、高效的部署不同版本的业务功能模块\n\n### 引擎如何安装\n\ndocker hub : docker pull serviceengine/surging:版本号\n\nnuget:Install-Package surging -Version  版本号\n\n### 架构图\n\n<img src=\"https://github.com/dotnetcore/surging/blob/master/docs/Architecture.png\" alt=\"架构图\" />\n\n### 调用链\n\n<img src=\"https://github.com/dotnetcore/surging/blob/master/docs/call-chain.png\" alt=\"链路图\" />\n\n### 配置：\n\n ```c#\nvar host = new ServiceHostBuilder()\n                .RegisterServices(builder =>\n                {\n                    builder.AddMicroService(option =>\n                    {\n                        option.AddServiceRuntime();//\n                        option.AddRelateService();//添加支持服务代理远程调用\n                         option.AddConfigurationWatch();//添加同步更新配置文件的监听处理\n                        // option.UseZooKeeperManager(new ConfigInfo(\"127.0.0.1:2181\")); //使用Zookeeper管理\n                        option.UseConsulManager(new ConfigInfo(\"127.0.0.1:8500\"));//使用Consul管理\n                        option.UseDotNettyTransport();//使用Netty传输\n                        option.UseRabbitMQTransport();//使用rabbitmq 传输\n                        option.AddRabbitMQAdapt();//基于rabbitmq的消费的服务适配\n                      //  option.UseProtoBufferCodec();//基于protobuf序列化\n                        option.UseMessagePackCodec();//基于MessagePack序列化\n                        builder.Register(p => new CPlatformContainer(ServiceLocator.Current));//初始化注入容器\n                    });\n                })\n                .SubscribeAt()     //消息订阅\n              //.UseServer(\"127.0.0.1\", 98)\n              //.UseServer(\"127.0.0.1\", 98，“true”) //自动生成Token\n              //.UseServer(\"127.0.0.1\", 98，“123456789”) //固定密码Token\n                .UseServer(options=> {\n                    options.Ip = \"127.0.0.1\";\n                    options.Port = 98;\n                    //options.IpEndpoint = new IPEndPoint(IPAddress.Any, 98);\n                    //options.Ip = \"0.0.0.0\";\n                    options.ExecutionTimeoutInMilliseconds = 30000; //执行超时时间\n                    options.Strategy=(int)StrategyType.Failover; //容错策略使用故障切换\n                    options.RequestCacheEnabled=true; //开启缓存（只有通过接口代理远程调用，才能启用缓存）\n                    options.Injection=\"return null\"; //注入方式\n                    options.InjectionNamespaces= new string[] { \"Surging.IModuleServices.Common\" }); //脚本注入使用的命名空间\n                    options.BreakeErrorThresholdPercentage=50;  //错误率达到多少开启熔断保护\n                    options.BreakeSleepWindowInMilliseconds=60000; //熔断多少毫秒后去尝试请求\n                    options.BreakerForceClosed=false;   //是否强制关闭熔断\n                    options.BreakerRequestVolumeThreshold = 20;//10秒钟内至少多少请求失败，熔断器才发挥起作用\n                    options.MaxConcurrentRequests=100000;//支持最大并发\n                    options.ShuntStrategy=AddressSelectorMode.Polling; //使用轮询负载分流策略\n                    options.NotRelatedAssemblyFiles = \"Centa.Agency.Application.DTO\\\\w*|StackExchange.Redis\\\\w*\"; //排除无需依赖注册\n                })\n                //.UseLog4net(\"Configs/log4net.config\") //使用log4net记录日志\n                .UseNLog(LogLevel.Error, \"Configs/NLog.config\")// 使用NLog 记录日志\n                //.UseLog4net(LogLevel.Error) //使用log4net记录日志\n                //.UseLog4net()  //使用log4net记录日志\n                .Configure(build =>\n                build.AddEventBusFile(\"eventBusSettings.json\", optional: false))//使用eventBusSettings.json文件进行配置\n                .Configure(build =>\n                 build.AddCacheFile(\"cacheSettings.json\", optional: false))//使用cacheSettings.json文件进行配置\n                .UseProxy() //使用Proxy\n                .UseStartup<Startup>()\n                .Build();\n                \n            using (host.Run())\n            {\n                Console.WriteLine($\"服务端启动成功，{DateTime.Now}。\");\n            }\n ```    \n<br/>\n\n### 文件配置：\n\n```c#\n{\n  \"ConnectionString\": \"${Register_Conn}|127.0.0.1:8500\", // ${环境变量名} |默认值,\n  \"SessionTimeout\": \"${Register_SessionTimeout}|50\",\n  \"ReloadOnChange\": true\n}\n\n```\n\n### 非容器环境文件配置\n\n```c#\n {\n  \"Ip\": \"${Server_IP}|127.0.0.1\",\n  \"WatchInterval\": 30,\n  \"Port\": \"${Server_port}\",\n  \"Token\": \"true\",\n   \"Protocol\": \"${Protocol}|Tcp\", //支持Http,Tcp协议\n  \"RootPath\": \"${RootPath}\",\n  \"RequestCacheEnabled\": false\n}\n\n```\n\n\n### 容器环境文件配置\n\n```c#\n {\n  \"Ip\": \"${Server_IP}|0.0.0.0\",//私有容器IP\n  \"WatchInterval\": 30,\n  \"Port\": \"${Server_port}|98\",//私有容器端口\n   \"MappingIp\": \"${Mapping_ip}\",//公开主机IP\n  \"MappingPort\": \"${Mapping_Port}\",//公开主机端口\n   \"Protocol\": \"${Protocol}|Tcp\", //支持Http,Tcp协议\n  \"Token\": \"true\",\n  \"RootPath\": \"${RootPath}\",\n  \"RequestCacheEnabled\": false\n}\n\n```\n\n\n服务路由访问配置：\n<br/>\n\n```c#\n[ServiceBundle(\"api/{Service}\")]\n ```    \n<br/>\n\nJWT验证，接口方法添加以下特性：\n<br/>\n\n```c#\n   [Authorization(AuthType = AuthorizationType.JWT)];\n ```    \n<br/>\n\nAppSecret验证，接口方法添加以下特性：\n<br/>\n\n```c#\n [Authorization(AuthType = AuthorizationType.AppSecret)];\n ```    \n<br/>\n\n订阅功能：\n<br/>\n\n```c#\n ServiceLocator.GetService< ISubscriptionAdapt >().SubscribeAt();\n ```    \n \n <br/>\n增加服务容错、服务容错降级、服务强制降级\n\n\n* 增加容错策略Injection，脚本注入：\n\n<br/>\n\n```c#\n[Command(Strategy= StrategyType.Injection ,Injection = @\"return null;\")]\n```    \n\n <br/>\n \n```C#  \n[Command(Strategy= StrategyType.Injection ,Injection = @\"return \nTask.FromResult(new Surging.IModuleServices.Common.Models.UserModel\n         {\n            Name=\"\"fanly\"\",\n            Age=18\n         });\",InjectionNamespaces =new string[] { \"Surging.IModuleServices.Common\"})] \n```\n\n\n* 增加容错策略Injection，本地模块注入：   \n\n<br/>\n\n```C#  \n[Command(Strategy= StrategyType.Injection ,Injection = @\"return true;\")] \n```\n\n<br/>\n\n增加缓存降级，怎么使用？\n<br/>\n在业务接口方法上添加如下特性\n<br/>\n\n```C#  \n   [Command(Strategy= StrategyType.Failover,FailoverCluster =3,RequestCacheEnabled =true)]  //RequestCacheEnabled =true 就是启用缓存\n```\n\n<br/>\n怎么拦截获取缓存\n <br/>\n在业务接口方法上添加如下特性\n <br/>\n \n```C#  \n [InterceptMethod(CachingMethod.Get, Key = \"GetUser_id_{0}\", Mode = CacheTargetType.Redis, Time = 480)]\n```\n    \n<br/>\n怎么拦截删除缓存\n <br/>\n在业务接口方法上添加如下特性\n <br/>\n \n```C#  \n  [InterceptMethod(CachingMethod.Remove, \"GetUser_id_{0}\", \"GetUserName_name_{0}\", Mode = CacheTargetType.Redis)]\n```\n      \n<br/>\n怎么添加缓存KEY\n   <br/>\n在业务模型属性上添加，如下特性，可以支持多个\n   <br/>\n   \n```C# \n[CacheKey(1)]\n```\n        \n<br/>\n配置拦截器\n<br/>\n   \n```C# \n .AddClientIntercepted(typeof(CacheProviderInterceptor))\n```\n\n## 捐赠明细\n\nsurging 接受来自社区的捐赠，所有款项将通过 [捐赠明细表](Statement-of-Income-and-Expense.md) 进行公示，接受社区监督。\n\nIDE:Visual Studio 2017 15.5,vscode\n<br/>\n框架：.NET core 2.1\n<br/>\nQQ群：615562965\n* [文档](http://docs.dotnet-china.org/surging/)\n* [简单示例](https://github.com/dotnetcore/surging/blob/master/docs/docs.en/INDEX.md)\n\n## 谁在使用\n\n\n",
  "stars": 3249,
  "timestamp": "2025-06-27T00:14:21.799460",
  "category": "advanced_patterns"
}