#!/usr/bin/env python3
"""
AutoCI - AI ê²Œì„ ê°œë°œ ì‹œìŠ¤í…œ
24ì‹œê°„ ìë™ ê²Œì„ ê°œë°œ AI
Cross-platform support for Windows and WSL
"""

import sys
import os
import asyncio
import platform
import subprocess
from pathlib import Path
from datetime import datetime

# Platform detection and path setup
def get_project_root():
    """Get project root path based on platform"""
    if platform.system() == "Windows":
        # Windows: use script directory
        return Path(os.path.dirname(os.path.abspath(__file__)))
    else:
        # WSL/Linux: use configured path
        return Path("/mnt/d/AutoCI/AutoCI")

# Set project root
PROJECT_ROOT = get_project_root()
sys.path.insert(0, str(PROJECT_ROOT))
sys.path.insert(0, str(PROJECT_ROOT / 'core_system'))
sys.path.insert(0, str(PROJECT_ROOT / 'modules'))
sys.path.insert(0, str(PROJECT_ROOT / 'modules_active'))

# Platform-specific imports
if platform.system() != "Windows":
    try:
        from core.xlib_suppressor import suppress_all_xlib_warnings
        suppress_all_xlib_warnings()
    except ImportError:
        pass  # Xlib not needed on Windows

# Import session manager
try:
    from modules.game_session_manager import GameSessionManager
    SESSION_MANAGER_AVAILABLE = True
except ImportError:
    SESSION_MANAGER_AVAILABLE = False

# ê°€ìƒí™˜ê²½ í™œì„±í™” ì²´í¬
def check_virtualenv():
    """ê°€ìƒí™˜ê²½ ì²´í¬ ë° í™œì„±í™” ì•ˆë‚´"""
    # Windowsì—ì„œ py ëª…ë ¹ì–´ë¡œ ì‹¤í–‰í•˜ëŠ” ê²½ìš° ê°€ìƒí™˜ê²½ ì²´í¬ ê±´ë„ˆë›°ê¸°
    if platform.system() == "Windows" and os.environ.get('AUTOCI_SKIP_VENV_CHECK') == '1':
        return True
        
    if not hasattr(sys, 'real_prefix') and not (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix):
        print("âš ï¸  ê°€ìƒí™˜ê²½ì´ í™œì„±í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
        print("ë‹¤ìŒ ëª…ë ¹ì–´ë¡œ ê°€ìƒí™˜ê²½ì„ í™œì„±í™”í•˜ì„¸ìš”:")
        if platform.system() == "Windows":
            print("  autoci_env\\Scripts\\activate.bat  # Command Prompt")
            print("  autoci_env\\Scripts\\Activate.ps1  # PowerShell")
        else:
            print("  source autoci_env/bin/activate  # Linux/WSL")
        return False
    return True

def get_python_executable():
    """Get the appropriate Python executable"""
    return sys.executable

def run_python_script(script_path, args=""):
    """Run Python script with cross-platform support"""
    python_exe = get_python_executable()
    if platform.system() == "Windows":
        # Windows: use subprocess for better compatibility
        cmd = [python_exe, str(script_path)]
        if args:
            cmd.extend(args.split())
        return subprocess.run(cmd, capture_output=False)
    else:
        # WSL/Linux: use os.system
        cmd = f'"{python_exe}" "{script_path}" {args}'
        return os.system(cmd)


def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    # ê°€ìƒí™˜ê²½ ì²´í¬
    if not check_virtualenv():
        print("\nê°€ìƒí™˜ê²½ ì—†ì´ ê³„ì† ì§„í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (y/N): ", end='')
        if input().lower() != 'y':
            sys.exit(1)
    
    # ëª…ë ¹ì¤„ ì¸ì ì²˜ë¦¬
    if len(sys.argv) > 1:
        command = sys.argv[1].lower()
        
        if command == 'learn':
            # AI í•™ìŠµ ëª¨ë“œ - ê°œì„ ëœ ë²„ì „
            print("ğŸ“ AutoCI ê°œì„ ëœ í•™ìŠµ ì‹œìŠ¤í…œì„ ì‹œì‘í•©ë‹ˆë‹¤!")
            print("ğŸ“š ê³ í’ˆì§ˆ ì§€ì‹œ-ì‘ë‹µ ë°ì´í„°ì…‹ì„ êµ¬ì¶•í•˜ë©° í•™ìŠµí•©ë‹ˆë‹¤")
            print("ğŸ“Š ê³¼ì í•© ë°©ì§€ ë° í’ˆì§ˆ ëª¨ë‹ˆí„°ë§ì´ í™œì„±í™”ë©ë‹ˆë‹¤")
            print("ğŸ’¡ Geminiì˜ ì¡°ì–¸ì„ ë°˜ì˜í•œ ì²´ê³„ì ì¸ í•™ìŠµì„ ì§„í–‰í•©ë‹ˆë‹¤")
            
            script_path = PROJECT_ROOT / "core_system" / "continuous_learning_system.py"
            if len(sys.argv) > 2 and sys.argv[2] == 'low':
                print("\nğŸ§  ë©”ëª¨ë¦¬ ìµœì í™” í•™ìŠµ ëª¨ë“œ ì‹œì‘ (8GB)...")
                run_python_script(script_path, "24", "8")
            else:
                print("\nğŸ§  í†µí•© í•™ìŠµ ëª¨ë“œ ì‹œì‘ (32GB)...")
                run_python_script(script_path, "24", "32")
        
        elif command == 'monitor':
            # ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ
            print("ğŸ“Š ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ ì‹œì‘...")
            script_path = PROJECT_ROOT / "modules" / "realtime_monitoring_system.py"
            run_python_script(script_path)
        
        elif command == 'fix':
            # í•™ìŠµ ê¸°ë°˜ ì—”ì§„ ê°œì„ 
            print("ğŸ”§ í•™ìŠµ ê¸°ë°˜ ì—”ì§„ ê°œì„  ì‹œì‘...")
            script_path = PROJECT_ROOT / "core_system" / "ai_engine_updater.py"
            run_python_script(script_path)
        
        elif command == 'create':
            # ê²Œì„ ìƒì„±/ì´ì–´ì„œ ê°œë°œ
            if len(sys.argv) > 2:
                game_type = sys.argv[2]
            else:
                # ê²Œì„ íƒ€ì…ì„ ë¬¼ì–´ë´„
                print("\nğŸ® ì–´ë–¤ ê²Œì„ì„ ë§Œë“¤ê³  ì‹¶ìœ¼ì‹ ê°€ìš”?")
                print("\nì„ íƒ ê°€ëŠ¥í•œ ê²Œì„ íƒ€ì…:")
                print("  1. platformer - í”Œë«í¼ ê²Œì„")
                print("  2. racing     - ë ˆì´ì‹± ê²Œì„")
                print("  3. rpg        - RPG ê²Œì„")
                print("  4. puzzle     - í¼ì¦ ê²Œì„")
                print("\nê²Œì„ íƒ€ì…ì„ ì…ë ¥í•˜ì„¸ìš” (ë²ˆí˜¸ ë˜ëŠ” ì´ë¦„): ", end='')
                
                choice = input().strip().lower()
                
                # ë²ˆí˜¸ë¡œ ì„ íƒí•œ ê²½ìš° ì²˜ë¦¬
                game_type_map = {
                    '1': 'platformer',
                    '2': 'racing',
                    '3': 'rpg',
                    '4': 'puzzle'
                }
                
                if choice in game_type_map:
                    game_type = game_type_map[choice]
                elif choice in ['platformer', 'racing', 'rpg', 'puzzle']:
                    game_type = choice
                else:
                    print("âŒ ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤. platformer, racing, rpg, puzzle ì¤‘ í•˜ë‚˜ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.")
                    sys.exit(1)
            
            # ì„ íƒëœ ê²Œì„ íƒ€ì…ìœ¼ë¡œ ì§„í–‰
            if SESSION_MANAGER_AVAILABLE:
                session_manager = GameSessionManager()
                existing_session = session_manager.get_active_session(game_type)
                
                if existing_session and existing_session.status != 'completed':
                    print(f"\nğŸ® ê¸°ì¡´ {game_type} ê²Œì„ ê°œë°œì„ ë°œê²¬í–ˆìŠµë‹ˆë‹¤!")
                    print(f"   ê²Œì„ ì´ë¦„: {existing_session.game_name}")
                    print(f"   ì§„í–‰ë¥ : {existing_session.progress.get('completion_percentage', 0)}%")
                    print(f"   ë§ˆì§€ë§‰ ìˆ˜ì •: {existing_session.last_modified}")
                    print("\nì´ì–´ì„œ ê°œë°œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (y/n): ", end='')
                    
                    if input().lower() == 'y':
                        print("ğŸ”„ ê²Œì„ ê°œë°œì„ ì´ì–´ì„œ ì§„í–‰í•©ë‹ˆë‹¤...")
                        asyncio.run(resume_game_development(existing_session))
                    else:
                        print("ğŸ†• ìƒˆë¡œìš´ ê²Œì„ ê°œë°œì„ ì‹œì‘í•©ë‹ˆë‹¤...")
                        asyncio.run(create_new_game(game_type))
                else:
                    print(f"\nğŸ†• ìƒˆë¡œìš´ {game_type} ê²Œì„ ê°œë°œì„ ì‹œì‘í•©ë‹ˆë‹¤...")
                    asyncio.run(create_new_game(game_type))
            else:
                print(f"\nğŸ® {game_type} ê²Œì„ ìƒì„± ì‹œì‘...")
                asyncio.run(create_new_game(game_type))
        
        elif command == 'resume':
            
            # Godot í”„ë¡œì íŠ¸ ê²½ë¡œ (ì—¬ëŸ¬ ê²½ë¡œ ì‹œë„)
            possible_paths = [
                Path("/home/super3720/Documents/Godot/Projects"),  # WSL direct path
                Path.home() / "Documents" / "Godot" / "Projects",  # User home path
                Path("//wsl.localhost/Ubuntu/home/super3720/Documents/Godot/Projects"),  # Windows WSL path
                Path("/mnt/c/Users") / os.environ.get('USER', 'super3720') / "Documents" / "Godot" / "Projects"  # WSL to Windows
            ]
            
            godot_projects_path = None
            for path in possible_paths:
                if path.exists():
                    godot_projects_path = path
                    print(f"âœ… Godot í”„ë¡œì íŠ¸ ê²½ë¡œ ë°œê²¬: {path}")
                    break
                    
            if godot_projects_path and godot_projects_path.exists():
                print("ğŸ® Godot í”„ë¡œì íŠ¸ ëª©ë¡:")
                
                # í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ ì°¾ê¸° (project.godot íŒŒì¼ì´ ìˆëŠ” ë””ë ‰í† ë¦¬)
                projects = []
                for item in godot_projects_path.iterdir():
                    if item.is_dir() and (item / "project.godot").exists():
                        projects.append(item)
                
                if not projects:
                    print("ğŸ’­ Godot í”„ë¡œì íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
                else:
                    # í”„ë¡œì íŠ¸ ëª©ë¡ í‘œì‹œ
                    for i, project in enumerate(projects, 1):
                        project_name = project.name
                        # project.godot íŒŒì¼ì—ì„œ í”„ë¡œì íŠ¸ ì •ë³´ ì½ê¸°
                        project_file = project / "project.godot"
                        if project_file.exists():
                            print(f"\n{i}. {project_name}")
                            print(f"   ê²½ë¡œ: {project}")
                            # ë§ˆì§€ë§‰ ìˆ˜ì • ì‹œê°„ í‘œì‹œ
                            mtime = datetime.fromtimestamp(project_file.stat().st_mtime)
                            print(f"   ë§ˆì§€ë§‰ ìˆ˜ì •: {mtime.strftime('%Y-%m-%d %H:%M:%S')}")
                    
                    print("\nì–´ë–¤ í”„ë¡œì íŠ¸ë¥¼ ì´ì–´ì„œ ê°œë°œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ë²ˆí˜¸ ì…ë ¥): ", end='')
                    try:
                        choice = int(input())
                        if 1 <= choice <= len(projects):
                            selected_project = projects[choice - 1]
                            print(f"\nğŸ”„ {selected_project.name} í”„ë¡œì íŠ¸ë¡œ ì´ë™í•©ë‹ˆë‹¤...")
                            
                            # í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ë¡œ ì´ë™
                            os.chdir(selected_project)
                            print(f"ğŸ“ í˜„ì¬ ë””ë ‰í† ë¦¬: {os.getcwd()}")
                            
                            # 24ì‹œê°„ ìë™ ê²Œì„ ê°œë°œ ëª¨ë“œë¡œ ì „í™˜
                            print("\nğŸš€ 24ì‹œê°„ ìë™ ê²Œì„ ê°œë°œ ëª¨ë“œë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...")
                            print("ğŸ’« AIê°€ ìë™ìœ¼ë¡œ ê²Œì„ì„ ë¶„ì„í•˜ê³  ê°œì„ í•©ë‹ˆë‹¤.")
                            
                            # í”„ë¡œì íŠ¸ íƒ€ì… ì¶”ì¸¡ (ë””ë ‰í† ë¦¬ ì´ë¦„ ê¸°ë°˜)
                            project_name = selected_project.name.lower()
                            game_type = 'platformer'  # ê¸°ë³¸ê°’
                            if 'rpg' in project_name:
                                game_type = 'rpg'
                            elif 'tactic' in project_name or 'strategy' in project_name:
                                game_type = 'strategy'
                            elif 'racing' in project_name:
                                game_type = 'racing'
                            elif 'puzzle' in project_name:
                                game_type = 'puzzle'
                            
                            print(f"ğŸ® ê²Œì„ íƒ€ì…: {game_type}")
                            
                            # PersistentGameImproverë¥¼ ì‚¬ìš©í•œ 24ì‹œê°„ ê°œì„  ëª¨ë“œ ì‹œì‘
                            try:
                                from modules.persistent_game_improver import PersistentGameImprover
                                
                                improver = PersistentGameImprover()  # No controller argument
                                
                                # í”„ë¡œì íŠ¸ ê²½ë¡œì™€ íƒ€ì… ì„¤ì •
                                asyncio.run(improver.start_24h_improvement(
                                    selected_project  # Path object expected, not string
                                ))
                            except ImportError as e:
                                print(f"âš ï¸ PersistentGameImprover ë¡œë“œ ì‹¤íŒ¨: {e}")
                                # Fallback to original method
                                asyncio.run(start_auto_development(selected_project, game_type))
                            except Exception as e:
                                print(f"âŒ ì˜¤ë¥˜ ë°œìƒ: {e}")
                                # Fallback to original method
                                asyncio.run(start_auto_development(selected_project, game_type))
                        else:
                            print("âŒ ì˜ëª»ëœ ë²ˆí˜¸ì…ë‹ˆë‹¤.")
                    except ValueError:
                        print("âŒ ì˜ëª»ëœ ì…ë ¥ì…ë‹ˆë‹¤.")
            else:
                print(f"âŒ Godot í”„ë¡œì íŠ¸ ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {godot_projects_path}")
                
                # ê¸°ì¡´ ì„¸ì…˜ ë§¤ë‹ˆì € fallback
                if SESSION_MANAGER_AVAILABLE:
                    print("\nğŸ’¾ ëŒ€ì‹  ì €ì¥ëœ ì„¸ì…˜ì„ í™•ì¸í•©ë‹ˆë‹¤...")
                    session_manager = GameSessionManager()
                    sessions = session_manager.list_sessions(status='paused')
                    
                    if sessions:
                        for i, session in enumerate(sessions, 1):
                            print(f"\n{i}. {session.game_name} ({session.game_type})")
                            print(f"   ì§„í–‰ë¥ : {session.progress.get('completion_percentage', 0)}%")
                        
                        print("\nì„¸ì…˜ì„ ì„ íƒí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (y/N): ", end='')
                        if input().lower() == 'y':
                            print("ë²ˆí˜¸ ì…ë ¥: ", end='')
                            try:
                                choice = int(input())
                                if 1 <= choice <= len(sessions):
                                    selected_session = sessions[choice - 1]
                                    print(f"\nğŸ”„ {selected_session.game_name} ê°œë°œì„ ì¬ê°œí•©ë‹ˆë‹¤...")
                                    asyncio.run(resume_game_development(selected_session))
                            except ValueError:
                                print("âŒ ì˜ëª»ëœ ì…ë ¥ì…ë‹ˆë‹¤.")
        
        elif command == 'sessions':
            # ëª¨ë“  ì„¸ì…˜ ë³´ê¸°
            if SESSION_MANAGER_AVAILABLE:
                print("ğŸ“ ëª¨ë“  ê²Œì„ ê°œë°œ ì„¸ì…˜:")
                session_manager = GameSessionManager()
                sessions = session_manager.list_sessions()
                
                if not sessions:
                    print("ğŸ’­ ì €ì¥ëœ ì„¸ì…˜ì´ ì—†ìŠµë‹ˆë‹¤.")
                else:
                    for session in sessions:
                        status_emoji = {
                            'active': 'ğŸ”´',
                            'paused': 'ğŸŸ¡', 
                            'completed': 'ğŸŸ¢'
                        }.get(session.status, 'âšª')
                        
                        print(f"\n{status_emoji} {session.game_name} ({session.game_type})")
                        print(f"   ID: {session.session_id}")
                        print(f"   ìƒíƒœ: {session.status}")
                        print(f"   ì§„í–‰ë¥ : {session.progress.get('completion_percentage', 0)}%")
                        print(f"   ìƒì„±ì¼: {session.created_at}")
                        print(f"   ë§ˆì§€ë§‰ ìˆ˜ì •: {session.last_modified}")
                        if session.features:
                            print(f"   ê¸°ëŠ¥ë“¤: {', '.join(session.features)}")
            else:
                print("âŒ ì„¸ì…˜ ê´€ë¦¬ìë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        
        elif command == 'chat':
            # í•œê¸€ ëŒ€í™” ëª¨ë“œ
            print("ğŸ’¬ í•œê¸€ ëŒ€í™” ëª¨ë“œ ì‹œì‘...")
            asyncio.run(chat_mode())
        
        elif command == 'talk':
            # PyTorch ëŒ€í™”í˜• í•™ìŠµ ëª¨ë“œ
            print("ğŸ”¥ PyTorch ëŒ€í™”í˜• í•™ìŠµ ëª¨ë“œ ì‹œì‘...")
            asyncio.run(pytorch_talk_mode())
        
        elif command == '--help' or command == '-h':
            show_help()
        
        else:
            print(f"âŒ ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´: {command}")
            show_help()
    
    else:
        # ê¸°ë³¸ ì‹¤í–‰ (ëŒ€í™”í˜• ëª¨ë“œ)
        try:
            from core_system.autoci_panda3d_main import AutoCIPanda3DMain
            asyncio.run(interactive_mode())
        except ImportError as e:
            print(f"âŒ ëª¨ë“ˆ ì„í¬íŠ¸ ì˜¤ë¥˜: {e}")
            print("\ní•„ìš”í•œ íŒ¨í‚¤ì§€ë¥¼ ì„¤ì¹˜í•˜ì„¸ìš”:")
            print("  pip install -r requirements.txt")
            sys.exit(1)


async def interactive_mode():
    """ëŒ€í™”í˜• ëª¨ë“œ"""
    from core_system.autoci_panda3d_main import AutoCIPanda3DMain
    autoci = AutoCIPanda3DMain()
    await autoci.start()

async def create_new_game(game_type: str):
    """ìƒˆ ê²Œì„ ìƒì„± (ê¸°ì¡´ í”„ë¡œì íŠ¸ ìˆìœ¼ë©´ ì´ì–´ì„œ ê°œë°œ)"""
    try:
        # Enhanced create ì‚¬ìš©
        from modules.create_enhanced import create_or_continue_game
        await create_or_continue_game(game_type)
    except ImportError:
        # Fallback to original method
        try:
            from core_system.autoci_panda3d_main import AutoCIPanda3DMain
            autoci = AutoCIPanda3DMain()
            
            # ì„¸ì…˜ ë§¤ë‹ˆì €ê°€ ìˆìœ¼ë©´ ìƒˆ ì„¸ì…˜ ìƒì„±
            if SESSION_MANAGER_AVAILABLE:
                session_manager = GameSessionManager()
                game_name = f"{game_type}_game_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
                session = session_manager.create_session(game_type, game_name)
                autoci.current_session = session
            
            await autoci.create_game(game_type)
        except Exception as e:
            print(f"âŒ ê²Œì„ ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
    except Exception as e:
        print(f"âŒ ê²Œì„ ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")

async def resume_game_development(session):
    """ê¸°ì¡´ ê²Œì„ ê°œë°œ ì´ì–´ì„œ í•˜ê¸°"""
    try:
        from core_system.autoci_panda3d_main import AutoCIPanda3DMain
        autoci = AutoCIPanda3DMain()
        
        # ì„¸ì…˜ ì¬ê°œ
        if SESSION_MANAGER_AVAILABLE:
            session_manager = GameSessionManager()
            session_manager.resume_session(session.session_id)
            autoci.current_session = session
            
            # ì§„í–‰ ìƒí™© í‘œì‹œ
            print(f"\nğŸ“¦ í”„ë¡œì íŠ¸ ì •ë³´:")
            print(f"   í˜„ì¬ ë‹¨ê³„: {session.progress.get('stage', 'unknown')}")
            print(f"   ì™„ë£Œëœ ì‘ì—…: {len(session.progress.get('completed_tasks', []))}")
            print(f"   ì¶”ê°€ëœ ê¸°ëŠ¥: {len(session.features)}")
            
            if session.features:
                print(f"\nğŸ¯ ê¸°ì¡´ ê¸°ëŠ¥ë“¤:")
                for feature in session.features:
                    print(f"   âœ“ {feature}")
        
        # ê²Œì„ ê°œë°œ ê³„ì†
        await autoci.resume_development(session)
    except Exception as e:
        print(f"âŒ ê²Œì„ ê°œë°œ ì¬ê°œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")


async def chat_mode():
    """í•œê¸€ ëŒ€í™” ì „ìš© ëª¨ë“œ"""
    try:
        from modules.korean_conversation_interface import KoreanConversationInterface
        from modules.ai_model_integration import AIModelIntegration
    except ImportError as e:
        print(f"âŒ ëª¨ë“ˆ ì„í¬íŠ¸ ì˜¤ë¥˜: {e}")
        return
    
    ai_model = AIModelIntegration()
    chat_interface = KoreanConversationInterface(ai_model)
    
    print("\nğŸ’¬ AutoCI í•œê¸€ ëŒ€í™” ëª¨ë“œ")
    print("=" * 50)
    print("ìì—°ìŠ¤ëŸ¬ìš´ í•œêµ­ì–´ë¡œ ëŒ€í™”í•˜ì„¸ìš”. 'ì¢…ë£Œ'ë¥¼ ì…ë ¥í•˜ë©´ ëë‚©ë‹ˆë‹¤.")
    print("=" * 50)
    
    while True:
        user_input = input("\nì‚¬ìš©ì: ")
        if user_input.lower() in ['ì¢…ë£Œ', 'exit', 'quit']:
            print("ëŒ€í™”ë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.")
            break
        
        response = await chat_interface.process_input(user_input)
        print(f"\nAutoCI: {response}")


async def pytorch_talk_mode():
    """PyTorch ëŒ€í™”í˜• í•™ìŠµ ëª¨ë“œ"""
    try:
        from modules.pytorch_tutorial_system import PyTorchTutorialSystem
        from modules.ai_model_integration import AIModelIntegration
    except ImportError as e:
        print(f"âŒ ëª¨ë“ˆ ì„í¬íŠ¸ ì˜¤ë¥˜: {e}")
        print("PyTorch íŠœí† ë¦¬ì–¼ ì‹œìŠ¤í…œì„ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        return
    
    # AI ëª¨ë¸ ì—°ê²° ì‹œë„
    ai_model = None
    try:
        ai_model = AIModelIntegration()
        print("âœ… AI ëª¨ë¸ì´ ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤. ë” ë‚˜ì€ ë‹µë³€ì„ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
    except Exception as e:
        print(f"âš ï¸  AI ëª¨ë¸ ì—°ê²° ì‹¤íŒ¨: {e}")
        print("ê¸°ë³¸ íŠœí† ë¦¬ì–¼ ëª¨ë“œë¡œ ì§„í–‰í•©ë‹ˆë‹¤.")
    
    # PyTorch íŠœí† ë¦¬ì–¼ ì‹œìŠ¤í…œ ì‹œì‘
    tutorial_system = PyTorchTutorialSystem(ai_model)
    await tutorial_system.start_tutorial_session()


async def start_auto_development(project_path, game_type):
    """24ì‹œê°„ ìë™ ê²Œì„ ê°œë°œ ì‹œì‘"""
    try:
        # 24ì‹œê°„ ê²Œì„ ê°œë°œ ì‹œìŠ¤í…œ ì„í¬íŠ¸
        from modules.game_factory_24h import GameFactory24H
        from modules.game_development_pipeline import GameDevelopmentPipeline
        
        print("\nğŸ­ 24ì‹œê°„ ê²Œì„ ê°œë°œ ê³µì¥ì„ ì‹œì‘í•©ë‹ˆë‹¤...")
        print(f"ğŸ“‚ í”„ë¡œì íŠ¸: {project_path}")
        print(f"ğŸ® ê²Œì„ íƒ€ì…: {game_type}")
        print("\nâ° ê°œë°œ ì¼ì •:")
        print("  - ë¶„ì„ ë‹¨ê³„: 1ì‹œê°„")
        print("  - ê°œì„  ê³„íš: 2ì‹œê°„") 
        print("  - ê¸°ëŠ¥ êµ¬í˜„: 16ì‹œê°„")
        print("  - í…ŒìŠ¤íŠ¸/ìµœì í™”: 5ì‹œê°„")
        print("\nğŸ’¡ Ctrl+Cë¥¼ ëˆŒëŸ¬ ì–¸ì œë“  ì¤‘ë‹¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
        
        # ê¸°ì¡´ í”„ë¡œì íŠ¸ ì‹¬ì¸µ ë¶„ì„
        print("\nğŸ” ê¸°ì¡´ í”„ë¡œì íŠ¸ë¥¼ ë¶„ì„í•˜ëŠ” ì¤‘...")
        existing_features = []
        project_analysis = {
            'scenes': [],
            'scripts': [],
            'assets': [],
            'systems': []
        }
        
        # project.godot íŒŒì¼ì—ì„œ ê¸°ë³¸ ì •ë³´ ì½ê¸°
        project_file = project_path / "project.godot"
        if project_file.exists():
            print("âœ… project.godot íŒŒì¼ ë°œê²¬")
            existing_features.append("ê¸°ë³¸ í”„ë¡œì íŠ¸ êµ¬ì¡°")
            
            # project.godot ë‚´ìš© ë¶„ì„
            try:
                with open(project_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                    if 'config/name=' in content:
                        game_name = content.split('config/name=')[1].split('\n')[0].strip('"')
                        print(f"   ê²Œì„ ì´ë¦„: {game_name}")
                    if 'main_scene=' in content:
                        main_scene = content.split('main_scene=')[1].split('\n')[0].strip('"')
                        print(f"   ë©”ì¸ ì”¬: {main_scene}")
            except:
                pass
        
        # ì”¬ íŒŒì¼ ë¶„ì„
        scene_count = 0
        for scene_file in project_path.rglob("*.tscn"):
            scene_count += 1
            project_analysis['scenes'].append(scene_file.relative_to(project_path))
        if scene_count > 0:
            existing_features.append(f"ì”¬ íŒŒì¼ {scene_count}ê°œ")
            print(f"   ë°œê²¬ëœ ì”¬: {scene_count}ê°œ")
        
        # ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ ë¶„ì„
        script_count = 0
        for ext in ["*.gd", "*.cs"]:
            for script_file in project_path.rglob(ext):
                script_count += 1
                project_analysis['scripts'].append(script_file.relative_to(project_path))
        if script_count > 0:
            existing_features.append(f"ìŠ¤í¬ë¦½íŠ¸ {script_count}ê°œ")
            print(f"   ë°œê²¬ëœ ìŠ¤í¬ë¦½íŠ¸: {script_count}ê°œ")
        
        # ì—ì…‹ ë¶„ì„
        asset_types = {
            'images': ['*.png', '*.jpg', '*.jpeg'],
            'audio': ['*.wav', '*.ogg', '*.mp3'],
            'models': ['*.obj', '*.gltf', '*.glb']
        }
        
        for asset_type, extensions in asset_types.items():
            count = 0
            for ext in extensions:
                count += len(list(project_path.rglob(ext)))
            if count > 0:
                existing_features.append(f"{asset_type} {count}ê°œ")
                project_analysis['assets'].append(f"{asset_type}: {count}")
        
        # ì£¼ìš” ì‹œìŠ¤í…œ/ê¸°ëŠ¥ ê°ì§€
        if any("player" in str(f).lower() for f in project_analysis['scripts']):
            project_analysis['systems'].append("í”Œë ˆì´ì–´ ì‹œìŠ¤í…œ")
        if any("enemy" in str(f).lower() for f in project_analysis['scripts']):
            project_analysis['systems'].append("ì  ì‹œìŠ¤í…œ")
        if any("ui" in str(f).lower() or "hud" in str(f).lower() for f in project_analysis['scripts']):
            project_analysis['systems'].append("UI ì‹œìŠ¤í…œ")
        if any("inventory" in str(f).lower() for f in project_analysis['scripts']):
            project_analysis['systems'].append("ì¸ë²¤í† ë¦¬ ì‹œìŠ¤í…œ")
        if any("dialog" in str(f).lower() for f in project_analysis['scripts']):
            project_analysis['systems'].append("ëŒ€í™” ì‹œìŠ¤í…œ")
            
        if project_analysis['systems']:
            print(f"\nğŸ¯ ê°ì§€ëœ ì‹œìŠ¤í…œ: {', '.join(project_analysis['systems'])}")
            existing_features.extend(project_analysis['systems'])
            
        if existing_features:
            print(f"\nâœ¨ ë°œê²¬ëœ ìš”ì†Œë“¤: {', '.join(existing_features)}")
        
        # 24ì‹œê°„ ìë™ ê°œë°œ ì‹œì‘
        factory = GameFactory24H()
        
        # ê¸°ì¡´ í”„ë¡œì íŠ¸ë¡œ ì´ˆê¸°í™”
        factory.current_project = {
            'path': str(project_path),
            'name': project_path.name,
            'type': game_type,
            'features': existing_features or []
        }
        
        # ê°œë°œ ì‹œì‘ (ê¸°ì¡´ í”„ë¡œì íŠ¸ ëª¨ë“œ)
        await factory.start_factory(
            game_name=project_path.name,
            game_type=game_type,
            existing_project=True
        )
        
    except KeyboardInterrupt:
        print("\n\nâš ï¸  ì‚¬ìš©ìê°€ ê°œë°œì„ ì¤‘ë‹¨í–ˆìŠµë‹ˆë‹¤.")
        print("ğŸ“ í”„ë¡œì íŠ¸ëŠ” í˜„ì¬ ìƒíƒœë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.")
    except ImportError as e:
        print(f"\nâŒ 24ì‹œê°„ ê°œë°œ ëª¨ë“ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {e}")
        print("\nëŒ€ì‹  ëŒ€í™”í˜• ëª¨ë“œë¡œ ì „í™˜í•©ë‹ˆë‹¤...")
        await interactive_mode()
    except Exception as e:
        print(f"\nâŒ ìë™ ê°œë°œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        print("ìƒì„¸ ì˜¤ë¥˜:", str(e))


def show_help():
    """ë„ì›€ë§ í‘œì‹œ"""
    print(f"""
AutoCI - AI ê²Œì„ ê°œë°œ ì‹œìŠ¤í…œ v5.0
Platform: {platform.system()}

ì‚¬ìš©ë²•:
  autoci                    ëŒ€í™”í˜• ëª¨ë“œ ì‹œì‘
  autoci create [type]      ê²Œì„ ìƒì„±/ì´ì–´ì„œ ê°œë°œ
  autoci resume             Godot í”„ë¡œì íŠ¸ ì„ íƒí•˜ì—¬ 24ì‹œê°„ ìë™ ê°œë°œ
  autoci sessions           ëª¨ë“  ê²Œì„ ê°œë°œ ì„¸ì…˜ ë³´ê¸°
  autoci learn              AI í†µí•© í•™ìŠµ ì‹œì‘
  autoci learn low          ë©”ëª¨ë¦¬ ìµœì í™” í•™ìŠµ (8GB VRAM)
  autoci monitor            ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ
  autoci fix                í•™ìŠµ ê¸°ë°˜ ì—”ì§„ ê°œì„ 
  autoci chat               í•œê¸€ ëŒ€í™” ì „ìš© ëª¨ë“œ
  autoci talk               PyTorch ëŒ€í™”í˜• í•™ìŠµ ëª¨ë“œ
  autoci --help             ë„ì›€ë§ í‘œì‹œ

ëŒ€í™”í˜• ëª¨ë“œ ëª…ë ¹ì–´:
  create [type] game        ê²Œì„ ìƒì„± (platformer, racing, rpg, puzzle)
  add feature [name]        ê¸°ëŠ¥ ì¶”ê°€
  modify [aspect]           ê²Œì„ ìˆ˜ì •
  open_panda3d             Panda3D ì—ë””í„° ì—´ê¸°
  status                    ì‹œìŠ¤í…œ ìƒíƒœ
  help                      ë„ì›€ë§
  exit/quit/ì¢…ë£Œ           ì¢…ë£Œ

ì˜ˆì œ:
  autoci create platformer  # í”Œë«í¼ ê²Œì„ ìƒì„± (ê¸°ì¡´ ê°œë°œ ìˆìœ¼ë©´ ì´ì–´ì„œ)
  autoci resume             # Godot í”„ë¡œì íŠ¸ì—ì„œ 24ì‹œê°„ ìë™ ê°œë°œ ì‹œì‘
  autoci sessions           # ëª¨ë“  ê²Œì„ ê°œë°œ í˜„í™© í™•ì¸
  
  ëŒ€í™”í˜• ëª¨ë“œ:
  > create platformer game  # í”Œë«í¼ ê²Œì„ ìƒì„±
  > add feature double_jump # ë”ë¸” ì í”„ ê¸°ëŠ¥ ì¶”ê°€
  > status                  # ê°œë°œ ìƒíƒœ í™•ì¸

í”Œë«í¼ë³„ ì°¸ê³ ì‚¬í•­:
""")
    
    if platform.system() == "Windows":
        print("  - Windowsì—ì„œ ì‹¤í–‰ ì¤‘")
        print("  - ê²½ë¡œì— ë°±ìŠ¬ë˜ì‹œ ì‚¬ìš©: C:\\AutoCI\\AutoCI")
    else:
        print("  - WSL/Linuxì—ì„œ ì‹¤í–‰ ì¤‘")
        print("  - ê²½ë¡œì— ìŠ¬ë˜ì‹œ ì‚¬ìš©: /mnt/d/AutoCI/AutoCI")


if __name__ == "__main__":
    main()