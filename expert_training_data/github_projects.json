[
  {
    "id": "3598cf8f287c4fe904873389f33ea7b2",
    "source": "github",
    "file_path": "src/common/FilePreviewCommon/MonacoHelper.cs",
    "repository": "",
    "code": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Text.Json;\nusing Microsoft.PowerToys.FilePreviewCommon.Monaco.Formatters;\n\nnamespace Microsoft.PowerToys.FilePreviewCommon\n{\n    public static class MonacoHelper\n    {\n        /// <summary>\n        /// Name of the virtual host\n        /// </summary>\n        public const string VirtualHostName = \"PowerToysLocalMonaco\";\n\n        /// <summary>\n        /// Formatters applied before rendering the preview\n        /// </summary>\n        public static readonly IReadOnlyCollection<IFormatter> Formatters = new List<IFormatter>\n        {\n            new JsonFormatter(),\n            new XmlFormatter(),\n        }.AsReadOnly();\n\n        private static readonly Lazy<string> _monacoDirectory = new(GetRuntimeMonacoDirectory);\n\n        /// <summary>\n        /// Gets the path of the Monaco assets folder.\n        /// </summary>\n        public static string MonacoDirectory => _monacoDirectory.Value;\n\n        private static string GetRuntimeMonacoDirectory()\n        {\n            string baseDirectory = AppContext.BaseDirectory ?? string.Empty;\n\n            // AppContext.BaseDirectory returns a stray \\\\ so we want to remove that.\n            baseDirectory = Path.TrimEndingDirectorySeparator(baseDirectory);\n\n            // If the executable is within \"WinUI3Apps\", correct the path first.\n            // The idea of GetFileName here is getting the last directory in the path.\n            if (Path.GetFileName(baseDirectory) == \"WinUI3Apps\")\n            {\n                baseDirectory = Path.Combine(baseDirectory, \"..\");\n            }\n\n            string monacoPath = Path.Combine(baseDirectory, \"Assets\", \"Monaco\");\n\n            return Directory.Exists(monacoPath) ?\n                monacoPath :\n                throw new DirectoryNotFoundException($\"Monaco assets directory not found at {monacoPath}\");\n        }\n\n        public static JsonDocument GetLanguages()\n        {\n            JsonDocument languageListDocument;\n            using (StreamReader jsonFileReader = new StreamReader(new FileStream(MonacoDirectory + \"\\\\monaco_languages.json\", FileMode.Open, FileAccess.Read, FileShare.ReadWrite)))\n            {\n                languageListDocument = JsonDocument.Parse(jsonFileReader.ReadToEnd());\n                jsonFileReader.Close();\n            }\n\n            return languageListDocument;\n        }\n\n        /// <summary>\n        /// Converts a file extension to a language monaco id.\n        /// </summary>\n        /// <param name=\"fileExtension\">The extension of the file (without the dot).</param>\n        /// <returns>The monaco language id</returns>\n        public static string GetLanguage(string fileExtension)\n        {\n            fileExtension = fileExtension.ToLower(CultureInfo.CurrentCulture);\n            try\n            {\n                JsonDocument languageListDocument = GetLanguages();\n                JsonElement languageList = languageListDocument.RootElement.GetProperty(\"list\");\n                foreach (JsonElement e in languageList.EnumerateArray())\n                {\n                    if (e.TryGetProperty(\"extensions\", out var extensions))\n                    {\n                        for (int j = 0; j < extensions.GetArrayLength(); j++)\n                        {\n                            if (extensions[j].ToString() == fileExtension)\n                            {\n                                return e.GetProperty(\"id\").ToString();\n                            }\n                        }\n                    }\n                }\n\n                return \"plaintext\";\n            }\n            catch (Exception)\n            {\n                return \"plaintext\";\n            }\n        }\n\n        public static string ReadIndexHtml()\n        {\n            string html;\n\n            using (StreamReader htmlFileReader = new StreamReader(new FileStream(MonacoDirectory + \"\\\\index.html\", FileMode.Open, FileAccess.Read, FileShare.ReadWrite)))\n            {\n                html = htmlFileReader.ReadToEnd();\n                htmlFileReader.Close();\n            }\n\n            return html;\n        }\n    }\n}\n",
    "patterns": [
      "Uses Generics",
      "Uses Lambda Expressions",
      "Uses Pattern Matching",
      "Uses Expression Bodies"
    ],
    "timestamp": "2025-06-24T22:15:36.318683",
    "quality_score": 0.9000000000000001,
    "training_prompts": [
      {
        "instruction": "JsonDocument 반환 타입의 GetLanguages 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Text.Json;\nusing Microsoft.PowerToys.FilePreviewCommon.Monaco.Formatters;\n\nnamespace Microsoft.PowerToys.FilePreviewCommon\n{\n    public static class MonacoHelper\n    {\n        /// <summary>\n        /// Name of the virtual host\n        /// </summary>\n        public const string VirtualHostName = \"PowerToysLocalMonaco\";\n\n        /// <summary>\n        /// Formatters applied before rendering the preview\n        /// </summary>\n        public static readonly IReadOnlyCollection<IFormatter> Formatters = new List<IFormatter>\n        {\n            new JsonFormatter(),\n            new XmlFormatter(),\n        }.AsReadOnly();\n\n        private static readonly Lazy<string> _monacoDirectory = new(GetRuntimeMonacoDirectory);\n\n        /// <summary>\n        /// Gets the path of the Monaco assets folder.\n        /// </summary>\n        public static string MonacoDirectory => _monacoDirectory.Value;\n\n        private static string GetRuntimeMonacoDirectory()\n        {\n            string baseDirectory = AppContext.BaseDirectory ?? string.Empty;\n\n            // AppContext.BaseDirectory returns a stray \\\\ so we want to remove that.\n            baseDirectory = Path.TrimEndingDirectorySeparator(baseDirectory);\n\n            // If the executable is within \"WinUI3Apps\", correct the path first.\n            // The idea of GetFileName here is getting the last directory in the path.\n            if (Path.GetFileName(baseDirectory) == \"WinUI3Apps\")\n            {\n                baseDirectory = Path.Combine(baseDirectory, \"..\");\n            }\n\n            string monacoPath = Path.Combine(baseDirectory, \"Assets\", \"Monaco\");\n\n            return Directory.Exists(monacoPath) ?\n                monacoPath :\n                throw new DirectoryNotFoundException($\"Monaco assets directory not found at {monacoPath}\");\n        }\n\n        public static JsonDocument GetLanguages()\n        {\n            JsonDocument languageListDocument;\n            using (StreamReader jsonFileReader = new StreamReader(new FileStream(MonacoDirectory + \"\\\\monaco_languages.json\", FileMode.Open, FileAccess.Read, FileShare.ReadWrite)))\n            {\n                languageListDocument = JsonDocument.Parse(jsonFileReader.ReadToEnd());\n                jsonFileReader.Close();\n            }\n\n            return languageListDocument;\n        }\n\n        /// <summary>\n        /// Converts a file extension to a language monaco id.\n        /// </summary>\n        /// <param name=\"fileExtension\">The extension of the file (without the dot).</param>\n        /// <returns>The monaco language id</returns>\n        public static string GetLanguage(string fileExtension)\n        {\n            fileExtension = fileExtension.ToLower(CultureInfo.CurrentCulture);\n            try\n            {\n                JsonDocument languageListDocument = GetLanguages();\n                JsonElement languageList = languageListDocument.RootElement.GetProperty(\"list\");\n                foreach (JsonElement e in languageList.EnumerateArray())\n                {\n                    if (e.TryGetProperty(\"extensions\", out var extensions))\n                    {\n                        for (int j = 0; j < extensions.GetArrayLength(); j++)\n                        {\n                            if (extensions[j].ToString() == fileExtension)\n                            {\n                                return e.GetProperty(\"id\").ToString();\n                            }\n                        }\n                    }\n                }\n\n                return \"plaintext\";\n            }\n            catch (Exception)\n            {\n                return \"plaintext\";\n            }\n        }\n\n        public static string ReadIndexHtml()\n        {\n            string html;\n\n            using (StreamReader htmlFileReader = new StreamReader(new FileStream(MonacoDirectory + \"\\\\index.html\", FileMode.Open, FileAccess.Read, FileShare.ReadWrite)))\n            {\n                html = htmlFileReader.ReadToEnd();\n                htmlFileReader.Close();\n            }\n\n            return html;\n        }\n    }\n}\n"
      },
      {
        "instruction": "string 반환 타입의 GetLanguage 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Text.Json;\nusing Microsoft.PowerToys.FilePreviewCommon.Monaco.Formatters;\n\nnamespace Microsoft.PowerToys.FilePreviewCommon\n{\n    public static class MonacoHelper\n    {\n        /// <summary>\n        /// Name of the virtual host\n        /// </summary>\n        public const string VirtualHostName = \"PowerToysLocalMonaco\";\n\n        /// <summary>\n        /// Formatters applied before rendering the preview\n        /// </summary>\n        public static readonly IReadOnlyCollection<IFormatter> Formatters = new List<IFormatter>\n        {\n            new JsonFormatter(),\n            new XmlFormatter(),\n        }.AsReadOnly();\n\n        private static readonly Lazy<string> _monacoDirectory = new(GetRuntimeMonacoDirectory);\n\n        /// <summary>\n        /// Gets the path of the Monaco assets folder.\n        /// </summary>\n        public static string MonacoDirectory => _monacoDirectory.Value;\n\n        private static string GetRuntimeMonacoDirectory()\n        {\n            string baseDirectory = AppContext.BaseDirectory ?? string.Empty;\n\n            // AppContext.BaseDirectory returns a stray \\\\ so we want to remove that.\n            baseDirectory = Path.TrimEndingDirectorySeparator(baseDirectory);\n\n            // If the executable is within \"WinUI3Apps\", correct the path first.\n            // The idea of GetFileName here is getting the last directory in the path.\n            if (Path.GetFileName(baseDirectory) == \"WinUI3Apps\")\n            {\n                baseDirectory = Path.Combine(baseDirectory, \"..\");\n            }\n\n            string monacoPath = Path.Combine(baseDirectory, \"Assets\", \"Monaco\");\n\n            return Directory.Exists(monacoPath) ?\n                monacoPath :\n                throw new DirectoryNotFoundException($\"Monaco assets directory not found at {monacoPath}\");\n        }\n\n        public static JsonDocument GetLanguages()\n        {\n            JsonDocument languageListDocument;\n            using (StreamReader jsonFileReader = new StreamReader(new FileStream(MonacoDirectory + \"\\\\monaco_languages.json\", FileMode.Open, FileAccess.Read, FileShare.ReadWrite)))\n            {\n                languageListDocument = JsonDocument.Parse(jsonFileReader.ReadToEnd());\n                jsonFileReader.Close();\n            }\n\n            return languageListDocument;\n        }\n\n        /// <summary>\n        /// Converts a file extension to a language monaco id.\n        /// </summary>\n        /// <param name=\"fileExtension\">The extension of the file (without the dot).</param>\n        /// <returns>The monaco language id</returns>\n        public static string GetLanguage(string fileExtension)\n        {\n            fileExtension = fileExtension.ToLower(CultureInfo.CurrentCulture);\n            try\n            {\n                JsonDocument languageListDocument = GetLanguages();\n                JsonElement languageList = languageListDocument.RootElement.GetProperty(\"list\");\n                foreach (JsonElement e in languageList.EnumerateArray())\n                {\n                    if (e.TryGetProperty(\"extensions\", out var extensions))\n                    {\n                        for (int j = 0; j < extensions.GetArrayLength(); j++)\n                        {\n                            if (extensions[j].ToString() == fileExtension)\n                            {\n                                return e.GetProperty(\"id\").ToString();\n                            }\n                        }\n                    }\n                }\n\n                return \"plaintext\";\n            }\n            catch (Exception)\n            {\n                return \"plaintext\";\n            }\n        }\n\n        public static string ReadIndexHtml()\n        {\n            string html;\n\n            using (StreamReader htmlFileReader = new StreamReader(new FileStream(MonacoDirectory + \"\\\\index.html\", FileMode.Open, FileAccess.Read, FileShare.ReadWrite)))\n            {\n                html = htmlFileReader.ReadToEnd();\n                htmlFileReader.Close();\n            }\n\n            return html;\n        }\n    }\n}\n"
      },
      {
        "instruction": "string 반환 타입의 ReadIndexHtml 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Text.Json;\nusing Microsoft.PowerToys.FilePreviewCommon.Monaco.Formatters;\n\nnamespace Microsoft.PowerToys.FilePreviewCommon\n{\n    public static class MonacoHelper\n    {\n        /// <summary>\n        /// Name of the virtual host\n        /// </summary>\n        public const string VirtualHostName = \"PowerToysLocalMonaco\";\n\n        /// <summary>\n        /// Formatters applied before rendering the preview\n        /// </summary>\n        public static readonly IReadOnlyCollection<IFormatter> Formatters = new List<IFormatter>\n        {\n            new JsonFormatter(),\n            new XmlFormatter(),\n        }.AsReadOnly();\n\n        private static readonly Lazy<string> _monacoDirectory = new(GetRuntimeMonacoDirectory);\n\n        /// <summary>\n        /// Gets the path of the Monaco assets folder.\n        /// </summary>\n        public static string MonacoDirectory => _monacoDirectory.Value;\n\n        private static string GetRuntimeMonacoDirectory()\n        {\n            string baseDirectory = AppContext.BaseDirectory ?? string.Empty;\n\n            // AppContext.BaseDirectory returns a stray \\\\ so we want to remove that.\n            baseDirectory = Path.TrimEndingDirectorySeparator(baseDirectory);\n\n            // If the executable is within \"WinUI3Apps\", correct the path first.\n            // The idea of GetFileName here is getting the last directory in the path.\n            if (Path.GetFileName(baseDirectory) == \"WinUI3Apps\")\n            {\n                baseDirectory = Path.Combine(baseDirectory, \"..\");\n            }\n\n            string monacoPath = Path.Combine(baseDirectory, \"Assets\", \"Monaco\");\n\n            return Directory.Exists(monacoPath) ?\n                monacoPath :\n                throw new DirectoryNotFoundException($\"Monaco assets directory not found at {monacoPath}\");\n        }\n\n        public static JsonDocument GetLanguages()\n        {\n            JsonDocument languageListDocument;\n            using (StreamReader jsonFileReader = new StreamReader(new FileStream(MonacoDirectory + \"\\\\monaco_languages.json\", FileMode.Open, FileAccess.Read, FileShare.ReadWrite)))\n            {\n                languageListDocument = JsonDocument.Parse(jsonFileReader.ReadToEnd());\n                jsonFileReader.Close();\n            }\n\n            return languageListDocument;\n        }\n\n        /// <summary>\n        /// Converts a file extension to a language monaco id.\n        /// </summary>\n        /// <param name=\"fileExtension\">The extension of the file (without the dot).</param>\n        /// <returns>The monaco language id</returns>\n        public static string GetLanguage(string fileExtension)\n        {\n            fileExtension = fileExtension.ToLower(CultureInfo.CurrentCulture);\n            try\n            {\n                JsonDocument languageListDocument = GetLanguages();\n                JsonElement languageList = languageListDocument.RootElement.GetProperty(\"list\");\n                foreach (JsonElement e in languageList.EnumerateArray())\n                {\n                    if (e.TryGetProperty(\"extensions\", out var extensions))\n                    {\n                        for (int j = 0; j < extensions.GetArrayLength(); j++)\n                        {\n                            if (extensions[j].ToString() == fileExtension)\n                            {\n                                return e.GetProperty(\"id\").ToString();\n                            }\n                        }\n                    }\n                }\n\n                return \"plaintext\";\n            }\n            catch (Exception)\n            {\n                return \"plaintext\";\n            }\n        }\n\n        public static string ReadIndexHtml()\n        {\n            string html;\n\n            using (StreamReader htmlFileReader = new StreamReader(new FileStream(MonacoDirectory + \"\\\\index.html\", FileMode.Open, FileAccess.Read, FileShare.ReadWrite)))\n            {\n                html = htmlFileReader.ReadToEnd();\n                htmlFileReader.Close();\n            }\n\n            return html;\n        }\n    }\n}\n"
      },
      {
        "instruction": "Uses Generics 패턴을 사용하는 C# 코드를 작성해주세요.",
        "context": "프로덕션 환경에서 사용 가능한 수준으로 작성해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Text.Json;\nusing Microsoft.PowerToys.FilePreviewCommon.Monaco.Formatters;\n\nnamespace Microsoft.PowerToys.FilePreviewCommon\n{\n    public static class MonacoHelper\n    {\n        /// <summary>\n        /// Name of the virtual host\n        /// </summary>\n        public const string VirtualHostName = \"PowerToysLocalMonaco\";\n\n        /// <summary>\n        /// Formatters applied before rendering the preview\n        /// </summary>\n        public static readonly IReadOnlyCollection<IFormatter> Formatters = new List<IFormatter>\n        {\n            new JsonFormatter(),\n            new XmlFormatter(),\n        }.AsReadOnly();\n\n        private static readonly Lazy<string> _monacoDirectory = new(GetRuntimeMonacoDirectory);\n\n        /// <summary>\n        /// Gets the path of the Monaco assets folder.\n        /// </summary>\n        public static string MonacoDirectory => _monacoDirectory.Value;\n\n        private static string GetRuntimeMonacoDirectory()\n        {\n            string baseDirectory = AppContext.BaseDirectory ?? string.Empty;\n\n            // AppContext.BaseDirectory returns a stray \\\\ so we want to remove that.\n            baseDirectory = Path.TrimEndingDirectorySeparator(baseDirectory);\n\n            // If the executable is within \"WinUI3Apps\", correct the path first.\n            // The idea of GetFileName here is getting the last directory in the path.\n            if (Path.GetFileName(baseDirectory) == \"WinUI3Apps\")\n            {\n                baseDirectory = Path.Combine(baseDirectory, \"..\");\n            }\n\n            string monacoPath = Path.Combine(baseDirectory, \"Assets\", \"Monaco\");\n\n            return Directory.Exists(monacoPath) ?\n                monacoPath :\n                throw new DirectoryNotFoundException($\"Monaco assets directory not found at {monacoPath}\");\n        }\n\n        public static JsonDocument GetLanguages()\n        {\n            JsonDocument languageListDocument;\n            using (StreamReader jsonFileReader = new StreamReader(new FileStream(MonacoDirectory + \"\\\\monaco_languages.json\", FileMode.Open, FileAccess.Read, FileShare.ReadWrite)))\n            {\n                languageListDocument = JsonDocument.Parse(jsonFileReader.ReadToEnd());\n                jsonFileReader.Close();\n            }\n\n            return languageListDocument;\n        }\n\n        /// <summary>\n        /// Converts a file extension to a language monaco id.\n        /// </summary>\n        /// <param name=\"fileExtension\">The extension of the file (without the dot).</param>\n        /// <returns>The monaco language id</returns>\n        public static string GetLanguage(string fileExtension)\n        {\n            fileExtension = fileExtension.ToLower(CultureInfo.CurrentCulture);\n            try\n            {\n                JsonDocument languageListDocument = GetLanguages();\n                JsonElement languageList = languageListDocument.RootElement.GetProperty(\"list\");\n                foreach (JsonElement e in languageList.EnumerateArray())\n                {\n                    if (e.TryGetProperty(\"extensions\", out var extensions))\n                    {\n                        for (int j = 0; j < extensions.GetArrayLength(); j++)\n                        {\n                            if (extensions[j].ToString() == fileExtension)\n                            {\n                                return e.GetProperty(\"id\").ToString();\n                            }\n                        }\n                    }\n                }\n\n                return \"plaintext\";\n            }\n            catch (Exception)\n            {\n                return \"plaintext\";\n            }\n        }\n\n        public static string ReadIndexHtml()\n        {\n            string html;\n\n            using (StreamReader htmlFileReader = new StreamReader(new FileStream(MonacoDirectory + \"\\\\index.html\", FileMode.Open, FileAccess.Read, FileShare.ReadWrite)))\n            {\n                html = htmlFileReader.ReadToEnd();\n                htmlFileReader.Close();\n            }\n\n            return html;\n        }\n    }\n}\n"
      }
    ]
  },
  {
    "id": "fdabede9e5ad90b3cba79eeb1b8a3b3c",
    "source": "github",
    "file_path": "src/common/UITestAutomation/KeyboardHelper.cs",
    "repository": "",
    "code": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// Represents keyboard keys.\n    /// </summary>\n    public enum Key\n    {\n        Ctrl,\n        LCtrl,\n        RCtrl,\n        Alt,\n        Shift,\n        Tab,\n        Esc,\n        Enter,\n        Win,\n        A,\n        B,\n        C,\n        D,\n        E,\n        F,\n        G,\n        H,\n        I,\n        J,\n        K,\n        L,\n        M,\n        N,\n        O,\n        P,\n        Q,\n        R,\n        S,\n        T,\n        U,\n        V,\n        W,\n        X,\n        Y,\n        Z,\n        Num0,\n        Num1,\n        Num2,\n        Num3,\n        Num4,\n        Num5,\n        Num6,\n        Num7,\n        Num8,\n        Num9,\n        F1,\n        F2,\n        F3,\n        F4,\n        F5,\n        F6,\n        F7,\n        F8,\n        F9,\n        F10,\n        F11,\n        F12,\n        Space,\n        Backspace,\n        Delete,\n        Insert,\n        Home,\n        End,\n        PageUp,\n        PageDown,\n        Up,\n        Down,\n        Left,\n        Right,\n        Other,\n    }\n\n    /// <summary>\n    /// Provides methods for simulating keyboard input.\n    /// </summary>\n    internal static class KeyboardHelper\n    {\n        [DllImport(\"user32.dll\")]\n#pragma warning disable SA1300 // Element should begin with upper-case letter\n        private static extern void keybd_event(byte bVk, byte bScan, uint dwFlags, UIntPtr dwExtraInfo);\n#pragma warning restore SA1300 // Element should begin with upper-case letter\n\n#pragma warning disable SA1310 // Field names should not contain underscore\n        private const byte VK_LWIN = 0x5B;\n        private const uint KEYEVENTF_KEYDOWN = 0x0000;\n        private const uint KEYEVENTF_KEYUP = 0x0002;\n#pragma warning restore SA1310 // Field names should not contain underscore\n\n        /// <summary>\n        /// Sends a combination of keys.\n        /// </summary>\n        /// <param name=\"keys\">The keys to send.</param>\n        public static void SendKeys(params Key[] keys)\n        {\n            string keysToSend = string.Join(string.Empty, keys.Select(TranslateKey));\n            SendWinKeyCombination(keysToSend);\n        }\n\n        public static void PressKey(Key key)\n        {\n            PressVirtualKey(TranslateKeyHex(key));\n        }\n\n        public static void ReleaseKey(Key key)\n        {\n            ReleaseVirtualKey(TranslateKeyHex(key));\n        }\n\n        public static void SendKey(Key key)\n        {\n            PressVirtualKey(TranslateKeyHex(key));\n            ReleaseVirtualKey(TranslateKeyHex(key));\n        }\n\n        /// <summary>\n        /// Translates a key to its corresponding SendKeys representation.\n        /// </summary>\n        /// <param name=\"key\">The key to translate.</param>\n        /// <returns>The SendKeys representation of the key.</returns>\n        private static string TranslateKey(Key key)\n        {\n            switch (key)\n            {\n                case Key.Ctrl:\n                    return \"^\";\n                case Key.LCtrl:\n                    return \"^\";\n                case Key.RCtrl:\n                    return \"^\";\n                case Key.Alt:\n                    return \"%\";\n                case Key.Shift:\n                    return \"+\";\n                case Key.Tab:\n                    return \"{TAB}\";\n                case Key.Esc:\n                    return \"{ESC}\";\n                case Key.Enter:\n                    return \"{ENTER}\";\n                case Key.Win:\n                    return \"{WIN}\";\n                case Key.Space:\n                    return \" \";\n                case Key.Backspace:\n                    return \"{BACKSPACE}\";\n                case Key.Delete:\n                    return \"{DELETE}\";\n                case Key.Insert:\n                    return \"{INSERT}\";\n                case Key.Home:\n                    return \"{HOME}\";\n                case Key.End:\n                    return \"{END}\";\n                case Key.PageUp:\n                    return \"{PGUP}\";\n                case Key.PageDown:\n                    return \"{PGDN}\";\n                case Key.Up:\n                    return \"{UP}\";\n                case Key.Down:\n                    return \"{DOWN}\";\n                case Key.Left:\n                    return \"{LEFT}\";\n                case Key.Right:\n                    return \"{RIGHT}\";\n                case Key.F1:\n                    return \"{F1}\";\n                case Key.F2:\n                    return \"{F2}\";\n                case Key.F3:\n                    return \"{F3}\";\n                case Key.F4:\n                    return \"{F4}\";\n                case Key.F5:\n                    return \"{F5}\";\n                case Key.F6:\n                    return \"{F6}\";\n                case Key.F7:\n                    return \"{F7}\";\n                case Key.F8:\n                    return \"{F8}\";\n                case Key.F9:\n                    return \"{F9}\";\n                case Key.F10:\n                    return \"{F10}\";\n                case Key.F11:\n                    return \"{F11}\";\n                case Key.F12:\n                    return \"{F12}\";\n                case Key.A:\n                    return \"a\";\n                case Key.B:\n                    return \"b\";\n                case Key.C:\n                    return \"c\";\n                case Key.D:\n                    return \"d\";\n                case Key.E:\n                    return \"e\";\n                case Key.F:\n                    return \"f\";\n                case Key.G:\n                    return \"g\";\n                case Key.H:\n                    return \"h\";\n                case Key.I:\n                    return \"i\";\n                case Key.J:\n                    return \"j\";\n                case Key.K:\n                    return \"k\";\n                case Key.L:\n                    return \"l\";\n                case Key.M:\n                    return \"m\";\n                case Key.N:\n                    return \"n\";\n                case Key.O:\n                    return \"o\";\n                case Key.P:\n                    return \"p\";\n                case Key.Q:\n                    return \"q\";\n                case Key.R:\n                    return \"r\";\n                case Key.S:\n                    return \"s\";\n                case Key.T:\n                    return \"t\";\n                case Key.U:\n                    return \"u\";\n                case Key.V:\n                    return \"v\";\n                case Key.W:\n                    return \"w\";\n                case Key.X:\n                    return \"x\";\n                case Key.Y:\n                    return \"y\";\n                case Key.Z:\n                    return \"z\";\n                case Key.Num0:\n                    return \"0\";\n                case Key.Num1:\n                    return \"1\";\n                case Key.Num2:\n                    return \"2\";\n                case Key.Num3:\n                    return \"3\";\n                case Key.Num4:\n                    return \"4\";\n                case Key.Num5:\n                    return \"5\";\n                case Key.Num6:\n                    return \"6\";\n                case Key.Num7:\n                    return \"7\";\n                case Key.Num8:\n                    return \"8\";\n                case Key.Num9:\n                    return \"9\";\n                default:\n                    return string.Empty;\n            }\n        }\n\n        /// <summary>\n        /// map the virtual key codes to the corresponding keys.\n        /// </summary>\n        private static byte TranslateKeyHex(Key key)\n        {\n            switch (key)\n            {\n                case Key.Win:\n                    return 0x5B;  // Windows Key - 0x5B in hex\n                case Key.Ctrl:\n                    return 0x11;  // Ctrl Key - 0x11 in hex\n                case Key.Alt:\n                    return 0x12;  // Alt Key - 0x12 in hex\n                case Key.Shift:\n                    return 0x10;  // Shift Key - 0x10 in hex\n                case Key.LCtrl:\n                    return 0xA2;  // Left Ctrl Key - 0xA2 in hex\n                case Key.RCtrl:\n                    return 0xA3;  // Right Ctrl Key - 0xA3 in hex\n                case Key.A:\n                    return 0x41;  // A Key - 0x41 in hex\n                case Key.B:\n                    return 0x42;  // B Key - 0x42 in hex\n                case Key.C:\n                    return 0x43;  // C Key - 0x43 in hex\n                case Key.D:\n                    return 0x44;  // D Key - 0x44 in hex\n                case Key.E:\n                    return 0x45;  // E Key - 0x45 in hex\n                case Key.F:\n                    return 0x46;  // F Key - 0x46 in hex\n                case Key.G:\n                    return 0x47;  // G Key - 0x47 in hex\n                case Key.H:\n                    return 0x48;  // H Key - 0x48 in hex\n                case Key.I:\n                    return 0x49;  // I Key - 0x49 in hex\n                case Key.J:\n                    return 0x4A;  // J Key - 0x4A in hex\n                case Key.K:\n                    return 0x4B;  // K Key - 0x4B in hex\n                case Key.L:\n                    return 0x4C;  // L Key - 0x4C in hex\n                case Key.M:\n                    return 0x4D;  // M Key - 0x4D in hex\n                case Key.N:\n                    return 0x4E;  // N Key - 0x4E in hex\n                case Key.O:\n                    return 0x4F;  // O Key - 0x4F in hex\n                case Key.P:\n                    return 0x50;  // P Key - 0x50 in hex\n                case Key.Q:\n                    return 0x51;  // Q Key - 0x51 in hex\n                case Key.R:\n                    return 0x52;  // R Key - 0x52 in hex\n                case Key.S:\n                    return 0x53;  // S Key - 0x53 in hex\n                case Key.T:\n                    return 0x54;  // T Key - 0x54 in hex\n                case Key.U:\n                    return 0x55;  // U Key - 0x55 in hex\n                case Key.V:\n                    return 0x56;  // V Key - 0x56 in hex\n                case Key.W:\n                    return 0x57;  // W Key - 0x57 in hex\n                case Key.X:\n                    return 0x58;  // X Key - 0x58 in hex\n                case Key.Y:\n                    return 0x59;  // Y Key - 0x59 in hex\n                case Key.Z:\n                    return 0x5A;  // Z Key - 0x5A in hex\n                case Key.Num0:\n                    return 0x30;  // 0 Key - 0x30 in hex\n                case Key.Num1:\n                    return 0x31;  // 1 Key - 0x31 in hex\n                case Key.Num2:\n                    return 0x32;  // 2 Key - 0x32 in hex\n                case Key.Num3:\n                    return 0x33;  // 3 Key - 0x33 in hex\n                case Key.Num4:\n                    return 0x34;  // 4 Key - 0x34 in hex\n                case Key.Num5:\n                    return 0x35;  // 5 Key - 0x35 in hex\n                case Key.Num6:\n                    return 0x36;  // 6 Key - 0x36 in hex\n                case Key.Num7:\n                    return 0x37;  // 7 Key - 0x37 in hex\n                case Key.Num8:\n                    return 0x38;  // 8 Key - 0x38 in hex\n                case Key.Num9:\n                    return 0x39;  // 9 Key - 0x39 in hex\n                case Key.F1:\n                    return 0x70;  // F1 Key - 0x70 in hex\n                case Key.F2:\n                    return 0x71;  // F2 Key - 0x71 in hex\n                case Key.F3:\n                    return 0x72;  // F3 Key - 0x72 in hex\n                case Key.F4:\n                    return 0x73;  // F4 Key - 0x73 in hex\n                case Key.F5:\n                    return 0x74;  // F5 Key - 0x74 in hex\n                case Key.F6:\n                    return 0x75;  // F6 Key - 0x75 in hex\n                case Key.F7:\n                    return 0x76;  // F7 Key - 0x76 in hex\n                case Key.F8:\n                    return 0x77;  // F8 Key - 0x77 in hex\n                case Key.F9:\n                    return 0x78;  // F9 Key - 0x78 in hex\n                case Key.F10:\n                    return 0x79;  // F10 Key - 0x79 in hex\n                case Key.F11:\n                    return 0x7A;  // F11 Key - 0x7A in hex\n                case Key.F12:\n                    return 0x7B;  // F12 Key - 0x7B in hex\n                case Key.Up:\n                    return 0x26;  // Up Arrow Key - 0x26 in hex\n                case Key.Down:\n                    return 0x28;  // Down Arrow Key - 0x28 in hex\n                case Key.Left:\n                    return 0x25;  // Left Arrow Key - 0x25 in hex\n                case Key.Right:\n                    return 0x27;  // Right Arrow Key - 0x27 in hex\n                case Key.Home:\n                    return 0x24;  // Home Key - 0x24 in hex\n                case Key.End:\n                    return 0x23;  // End Key - 0x23 in hex\n                case Key.PageUp:\n                    return 0x21;  // Page Up Key - 0x21 in hex\n                case Key.PageDown:\n                    return 0x22;  // Page Down Key - 0x22 in hex\n                case Key.Space:\n                    return 0x20;  // Space Key - 0x20 in hex\n                case Key.Enter:\n                    return 0x0D;  // Enter Key - 0x0D in hex\n                case Key.Backspace:\n                    return 0x08;  // Backspace Key - 0x08 in hex\n                case Key.Tab:\n                    return 0x09;  // Tab Key - 0x09 in hex\n                case Key.Esc:\n                    return 0x1B;  // Escape Key - 0x1B in hex\n                case Key.Insert:\n                    return 0x2D;  // Insert Key - 0x2D in hex\n                case Key.Delete:\n                    return 0x2E;  // Delete Key - 0x2E in hex\n                default:\n                    throw new ArgumentException($\"Key {key} is not supported, Please add your key at TranslateKeyHex for translation to hex.\");\n            }\n        }\n\n        /// <summary>\n        /// Sends a combination of keys, including the Windows key, to the system.\n        /// </summary>\n        /// <param name=\"keys\">The keys to send.</param>\n        private static void SendWinKeyCombination(string keys)\n        {\n            bool winKeyDown = false;\n\n            if (keys.Contains(\"{WIN}\"))\n            {\n                keybd_event(VK_LWIN, 0, KEYEVENTF_KEYDOWN, UIntPtr.Zero);\n                winKeyDown = true;\n                keys = keys.Replace(\"{WIN}\", string.Empty); // Remove {WIN} from the string\n            }\n\n            System.Windows.Forms.SendKeys.SendWait(keys);\n\n            // Release Windows key\n            if (winKeyDown)\n            {\n                keybd_event(VK_LWIN, 0, KEYEVENTF_KEYUP, UIntPtr.Zero);\n            }\n        }\n\n        /// <summary>\n        /// Just press the key.(no release)\n        /// </summary>\n        private static void PressVirtualKey(byte key)\n        {\n            keybd_event(key, 0, KEYEVENTF_KEYDOWN, UIntPtr.Zero);\n        }\n\n        /// <summary>\n        /// Release only the button (if pressed first)\n        /// </summary>\n        private static void ReleaseVirtualKey(byte key)\n        {\n            keybd_event(key, 0, KEYEVENTF_KEYUP, UIntPtr.Zero);\n        }\n    }\n}\n",
    "patterns": [
      "Service",
      "Uses LINQ",
      "Uses Generics",
      "Uses Pattern Matching"
    ],
    "timestamp": "2025-06-24T22:15:46.862141",
    "quality_score": 0.8000000000000002,
    "training_prompts": [
      {
        "instruction": "void 반환 타입의 SendKeys 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// Represents keyboard keys.\n    /// </summary>\n    public enum Key\n    {\n        Ctrl,\n        LCtrl,\n        RCtrl,\n        Alt,\n        Shift,\n        Tab,\n        Esc,\n        Enter,\n        Win,\n        A,\n        B,\n        C,\n        D,\n        E,\n        F,\n        G,\n        H,\n        I,\n        J,\n        K,\n        L,\n        M,\n        N,\n        O,\n        P,\n        Q,\n        R,\n        S,\n        T,\n        U,\n        V,\n        W,\n        X,\n        Y,\n        Z,\n        Num0,\n        Num1,\n        Num2,\n        Num3,\n        Num4,\n        Num5,\n        Num6,\n        Num7,\n        Num8,\n        Num9,\n        F1,\n        F2,\n        F3,\n        F4,\n        F5,\n        F6,\n        F7,\n        F8,\n        F9,\n        F10,\n        F11,\n        F12,\n        Space,\n        Backspace,\n        Delete,\n        Insert,\n        Home,\n        End,\n        PageUp,\n        PageDown,\n        Up,\n        Down,\n        Left,\n        Right,\n        Other,\n    }\n\n    /// <summary>\n    /// Provides methods for simulating keyboard input.\n    /// </summary>\n    internal static class KeyboardHelper\n    {\n        [DllImport(\"user32.dll\")]\n#pragma warning disable SA1300 // Element should begin with upper-case letter\n        private static extern void keybd_event(byte bVk, byte bScan, uint dwFlags, UIntPtr dwExtraInfo);\n#pragma warning restore SA1300 // Element should begin with upper-case letter\n\n#pragma warning disable SA1310 // Field names should not contain underscore\n        private const byte VK_LWIN = 0x5B;\n        private const uint KEYEVENTF_KEYDOWN = 0x0000;\n        private const uint KEYEVENTF_KEYUP = 0x0002;\n#pragma warning restore SA1310 // Field names should not contain underscore\n\n        /// <summary>\n        /// Sends a combination of keys.\n        /// </summary>\n        /// <param name=\"keys\">The keys to send.</param>\n        public static void SendKeys(params Key[] keys)\n        {\n            string keysToSend = string.Join(string.Empty, keys.Select(TranslateKey));\n            SendWinKeyCombination(keysToSend);\n        }\n\n        public static void PressKey(Key key)\n        {\n            PressVirtualKey(TranslateKeyHex(key));\n        }\n\n        public static void ReleaseKey(Key key)\n        {\n            ReleaseVirtualKey(TranslateKeyHex(key));\n        }\n\n        public static void SendKey(Key key)\n        {\n            PressVirtualKey(TranslateKeyHex(key));\n            ReleaseVirtualKey(TranslateKeyHex(key));\n        }\n\n        /// <summary>\n        /// Translates a key to its corresponding SendKeys representation.\n        /// </summary>\n        /// <param name=\"key\">The key to translate.</param>\n        /// <returns>The SendKeys representation of the key.</returns>\n        private static string TranslateKey(Key key)\n        {\n            switch (key)\n            {\n                case Key.Ctrl:\n                    return \"^\";\n                case Key.LCtrl:\n                    return \"^\";\n                case Key.RCtrl:\n                    return \"^\";\n                case Key.Alt:\n                    return \"%\";\n                case Key.Shift:\n                    return \"+\";\n                case Key.Tab:\n                    return \"{TAB}\";\n                case Key.Esc:\n                    return \"{ESC}\";\n                case Key.Enter:\n                    return \"{ENTER}\";\n                case Key.Win:\n                    return \"{WIN}\";\n                case Key.Space:\n                    return \" \";\n                case Key.Backspace:\n                    return \"{BACKSPACE}\";\n                case Key.Delete:\n                    return \"{DELETE}\";\n                case Key.Insert:\n                    return \"{INSERT}\";\n                case Key.Home:\n                    return \"{HOME}\";\n                case Key.End:\n                    return \"{END}\";\n                case Key.PageUp:\n                    return \"{PGUP}\";\n                case Key.PageDown:\n                    return \"{PGDN}\";\n                case Key.Up:\n                    return \"{UP}\";\n                case Key.Down:\n                    return \"{DOWN}\";\n                case Key.Left:\n                    return \"{LEFT}\";\n                case Key.Right:\n                    return \"{RIGHT}\";\n                case Key.F1:\n                    return \"{F1}\";\n                case Key.F2:\n                    return \"{F2}\";\n                case Key.F3:\n                    return \"{F3}\";\n                case Key.F4:\n                    return \"{F4}\";\n                case Key.F5:\n                    return \"{F5}\";\n                case Key.F6:\n                    return \"{F6}\";\n                case Key.F7:\n                    return \"{F7}\";\n                case Key.F8:\n                    return \"{F8}\";\n                case Key.F9:\n                    return \"{F9}\";\n                case Key.F10:\n                    return \"{F10}\";\n                case Key.F11:\n                    return \"{F11}\";\n                case Key.F12:\n                    return \"{F12}\";\n                case Key.A:\n                    return \"a\";\n                case Key.B:\n                    return \"b\";\n                case Key.C:\n                    return \"c\";\n                case Key.D:\n                    return \"d\";\n                case Key.E:\n                    return \"e\";\n                case Key.F:\n                    return \"f\";\n                case Key.G:\n                    return \"g\";\n                case Key.H:\n                    return \"h\";\n                case Key.I:\n                    return \"i\";\n                case Key.J:\n                    return \"j\";\n                case Key.K:\n                    return \"k\";\n                case Key.L:\n                    return \"l\";\n                case Key.M:\n                    return \"m\";\n                case Key.N:\n                    return \"n\";\n                case Key.O:\n                    return \"o\";\n                case Key.P:\n                    return \"p\";\n                case Key.Q:\n                    return \"q\";\n                case Key.R:\n                    return \"r\";\n                case Key.S:\n                    return \"s\";\n                case Key.T:\n                    return \"t\";\n                case Key.U:\n                    return \"u\";\n                case Key.V:\n                    return \"v\";\n                case Key.W:\n                    return \"w\";\n                case Key.X:\n                    return \"x\";\n                case Key.Y:\n                    return \"y\";\n                case Key.Z:\n                    return \"z\";\n                case Key.Num0:\n                    return \"0\";\n                case Key.Num1:\n                    return \"1\";\n                case Key.Num2:\n                    return \"2\";\n                case Key.Num3:\n                    return \"3\";\n                case Key.Num4:\n                    return \"4\";\n                case Key.Num5:\n                    return \"5\";\n                case Key.Num6:\n                    return \"6\";\n                case Key.Num7:\n                    return \"7\";\n                case Key.Num8:\n                    return \"8\";\n                case Key.Num9:\n                    return \"9\";\n                default:\n                    return string.Empty;\n            }\n        }\n\n        /// <summary>\n        /// map the virtual key codes to the corresponding keys.\n        /// </summary>\n        private static byte TranslateKeyHex(Key key)\n        {\n            switch (key)\n            {\n                case Key.Win:\n                    return 0x5B;  // Windows Key - 0x5B in hex\n                case Key.Ctrl:\n                    return 0x11;  // Ctrl Key - 0x11 in hex\n                case Key.Alt:\n                    return 0x12;  // Alt Key - 0x12 in hex\n                case Key.Shift:\n                    return 0x10;  // Shift Key - 0x10 in hex\n                case Key.LCtrl:\n                    return 0xA2;  // Left Ctrl Key - 0xA2 in hex\n                case Key.RCtrl:\n                    return 0xA3;  // Right Ctrl Key - 0xA3 in hex\n                case Key.A:\n                    return 0x41;  // A Key - 0x41 in hex\n                case Key.B:\n                    return 0x42;  // B Key - 0x42 in hex\n                case Key.C:\n                    return 0x43;  // C Key - 0x43 in hex\n                case Key.D:\n                    return 0x44;  // D Key - 0x44 in hex\n                case Key.E:\n                    return 0x45;  // E Key - 0x45 in hex\n                case Key.F:\n                    return 0x46;  // F Key - 0x46 in hex\n                case Key.G:\n                    return 0x47;  // G Key - 0x47 in hex\n                case Key.H:\n                    return 0x48;  // H Key - 0x48 in hex\n                case Key.I:\n                    return 0x49;  // I Key - 0x49 in hex\n                case Key.J:\n                    return 0x4A;  // J Key - 0x4A in hex\n                case Key.K:\n                    return 0x4B;  // K Key - 0x4B in hex\n                case Key.L:\n                    return 0x4C;  // L Key - 0x4C in hex\n                case Key.M:\n                    return 0x4D;  // M Key - 0x4D in hex\n                case Key.N:\n                    return 0x4E;  // N Key - 0x4E in hex\n                case Key.O:\n                    return 0x4F;  // O Key - 0x4F in hex\n                case Key.P:\n                    return 0x50;  // P Key - 0x50 in hex\n                case Key.Q:\n                    return 0x51;  // Q Key - 0x51 in hex\n                case Key.R:\n                    return 0x52;  // R Key - 0x52 in hex\n                case Key.S:\n                    return 0x53;  // S Key - 0x53 in hex\n                case Key.T:\n                    return 0x54;  // T Key - 0x54 in hex\n                case Key.U:\n                    return 0x55;  // U Key - 0x55 in hex\n                case Key.V:\n                    return 0x56;  // V Key - 0x56 in hex\n                case Key.W:\n                    return 0x57;  // W Key - 0x57 in hex\n                case Key.X:\n                    return 0x58;  // X Key - 0x58 in hex\n                case Key.Y:\n                    return 0x59;  // Y Key - 0x59 in hex\n                case Key.Z:\n                    return 0x5A;  // Z Key - 0x5A in hex\n                case Key.Num0:\n                    return 0x30;  // 0 Key - 0x30 in hex\n                case Key.Num1:\n                    return 0x31;  // 1 Key - 0x31 in hex\n                case Key.Num2:\n                    return 0x32;  // 2 Key - 0x32 in hex\n                case Key.Num3:\n                    return 0x33;  // 3 Key - 0x33 in hex\n                case Key.Num4:\n                    return 0x34;  // 4 Key - 0x34 in hex\n                case Key.Num5:\n                    return 0x35;  // 5 Key - 0x35 in hex\n                case Key.Num6:\n                    return 0x36;  // 6 Key - 0x36 in hex\n                case Key.Num7:\n                    return 0x37;  // 7 Key - 0x37 in hex\n                case Key.Num8:\n                    return 0x38;  // 8 Key - 0x38 in hex\n                case Key.Num9:\n                    return 0x39;  // 9 Key - 0x39 in hex\n                case Key.F1:\n                    return 0x70;  // F1 Key - 0x70 in hex\n                case Key.F2:\n                    return 0x71;  // F2 Key - 0x71 in hex\n                case Key.F3:\n                    return 0x72;  // F3 Key - 0x72 in hex\n                case Key.F4:\n                    return 0x73;  // F4 Key - 0x73 in hex\n                case Key.F5:\n                    return 0x74;  // F5 Key - 0x74 in hex\n                case Key.F6:\n                    return 0x75;  // F6 Key - 0x75 in hex\n                case Key.F7:\n                    return 0x76;  // F7 Key - 0x76 in hex\n                case Key.F8:\n                    return 0x77;  // F8 Key - 0x77 in hex\n                case Key.F9:\n                    return 0x78;  // F9 Key - 0x78 in hex\n                case Key.F10:\n                    return 0x79;  // F10 Key - 0x79 in hex\n                case Key.F11:\n                    return 0x7A;  // F11 Key - 0x7A in hex\n                case Key.F12:\n                    return 0x7B;  // F12 Key - 0x7B in hex\n                case Key.Up:\n                    return 0x26;  // Up Arrow Key - 0x26 in hex\n                case Key.Down:\n                    return 0x28;  // Down Arrow Key - 0x28 in hex\n                case Key.Left:\n                    return 0x25;  // Left Arrow Key - 0x25 in hex\n                case Key.Right:\n                    return 0x27;  // Right Arrow Key - 0x27 in hex\n                case Key.Home:\n                    return 0x24;  // Home Key - 0x24 in hex\n                case Key.End:\n                    return 0x23;  // End Key - 0x23 in hex\n                case Key.PageUp:\n                    return 0x21;  // Page Up Key - 0x21 in hex\n                case Key.PageDown:\n                    return 0x22;  // Page Down Key - 0x22 in hex\n                case Key.Space:\n                    return 0x20;  // Space Key - 0x20 in hex\n                case Key.Enter:\n                    return 0x0D;  // Enter Key - 0x0D in hex\n                case Key.Backspace:\n                    return 0x08;  // Backspace Key - 0x08 in hex\n                case Key.Tab:\n                    return 0x09;  // Tab Key - 0x09 in hex\n                case Key.Esc:\n                    return 0x1B;  // Escape Key - 0x1B in hex\n                case Key.Insert:\n                    return 0x2D;  // Insert Key - 0x2D in hex\n                case Key.Delete:\n                    return 0x2E;  // Delete Key - 0x2E in hex\n                default:\n                    throw new ArgumentException($\"Key {key} is not supported, Please add your key at TranslateKeyHex for translation to hex.\");\n            }\n        }\n\n        /// <summary>\n        /// Sends a combination of keys, including the Windows key, to the system.\n        /// </summary>\n        /// <param name=\"keys\">The keys to send.</param>\n        private static void SendWinKeyCombination(string keys)\n        {\n            bool winKeyDown = false;\n\n            if (keys.Contains(\"{WIN}\"))\n            {\n                keybd_event(VK_LWIN, 0, KEYEVENTF_KEYDOWN, UIntPtr.Zero);\n                winKeyDown = true;\n                keys = keys.Replace(\"{WIN}\", string.Empty); // Remove {WIN} from the string\n            }\n\n            System.Windows.Forms.SendKeys.SendWait(keys);\n\n            // Release Windows key\n            if (winKeyDown)\n            {\n                keybd_event(VK_LWIN, 0, KEYEVENTF_KEYUP, UIntPtr.Zero);\n            }\n        }\n\n        /// <summary>\n        /// Just press the key.(no release)\n        /// </summary>\n        private static void PressVirtualKey(byte key)\n        {\n            keybd_event(key, 0, KEYEVENTF_KEYDOWN, UIntPtr.Zero);\n        }\n\n        /// <summary>\n        /// Release only the button (if pressed first)\n        /// </summary>\n        private static void ReleaseVirtualKey(byte key)\n        {\n            keybd_event(key, 0, KEYEVENTF_KEYUP, UIntPtr.Zero);\n        }\n    }\n}\n"
      },
      {
        "instruction": "void 반환 타입의 PressKey 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// Represents keyboard keys.\n    /// </summary>\n    public enum Key\n    {\n        Ctrl,\n        LCtrl,\n        RCtrl,\n        Alt,\n        Shift,\n        Tab,\n        Esc,\n        Enter,\n        Win,\n        A,\n        B,\n        C,\n        D,\n        E,\n        F,\n        G,\n        H,\n        I,\n        J,\n        K,\n        L,\n        M,\n        N,\n        O,\n        P,\n        Q,\n        R,\n        S,\n        T,\n        U,\n        V,\n        W,\n        X,\n        Y,\n        Z,\n        Num0,\n        Num1,\n        Num2,\n        Num3,\n        Num4,\n        Num5,\n        Num6,\n        Num7,\n        Num8,\n        Num9,\n        F1,\n        F2,\n        F3,\n        F4,\n        F5,\n        F6,\n        F7,\n        F8,\n        F9,\n        F10,\n        F11,\n        F12,\n        Space,\n        Backspace,\n        Delete,\n        Insert,\n        Home,\n        End,\n        PageUp,\n        PageDown,\n        Up,\n        Down,\n        Left,\n        Right,\n        Other,\n    }\n\n    /// <summary>\n    /// Provides methods for simulating keyboard input.\n    /// </summary>\n    internal static class KeyboardHelper\n    {\n        [DllImport(\"user32.dll\")]\n#pragma warning disable SA1300 // Element should begin with upper-case letter\n        private static extern void keybd_event(byte bVk, byte bScan, uint dwFlags, UIntPtr dwExtraInfo);\n#pragma warning restore SA1300 // Element should begin with upper-case letter\n\n#pragma warning disable SA1310 // Field names should not contain underscore\n        private const byte VK_LWIN = 0x5B;\n        private const uint KEYEVENTF_KEYDOWN = 0x0000;\n        private const uint KEYEVENTF_KEYUP = 0x0002;\n#pragma warning restore SA1310 // Field names should not contain underscore\n\n        /// <summary>\n        /// Sends a combination of keys.\n        /// </summary>\n        /// <param name=\"keys\">The keys to send.</param>\n        public static void SendKeys(params Key[] keys)\n        {\n            string keysToSend = string.Join(string.Empty, keys.Select(TranslateKey));\n            SendWinKeyCombination(keysToSend);\n        }\n\n        public static void PressKey(Key key)\n        {\n            PressVirtualKey(TranslateKeyHex(key));\n        }\n\n        public static void ReleaseKey(Key key)\n        {\n            ReleaseVirtualKey(TranslateKeyHex(key));\n        }\n\n        public static void SendKey(Key key)\n        {\n            PressVirtualKey(TranslateKeyHex(key));\n            ReleaseVirtualKey(TranslateKeyHex(key));\n        }\n\n        /// <summary>\n        /// Translates a key to its corresponding SendKeys representation.\n        /// </summary>\n        /// <param name=\"key\">The key to translate.</param>\n        /// <returns>The SendKeys representation of the key.</returns>\n        private static string TranslateKey(Key key)\n        {\n            switch (key)\n            {\n                case Key.Ctrl:\n                    return \"^\";\n                case Key.LCtrl:\n                    return \"^\";\n                case Key.RCtrl:\n                    return \"^\";\n                case Key.Alt:\n                    return \"%\";\n                case Key.Shift:\n                    return \"+\";\n                case Key.Tab:\n                    return \"{TAB}\";\n                case Key.Esc:\n                    return \"{ESC}\";\n                case Key.Enter:\n                    return \"{ENTER}\";\n                case Key.Win:\n                    return \"{WIN}\";\n                case Key.Space:\n                    return \" \";\n                case Key.Backspace:\n                    return \"{BACKSPACE}\";\n                case Key.Delete:\n                    return \"{DELETE}\";\n                case Key.Insert:\n                    return \"{INSERT}\";\n                case Key.Home:\n                    return \"{HOME}\";\n                case Key.End:\n                    return \"{END}\";\n                case Key.PageUp:\n                    return \"{PGUP}\";\n                case Key.PageDown:\n                    return \"{PGDN}\";\n                case Key.Up:\n                    return \"{UP}\";\n                case Key.Down:\n                    return \"{DOWN}\";\n                case Key.Left:\n                    return \"{LEFT}\";\n                case Key.Right:\n                    return \"{RIGHT}\";\n                case Key.F1:\n                    return \"{F1}\";\n                case Key.F2:\n                    return \"{F2}\";\n                case Key.F3:\n                    return \"{F3}\";\n                case Key.F4:\n                    return \"{F4}\";\n                case Key.F5:\n                    return \"{F5}\";\n                case Key.F6:\n                    return \"{F6}\";\n                case Key.F7:\n                    return \"{F7}\";\n                case Key.F8:\n                    return \"{F8}\";\n                case Key.F9:\n                    return \"{F9}\";\n                case Key.F10:\n                    return \"{F10}\";\n                case Key.F11:\n                    return \"{F11}\";\n                case Key.F12:\n                    return \"{F12}\";\n                case Key.A:\n                    return \"a\";\n                case Key.B:\n                    return \"b\";\n                case Key.C:\n                    return \"c\";\n                case Key.D:\n                    return \"d\";\n                case Key.E:\n                    return \"e\";\n                case Key.F:\n                    return \"f\";\n                case Key.G:\n                    return \"g\";\n                case Key.H:\n                    return \"h\";\n                case Key.I:\n                    return \"i\";\n                case Key.J:\n                    return \"j\";\n                case Key.K:\n                    return \"k\";\n                case Key.L:\n                    return \"l\";\n                case Key.M:\n                    return \"m\";\n                case Key.N:\n                    return \"n\";\n                case Key.O:\n                    return \"o\";\n                case Key.P:\n                    return \"p\";\n                case Key.Q:\n                    return \"q\";\n                case Key.R:\n                    return \"r\";\n                case Key.S:\n                    return \"s\";\n                case Key.T:\n                    return \"t\";\n                case Key.U:\n                    return \"u\";\n                case Key.V:\n                    return \"v\";\n                case Key.W:\n                    return \"w\";\n                case Key.X:\n                    return \"x\";\n                case Key.Y:\n                    return \"y\";\n                case Key.Z:\n                    return \"z\";\n                case Key.Num0:\n                    return \"0\";\n                case Key.Num1:\n                    return \"1\";\n                case Key.Num2:\n                    return \"2\";\n                case Key.Num3:\n                    return \"3\";\n                case Key.Num4:\n                    return \"4\";\n                case Key.Num5:\n                    return \"5\";\n                case Key.Num6:\n                    return \"6\";\n                case Key.Num7:\n                    return \"7\";\n                case Key.Num8:\n                    return \"8\";\n                case Key.Num9:\n                    return \"9\";\n                default:\n                    return string.Empty;\n            }\n        }\n\n        /// <summary>\n        /// map the virtual key codes to the corresponding keys.\n        /// </summary>\n        private static byte TranslateKeyHex(Key key)\n        {\n            switch (key)\n            {\n                case Key.Win:\n                    return 0x5B;  // Windows Key - 0x5B in hex\n                case Key.Ctrl:\n                    return 0x11;  // Ctrl Key - 0x11 in hex\n                case Key.Alt:\n                    return 0x12;  // Alt Key - 0x12 in hex\n                case Key.Shift:\n                    return 0x10;  // Shift Key - 0x10 in hex\n                case Key.LCtrl:\n                    return 0xA2;  // Left Ctrl Key - 0xA2 in hex\n                case Key.RCtrl:\n                    return 0xA3;  // Right Ctrl Key - 0xA3 in hex\n                case Key.A:\n                    return 0x41;  // A Key - 0x41 in hex\n                case Key.B:\n                    return 0x42;  // B Key - 0x42 in hex\n                case Key.C:\n                    return 0x43;  // C Key - 0x43 in hex\n                case Key.D:\n                    return 0x44;  // D Key - 0x44 in hex\n                case Key.E:\n                    return 0x45;  // E Key - 0x45 in hex\n                case Key.F:\n                    return 0x46;  // F Key - 0x46 in hex\n                case Key.G:\n                    return 0x47;  // G Key - 0x47 in hex\n                case Key.H:\n                    return 0x48;  // H Key - 0x48 in hex\n                case Key.I:\n                    return 0x49;  // I Key - 0x49 in hex\n                case Key.J:\n                    return 0x4A;  // J Key - 0x4A in hex\n                case Key.K:\n                    return 0x4B;  // K Key - 0x4B in hex\n                case Key.L:\n                    return 0x4C;  // L Key - 0x4C in hex\n                case Key.M:\n                    return 0x4D;  // M Key - 0x4D in hex\n                case Key.N:\n                    return 0x4E;  // N Key - 0x4E in hex\n                case Key.O:\n                    return 0x4F;  // O Key - 0x4F in hex\n                case Key.P:\n                    return 0x50;  // P Key - 0x50 in hex\n                case Key.Q:\n                    return 0x51;  // Q Key - 0x51 in hex\n                case Key.R:\n                    return 0x52;  // R Key - 0x52 in hex\n                case Key.S:\n                    return 0x53;  // S Key - 0x53 in hex\n                case Key.T:\n                    return 0x54;  // T Key - 0x54 in hex\n                case Key.U:\n                    return 0x55;  // U Key - 0x55 in hex\n                case Key.V:\n                    return 0x56;  // V Key - 0x56 in hex\n                case Key.W:\n                    return 0x57;  // W Key - 0x57 in hex\n                case Key.X:\n                    return 0x58;  // X Key - 0x58 in hex\n                case Key.Y:\n                    return 0x59;  // Y Key - 0x59 in hex\n                case Key.Z:\n                    return 0x5A;  // Z Key - 0x5A in hex\n                case Key.Num0:\n                    return 0x30;  // 0 Key - 0x30 in hex\n                case Key.Num1:\n                    return 0x31;  // 1 Key - 0x31 in hex\n                case Key.Num2:\n                    return 0x32;  // 2 Key - 0x32 in hex\n                case Key.Num3:\n                    return 0x33;  // 3 Key - 0x33 in hex\n                case Key.Num4:\n                    return 0x34;  // 4 Key - 0x34 in hex\n                case Key.Num5:\n                    return 0x35;  // 5 Key - 0x35 in hex\n                case Key.Num6:\n                    return 0x36;  // 6 Key - 0x36 in hex\n                case Key.Num7:\n                    return 0x37;  // 7 Key - 0x37 in hex\n                case Key.Num8:\n                    return 0x38;  // 8 Key - 0x38 in hex\n                case Key.Num9:\n                    return 0x39;  // 9 Key - 0x39 in hex\n                case Key.F1:\n                    return 0x70;  // F1 Key - 0x70 in hex\n                case Key.F2:\n                    return 0x71;  // F2 Key - 0x71 in hex\n                case Key.F3:\n                    return 0x72;  // F3 Key - 0x72 in hex\n                case Key.F4:\n                    return 0x73;  // F4 Key - 0x73 in hex\n                case Key.F5:\n                    return 0x74;  // F5 Key - 0x74 in hex\n                case Key.F6:\n                    return 0x75;  // F6 Key - 0x75 in hex\n                case Key.F7:\n                    return 0x76;  // F7 Key - 0x76 in hex\n                case Key.F8:\n                    return 0x77;  // F8 Key - 0x77 in hex\n                case Key.F9:\n                    return 0x78;  // F9 Key - 0x78 in hex\n                case Key.F10:\n                    return 0x79;  // F10 Key - 0x79 in hex\n                case Key.F11:\n                    return 0x7A;  // F11 Key - 0x7A in hex\n                case Key.F12:\n                    return 0x7B;  // F12 Key - 0x7B in hex\n                case Key.Up:\n                    return 0x26;  // Up Arrow Key - 0x26 in hex\n                case Key.Down:\n                    return 0x28;  // Down Arrow Key - 0x28 in hex\n                case Key.Left:\n                    return 0x25;  // Left Arrow Key - 0x25 in hex\n                case Key.Right:\n                    return 0x27;  // Right Arrow Key - 0x27 in hex\n                case Key.Home:\n                    return 0x24;  // Home Key - 0x24 in hex\n                case Key.End:\n                    return 0x23;  // End Key - 0x23 in hex\n                case Key.PageUp:\n                    return 0x21;  // Page Up Key - 0x21 in hex\n                case Key.PageDown:\n                    return 0x22;  // Page Down Key - 0x22 in hex\n                case Key.Space:\n                    return 0x20;  // Space Key - 0x20 in hex\n                case Key.Enter:\n                    return 0x0D;  // Enter Key - 0x0D in hex\n                case Key.Backspace:\n                    return 0x08;  // Backspace Key - 0x08 in hex\n                case Key.Tab:\n                    return 0x09;  // Tab Key - 0x09 in hex\n                case Key.Esc:\n                    return 0x1B;  // Escape Key - 0x1B in hex\n                case Key.Insert:\n                    return 0x2D;  // Insert Key - 0x2D in hex\n                case Key.Delete:\n                    return 0x2E;  // Delete Key - 0x2E in hex\n                default:\n                    throw new ArgumentException($\"Key {key} is not supported, Please add your key at TranslateKeyHex for translation to hex.\");\n            }\n        }\n\n        /// <summary>\n        /// Sends a combination of keys, including the Windows key, to the system.\n        /// </summary>\n        /// <param name=\"keys\">The keys to send.</param>\n        private static void SendWinKeyCombination(string keys)\n        {\n            bool winKeyDown = false;\n\n            if (keys.Contains(\"{WIN}\"))\n            {\n                keybd_event(VK_LWIN, 0, KEYEVENTF_KEYDOWN, UIntPtr.Zero);\n                winKeyDown = true;\n                keys = keys.Replace(\"{WIN}\", string.Empty); // Remove {WIN} from the string\n            }\n\n            System.Windows.Forms.SendKeys.SendWait(keys);\n\n            // Release Windows key\n            if (winKeyDown)\n            {\n                keybd_event(VK_LWIN, 0, KEYEVENTF_KEYUP, UIntPtr.Zero);\n            }\n        }\n\n        /// <summary>\n        /// Just press the key.(no release)\n        /// </summary>\n        private static void PressVirtualKey(byte key)\n        {\n            keybd_event(key, 0, KEYEVENTF_KEYDOWN, UIntPtr.Zero);\n        }\n\n        /// <summary>\n        /// Release only the button (if pressed first)\n        /// </summary>\n        private static void ReleaseVirtualKey(byte key)\n        {\n            keybd_event(key, 0, KEYEVENTF_KEYUP, UIntPtr.Zero);\n        }\n    }\n}\n"
      },
      {
        "instruction": "void 반환 타입의 ReleaseKey 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// Represents keyboard keys.\n    /// </summary>\n    public enum Key\n    {\n        Ctrl,\n        LCtrl,\n        RCtrl,\n        Alt,\n        Shift,\n        Tab,\n        Esc,\n        Enter,\n        Win,\n        A,\n        B,\n        C,\n        D,\n        E,\n        F,\n        G,\n        H,\n        I,\n        J,\n        K,\n        L,\n        M,\n        N,\n        O,\n        P,\n        Q,\n        R,\n        S,\n        T,\n        U,\n        V,\n        W,\n        X,\n        Y,\n        Z,\n        Num0,\n        Num1,\n        Num2,\n        Num3,\n        Num4,\n        Num5,\n        Num6,\n        Num7,\n        Num8,\n        Num9,\n        F1,\n        F2,\n        F3,\n        F4,\n        F5,\n        F6,\n        F7,\n        F8,\n        F9,\n        F10,\n        F11,\n        F12,\n        Space,\n        Backspace,\n        Delete,\n        Insert,\n        Home,\n        End,\n        PageUp,\n        PageDown,\n        Up,\n        Down,\n        Left,\n        Right,\n        Other,\n    }\n\n    /// <summary>\n    /// Provides methods for simulating keyboard input.\n    /// </summary>\n    internal static class KeyboardHelper\n    {\n        [DllImport(\"user32.dll\")]\n#pragma warning disable SA1300 // Element should begin with upper-case letter\n        private static extern void keybd_event(byte bVk, byte bScan, uint dwFlags, UIntPtr dwExtraInfo);\n#pragma warning restore SA1300 // Element should begin with upper-case letter\n\n#pragma warning disable SA1310 // Field names should not contain underscore\n        private const byte VK_LWIN = 0x5B;\n        private const uint KEYEVENTF_KEYDOWN = 0x0000;\n        private const uint KEYEVENTF_KEYUP = 0x0002;\n#pragma warning restore SA1310 // Field names should not contain underscore\n\n        /// <summary>\n        /// Sends a combination of keys.\n        /// </summary>\n        /// <param name=\"keys\">The keys to send.</param>\n        public static void SendKeys(params Key[] keys)\n        {\n            string keysToSend = string.Join(string.Empty, keys.Select(TranslateKey));\n            SendWinKeyCombination(keysToSend);\n        }\n\n        public static void PressKey(Key key)\n        {\n            PressVirtualKey(TranslateKeyHex(key));\n        }\n\n        public static void ReleaseKey(Key key)\n        {\n            ReleaseVirtualKey(TranslateKeyHex(key));\n        }\n\n        public static void SendKey(Key key)\n        {\n            PressVirtualKey(TranslateKeyHex(key));\n            ReleaseVirtualKey(TranslateKeyHex(key));\n        }\n\n        /// <summary>\n        /// Translates a key to its corresponding SendKeys representation.\n        /// </summary>\n        /// <param name=\"key\">The key to translate.</param>\n        /// <returns>The SendKeys representation of the key.</returns>\n        private static string TranslateKey(Key key)\n        {\n            switch (key)\n            {\n                case Key.Ctrl:\n                    return \"^\";\n                case Key.LCtrl:\n                    return \"^\";\n                case Key.RCtrl:\n                    return \"^\";\n                case Key.Alt:\n                    return \"%\";\n                case Key.Shift:\n                    return \"+\";\n                case Key.Tab:\n                    return \"{TAB}\";\n                case Key.Esc:\n                    return \"{ESC}\";\n                case Key.Enter:\n                    return \"{ENTER}\";\n                case Key.Win:\n                    return \"{WIN}\";\n                case Key.Space:\n                    return \" \";\n                case Key.Backspace:\n                    return \"{BACKSPACE}\";\n                case Key.Delete:\n                    return \"{DELETE}\";\n                case Key.Insert:\n                    return \"{INSERT}\";\n                case Key.Home:\n                    return \"{HOME}\";\n                case Key.End:\n                    return \"{END}\";\n                case Key.PageUp:\n                    return \"{PGUP}\";\n                case Key.PageDown:\n                    return \"{PGDN}\";\n                case Key.Up:\n                    return \"{UP}\";\n                case Key.Down:\n                    return \"{DOWN}\";\n                case Key.Left:\n                    return \"{LEFT}\";\n                case Key.Right:\n                    return \"{RIGHT}\";\n                case Key.F1:\n                    return \"{F1}\";\n                case Key.F2:\n                    return \"{F2}\";\n                case Key.F3:\n                    return \"{F3}\";\n                case Key.F4:\n                    return \"{F4}\";\n                case Key.F5:\n                    return \"{F5}\";\n                case Key.F6:\n                    return \"{F6}\";\n                case Key.F7:\n                    return \"{F7}\";\n                case Key.F8:\n                    return \"{F8}\";\n                case Key.F9:\n                    return \"{F9}\";\n                case Key.F10:\n                    return \"{F10}\";\n                case Key.F11:\n                    return \"{F11}\";\n                case Key.F12:\n                    return \"{F12}\";\n                case Key.A:\n                    return \"a\";\n                case Key.B:\n                    return \"b\";\n                case Key.C:\n                    return \"c\";\n                case Key.D:\n                    return \"d\";\n                case Key.E:\n                    return \"e\";\n                case Key.F:\n                    return \"f\";\n                case Key.G:\n                    return \"g\";\n                case Key.H:\n                    return \"h\";\n                case Key.I:\n                    return \"i\";\n                case Key.J:\n                    return \"j\";\n                case Key.K:\n                    return \"k\";\n                case Key.L:\n                    return \"l\";\n                case Key.M:\n                    return \"m\";\n                case Key.N:\n                    return \"n\";\n                case Key.O:\n                    return \"o\";\n                case Key.P:\n                    return \"p\";\n                case Key.Q:\n                    return \"q\";\n                case Key.R:\n                    return \"r\";\n                case Key.S:\n                    return \"s\";\n                case Key.T:\n                    return \"t\";\n                case Key.U:\n                    return \"u\";\n                case Key.V:\n                    return \"v\";\n                case Key.W:\n                    return \"w\";\n                case Key.X:\n                    return \"x\";\n                case Key.Y:\n                    return \"y\";\n                case Key.Z:\n                    return \"z\";\n                case Key.Num0:\n                    return \"0\";\n                case Key.Num1:\n                    return \"1\";\n                case Key.Num2:\n                    return \"2\";\n                case Key.Num3:\n                    return \"3\";\n                case Key.Num4:\n                    return \"4\";\n                case Key.Num5:\n                    return \"5\";\n                case Key.Num6:\n                    return \"6\";\n                case Key.Num7:\n                    return \"7\";\n                case Key.Num8:\n                    return \"8\";\n                case Key.Num9:\n                    return \"9\";\n                default:\n                    return string.Empty;\n            }\n        }\n\n        /// <summary>\n        /// map the virtual key codes to the corresponding keys.\n        /// </summary>\n        private static byte TranslateKeyHex(Key key)\n        {\n            switch (key)\n            {\n                case Key.Win:\n                    return 0x5B;  // Windows Key - 0x5B in hex\n                case Key.Ctrl:\n                    return 0x11;  // Ctrl Key - 0x11 in hex\n                case Key.Alt:\n                    return 0x12;  // Alt Key - 0x12 in hex\n                case Key.Shift:\n                    return 0x10;  // Shift Key - 0x10 in hex\n                case Key.LCtrl:\n                    return 0xA2;  // Left Ctrl Key - 0xA2 in hex\n                case Key.RCtrl:\n                    return 0xA3;  // Right Ctrl Key - 0xA3 in hex\n                case Key.A:\n                    return 0x41;  // A Key - 0x41 in hex\n                case Key.B:\n                    return 0x42;  // B Key - 0x42 in hex\n                case Key.C:\n                    return 0x43;  // C Key - 0x43 in hex\n                case Key.D:\n                    return 0x44;  // D Key - 0x44 in hex\n                case Key.E:\n                    return 0x45;  // E Key - 0x45 in hex\n                case Key.F:\n                    return 0x46;  // F Key - 0x46 in hex\n                case Key.G:\n                    return 0x47;  // G Key - 0x47 in hex\n                case Key.H:\n                    return 0x48;  // H Key - 0x48 in hex\n                case Key.I:\n                    return 0x49;  // I Key - 0x49 in hex\n                case Key.J:\n                    return 0x4A;  // J Key - 0x4A in hex\n                case Key.K:\n                    return 0x4B;  // K Key - 0x4B in hex\n                case Key.L:\n                    return 0x4C;  // L Key - 0x4C in hex\n                case Key.M:\n                    return 0x4D;  // M Key - 0x4D in hex\n                case Key.N:\n                    return 0x4E;  // N Key - 0x4E in hex\n                case Key.O:\n                    return 0x4F;  // O Key - 0x4F in hex\n                case Key.P:\n                    return 0x50;  // P Key - 0x50 in hex\n                case Key.Q:\n                    return 0x51;  // Q Key - 0x51 in hex\n                case Key.R:\n                    return 0x52;  // R Key - 0x52 in hex\n                case Key.S:\n                    return 0x53;  // S Key - 0x53 in hex\n                case Key.T:\n                    return 0x54;  // T Key - 0x54 in hex\n                case Key.U:\n                    return 0x55;  // U Key - 0x55 in hex\n                case Key.V:\n                    return 0x56;  // V Key - 0x56 in hex\n                case Key.W:\n                    return 0x57;  // W Key - 0x57 in hex\n                case Key.X:\n                    return 0x58;  // X Key - 0x58 in hex\n                case Key.Y:\n                    return 0x59;  // Y Key - 0x59 in hex\n                case Key.Z:\n                    return 0x5A;  // Z Key - 0x5A in hex\n                case Key.Num0:\n                    return 0x30;  // 0 Key - 0x30 in hex\n                case Key.Num1:\n                    return 0x31;  // 1 Key - 0x31 in hex\n                case Key.Num2:\n                    return 0x32;  // 2 Key - 0x32 in hex\n                case Key.Num3:\n                    return 0x33;  // 3 Key - 0x33 in hex\n                case Key.Num4:\n                    return 0x34;  // 4 Key - 0x34 in hex\n                case Key.Num5:\n                    return 0x35;  // 5 Key - 0x35 in hex\n                case Key.Num6:\n                    return 0x36;  // 6 Key - 0x36 in hex\n                case Key.Num7:\n                    return 0x37;  // 7 Key - 0x37 in hex\n                case Key.Num8:\n                    return 0x38;  // 8 Key - 0x38 in hex\n                case Key.Num9:\n                    return 0x39;  // 9 Key - 0x39 in hex\n                case Key.F1:\n                    return 0x70;  // F1 Key - 0x70 in hex\n                case Key.F2:\n                    return 0x71;  // F2 Key - 0x71 in hex\n                case Key.F3:\n                    return 0x72;  // F3 Key - 0x72 in hex\n                case Key.F4:\n                    return 0x73;  // F4 Key - 0x73 in hex\n                case Key.F5:\n                    return 0x74;  // F5 Key - 0x74 in hex\n                case Key.F6:\n                    return 0x75;  // F6 Key - 0x75 in hex\n                case Key.F7:\n                    return 0x76;  // F7 Key - 0x76 in hex\n                case Key.F8:\n                    return 0x77;  // F8 Key - 0x77 in hex\n                case Key.F9:\n                    return 0x78;  // F9 Key - 0x78 in hex\n                case Key.F10:\n                    return 0x79;  // F10 Key - 0x79 in hex\n                case Key.F11:\n                    return 0x7A;  // F11 Key - 0x7A in hex\n                case Key.F12:\n                    return 0x7B;  // F12 Key - 0x7B in hex\n                case Key.Up:\n                    return 0x26;  // Up Arrow Key - 0x26 in hex\n                case Key.Down:\n                    return 0x28;  // Down Arrow Key - 0x28 in hex\n                case Key.Left:\n                    return 0x25;  // Left Arrow Key - 0x25 in hex\n                case Key.Right:\n                    return 0x27;  // Right Arrow Key - 0x27 in hex\n                case Key.Home:\n                    return 0x24;  // Home Key - 0x24 in hex\n                case Key.End:\n                    return 0x23;  // End Key - 0x23 in hex\n                case Key.PageUp:\n                    return 0x21;  // Page Up Key - 0x21 in hex\n                case Key.PageDown:\n                    return 0x22;  // Page Down Key - 0x22 in hex\n                case Key.Space:\n                    return 0x20;  // Space Key - 0x20 in hex\n                case Key.Enter:\n                    return 0x0D;  // Enter Key - 0x0D in hex\n                case Key.Backspace:\n                    return 0x08;  // Backspace Key - 0x08 in hex\n                case Key.Tab:\n                    return 0x09;  // Tab Key - 0x09 in hex\n                case Key.Esc:\n                    return 0x1B;  // Escape Key - 0x1B in hex\n                case Key.Insert:\n                    return 0x2D;  // Insert Key - 0x2D in hex\n                case Key.Delete:\n                    return 0x2E;  // Delete Key - 0x2E in hex\n                default:\n                    throw new ArgumentException($\"Key {key} is not supported, Please add your key at TranslateKeyHex for translation to hex.\");\n            }\n        }\n\n        /// <summary>\n        /// Sends a combination of keys, including the Windows key, to the system.\n        /// </summary>\n        /// <param name=\"keys\">The keys to send.</param>\n        private static void SendWinKeyCombination(string keys)\n        {\n            bool winKeyDown = false;\n\n            if (keys.Contains(\"{WIN}\"))\n            {\n                keybd_event(VK_LWIN, 0, KEYEVENTF_KEYDOWN, UIntPtr.Zero);\n                winKeyDown = true;\n                keys = keys.Replace(\"{WIN}\", string.Empty); // Remove {WIN} from the string\n            }\n\n            System.Windows.Forms.SendKeys.SendWait(keys);\n\n            // Release Windows key\n            if (winKeyDown)\n            {\n                keybd_event(VK_LWIN, 0, KEYEVENTF_KEYUP, UIntPtr.Zero);\n            }\n        }\n\n        /// <summary>\n        /// Just press the key.(no release)\n        /// </summary>\n        private static void PressVirtualKey(byte key)\n        {\n            keybd_event(key, 0, KEYEVENTF_KEYDOWN, UIntPtr.Zero);\n        }\n\n        /// <summary>\n        /// Release only the button (if pressed first)\n        /// </summary>\n        private static void ReleaseVirtualKey(byte key)\n        {\n            keybd_event(key, 0, KEYEVENTF_KEYUP, UIntPtr.Zero);\n        }\n    }\n}\n"
      },
      {
        "instruction": "void 반환 타입의 SendKey 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// Represents keyboard keys.\n    /// </summary>\n    public enum Key\n    {\n        Ctrl,\n        LCtrl,\n        RCtrl,\n        Alt,\n        Shift,\n        Tab,\n        Esc,\n        Enter,\n        Win,\n        A,\n        B,\n        C,\n        D,\n        E,\n        F,\n        G,\n        H,\n        I,\n        J,\n        K,\n        L,\n        M,\n        N,\n        O,\n        P,\n        Q,\n        R,\n        S,\n        T,\n        U,\n        V,\n        W,\n        X,\n        Y,\n        Z,\n        Num0,\n        Num1,\n        Num2,\n        Num3,\n        Num4,\n        Num5,\n        Num6,\n        Num7,\n        Num8,\n        Num9,\n        F1,\n        F2,\n        F3,\n        F4,\n        F5,\n        F6,\n        F7,\n        F8,\n        F9,\n        F10,\n        F11,\n        F12,\n        Space,\n        Backspace,\n        Delete,\n        Insert,\n        Home,\n        End,\n        PageUp,\n        PageDown,\n        Up,\n        Down,\n        Left,\n        Right,\n        Other,\n    }\n\n    /// <summary>\n    /// Provides methods for simulating keyboard input.\n    /// </summary>\n    internal static class KeyboardHelper\n    {\n        [DllImport(\"user32.dll\")]\n#pragma warning disable SA1300 // Element should begin with upper-case letter\n        private static extern void keybd_event(byte bVk, byte bScan, uint dwFlags, UIntPtr dwExtraInfo);\n#pragma warning restore SA1300 // Element should begin with upper-case letter\n\n#pragma warning disable SA1310 // Field names should not contain underscore\n        private const byte VK_LWIN = 0x5B;\n        private const uint KEYEVENTF_KEYDOWN = 0x0000;\n        private const uint KEYEVENTF_KEYUP = 0x0002;\n#pragma warning restore SA1310 // Field names should not contain underscore\n\n        /// <summary>\n        /// Sends a combination of keys.\n        /// </summary>\n        /// <param name=\"keys\">The keys to send.</param>\n        public static void SendKeys(params Key[] keys)\n        {\n            string keysToSend = string.Join(string.Empty, keys.Select(TranslateKey));\n            SendWinKeyCombination(keysToSend);\n        }\n\n        public static void PressKey(Key key)\n        {\n            PressVirtualKey(TranslateKeyHex(key));\n        }\n\n        public static void ReleaseKey(Key key)\n        {\n            ReleaseVirtualKey(TranslateKeyHex(key));\n        }\n\n        public static void SendKey(Key key)\n        {\n            PressVirtualKey(TranslateKeyHex(key));\n            ReleaseVirtualKey(TranslateKeyHex(key));\n        }\n\n        /// <summary>\n        /// Translates a key to its corresponding SendKeys representation.\n        /// </summary>\n        /// <param name=\"key\">The key to translate.</param>\n        /// <returns>The SendKeys representation of the key.</returns>\n        private static string TranslateKey(Key key)\n        {\n            switch (key)\n            {\n                case Key.Ctrl:\n                    return \"^\";\n                case Key.LCtrl:\n                    return \"^\";\n                case Key.RCtrl:\n                    return \"^\";\n                case Key.Alt:\n                    return \"%\";\n                case Key.Shift:\n                    return \"+\";\n                case Key.Tab:\n                    return \"{TAB}\";\n                case Key.Esc:\n                    return \"{ESC}\";\n                case Key.Enter:\n                    return \"{ENTER}\";\n                case Key.Win:\n                    return \"{WIN}\";\n                case Key.Space:\n                    return \" \";\n                case Key.Backspace:\n                    return \"{BACKSPACE}\";\n                case Key.Delete:\n                    return \"{DELETE}\";\n                case Key.Insert:\n                    return \"{INSERT}\";\n                case Key.Home:\n                    return \"{HOME}\";\n                case Key.End:\n                    return \"{END}\";\n                case Key.PageUp:\n                    return \"{PGUP}\";\n                case Key.PageDown:\n                    return \"{PGDN}\";\n                case Key.Up:\n                    return \"{UP}\";\n                case Key.Down:\n                    return \"{DOWN}\";\n                case Key.Left:\n                    return \"{LEFT}\";\n                case Key.Right:\n                    return \"{RIGHT}\";\n                case Key.F1:\n                    return \"{F1}\";\n                case Key.F2:\n                    return \"{F2}\";\n                case Key.F3:\n                    return \"{F3}\";\n                case Key.F4:\n                    return \"{F4}\";\n                case Key.F5:\n                    return \"{F5}\";\n                case Key.F6:\n                    return \"{F6}\";\n                case Key.F7:\n                    return \"{F7}\";\n                case Key.F8:\n                    return \"{F8}\";\n                case Key.F9:\n                    return \"{F9}\";\n                case Key.F10:\n                    return \"{F10}\";\n                case Key.F11:\n                    return \"{F11}\";\n                case Key.F12:\n                    return \"{F12}\";\n                case Key.A:\n                    return \"a\";\n                case Key.B:\n                    return \"b\";\n                case Key.C:\n                    return \"c\";\n                case Key.D:\n                    return \"d\";\n                case Key.E:\n                    return \"e\";\n                case Key.F:\n                    return \"f\";\n                case Key.G:\n                    return \"g\";\n                case Key.H:\n                    return \"h\";\n                case Key.I:\n                    return \"i\";\n                case Key.J:\n                    return \"j\";\n                case Key.K:\n                    return \"k\";\n                case Key.L:\n                    return \"l\";\n                case Key.M:\n                    return \"m\";\n                case Key.N:\n                    return \"n\";\n                case Key.O:\n                    return \"o\";\n                case Key.P:\n                    return \"p\";\n                case Key.Q:\n                    return \"q\";\n                case Key.R:\n                    return \"r\";\n                case Key.S:\n                    return \"s\";\n                case Key.T:\n                    return \"t\";\n                case Key.U:\n                    return \"u\";\n                case Key.V:\n                    return \"v\";\n                case Key.W:\n                    return \"w\";\n                case Key.X:\n                    return \"x\";\n                case Key.Y:\n                    return \"y\";\n                case Key.Z:\n                    return \"z\";\n                case Key.Num0:\n                    return \"0\";\n                case Key.Num1:\n                    return \"1\";\n                case Key.Num2:\n                    return \"2\";\n                case Key.Num3:\n                    return \"3\";\n                case Key.Num4:\n                    return \"4\";\n                case Key.Num5:\n                    return \"5\";\n                case Key.Num6:\n                    return \"6\";\n                case Key.Num7:\n                    return \"7\";\n                case Key.Num8:\n                    return \"8\";\n                case Key.Num9:\n                    return \"9\";\n                default:\n                    return string.Empty;\n            }\n        }\n\n        /// <summary>\n        /// map the virtual key codes to the corresponding keys.\n        /// </summary>\n        private static byte TranslateKeyHex(Key key)\n        {\n            switch (key)\n            {\n                case Key.Win:\n                    return 0x5B;  // Windows Key - 0x5B in hex\n                case Key.Ctrl:\n                    return 0x11;  // Ctrl Key - 0x11 in hex\n                case Key.Alt:\n                    return 0x12;  // Alt Key - 0x12 in hex\n                case Key.Shift:\n                    return 0x10;  // Shift Key - 0x10 in hex\n                case Key.LCtrl:\n                    return 0xA2;  // Left Ctrl Key - 0xA2 in hex\n                case Key.RCtrl:\n                    return 0xA3;  // Right Ctrl Key - 0xA3 in hex\n                case Key.A:\n                    return 0x41;  // A Key - 0x41 in hex\n                case Key.B:\n                    return 0x42;  // B Key - 0x42 in hex\n                case Key.C:\n                    return 0x43;  // C Key - 0x43 in hex\n                case Key.D:\n                    return 0x44;  // D Key - 0x44 in hex\n                case Key.E:\n                    return 0x45;  // E Key - 0x45 in hex\n                case Key.F:\n                    return 0x46;  // F Key - 0x46 in hex\n                case Key.G:\n                    return 0x47;  // G Key - 0x47 in hex\n                case Key.H:\n                    return 0x48;  // H Key - 0x48 in hex\n                case Key.I:\n                    return 0x49;  // I Key - 0x49 in hex\n                case Key.J:\n                    return 0x4A;  // J Key - 0x4A in hex\n                case Key.K:\n                    return 0x4B;  // K Key - 0x4B in hex\n                case Key.L:\n                    return 0x4C;  // L Key - 0x4C in hex\n                case Key.M:\n                    return 0x4D;  // M Key - 0x4D in hex\n                case Key.N:\n                    return 0x4E;  // N Key - 0x4E in hex\n                case Key.O:\n                    return 0x4F;  // O Key - 0x4F in hex\n                case Key.P:\n                    return 0x50;  // P Key - 0x50 in hex\n                case Key.Q:\n                    return 0x51;  // Q Key - 0x51 in hex\n                case Key.R:\n                    return 0x52;  // R Key - 0x52 in hex\n                case Key.S:\n                    return 0x53;  // S Key - 0x53 in hex\n                case Key.T:\n                    return 0x54;  // T Key - 0x54 in hex\n                case Key.U:\n                    return 0x55;  // U Key - 0x55 in hex\n                case Key.V:\n                    return 0x56;  // V Key - 0x56 in hex\n                case Key.W:\n                    return 0x57;  // W Key - 0x57 in hex\n                case Key.X:\n                    return 0x58;  // X Key - 0x58 in hex\n                case Key.Y:\n                    return 0x59;  // Y Key - 0x59 in hex\n                case Key.Z:\n                    return 0x5A;  // Z Key - 0x5A in hex\n                case Key.Num0:\n                    return 0x30;  // 0 Key - 0x30 in hex\n                case Key.Num1:\n                    return 0x31;  // 1 Key - 0x31 in hex\n                case Key.Num2:\n                    return 0x32;  // 2 Key - 0x32 in hex\n                case Key.Num3:\n                    return 0x33;  // 3 Key - 0x33 in hex\n                case Key.Num4:\n                    return 0x34;  // 4 Key - 0x34 in hex\n                case Key.Num5:\n                    return 0x35;  // 5 Key - 0x35 in hex\n                case Key.Num6:\n                    return 0x36;  // 6 Key - 0x36 in hex\n                case Key.Num7:\n                    return 0x37;  // 7 Key - 0x37 in hex\n                case Key.Num8:\n                    return 0x38;  // 8 Key - 0x38 in hex\n                case Key.Num9:\n                    return 0x39;  // 9 Key - 0x39 in hex\n                case Key.F1:\n                    return 0x70;  // F1 Key - 0x70 in hex\n                case Key.F2:\n                    return 0x71;  // F2 Key - 0x71 in hex\n                case Key.F3:\n                    return 0x72;  // F3 Key - 0x72 in hex\n                case Key.F4:\n                    return 0x73;  // F4 Key - 0x73 in hex\n                case Key.F5:\n                    return 0x74;  // F5 Key - 0x74 in hex\n                case Key.F6:\n                    return 0x75;  // F6 Key - 0x75 in hex\n                case Key.F7:\n                    return 0x76;  // F7 Key - 0x76 in hex\n                case Key.F8:\n                    return 0x77;  // F8 Key - 0x77 in hex\n                case Key.F9:\n                    return 0x78;  // F9 Key - 0x78 in hex\n                case Key.F10:\n                    return 0x79;  // F10 Key - 0x79 in hex\n                case Key.F11:\n                    return 0x7A;  // F11 Key - 0x7A in hex\n                case Key.F12:\n                    return 0x7B;  // F12 Key - 0x7B in hex\n                case Key.Up:\n                    return 0x26;  // Up Arrow Key - 0x26 in hex\n                case Key.Down:\n                    return 0x28;  // Down Arrow Key - 0x28 in hex\n                case Key.Left:\n                    return 0x25;  // Left Arrow Key - 0x25 in hex\n                case Key.Right:\n                    return 0x27;  // Right Arrow Key - 0x27 in hex\n                case Key.Home:\n                    return 0x24;  // Home Key - 0x24 in hex\n                case Key.End:\n                    return 0x23;  // End Key - 0x23 in hex\n                case Key.PageUp:\n                    return 0x21;  // Page Up Key - 0x21 in hex\n                case Key.PageDown:\n                    return 0x22;  // Page Down Key - 0x22 in hex\n                case Key.Space:\n                    return 0x20;  // Space Key - 0x20 in hex\n                case Key.Enter:\n                    return 0x0D;  // Enter Key - 0x0D in hex\n                case Key.Backspace:\n                    return 0x08;  // Backspace Key - 0x08 in hex\n                case Key.Tab:\n                    return 0x09;  // Tab Key - 0x09 in hex\n                case Key.Esc:\n                    return 0x1B;  // Escape Key - 0x1B in hex\n                case Key.Insert:\n                    return 0x2D;  // Insert Key - 0x2D in hex\n                case Key.Delete:\n                    return 0x2E;  // Delete Key - 0x2E in hex\n                default:\n                    throw new ArgumentException($\"Key {key} is not supported, Please add your key at TranslateKeyHex for translation to hex.\");\n            }\n        }\n\n        /// <summary>\n        /// Sends a combination of keys, including the Windows key, to the system.\n        /// </summary>\n        /// <param name=\"keys\">The keys to send.</param>\n        private static void SendWinKeyCombination(string keys)\n        {\n            bool winKeyDown = false;\n\n            if (keys.Contains(\"{WIN}\"))\n            {\n                keybd_event(VK_LWIN, 0, KEYEVENTF_KEYDOWN, UIntPtr.Zero);\n                winKeyDown = true;\n                keys = keys.Replace(\"{WIN}\", string.Empty); // Remove {WIN} from the string\n            }\n\n            System.Windows.Forms.SendKeys.SendWait(keys);\n\n            // Release Windows key\n            if (winKeyDown)\n            {\n                keybd_event(VK_LWIN, 0, KEYEVENTF_KEYUP, UIntPtr.Zero);\n            }\n        }\n\n        /// <summary>\n        /// Just press the key.(no release)\n        /// </summary>\n        private static void PressVirtualKey(byte key)\n        {\n            keybd_event(key, 0, KEYEVENTF_KEYDOWN, UIntPtr.Zero);\n        }\n\n        /// <summary>\n        /// Release only the button (if pressed first)\n        /// </summary>\n        private static void ReleaseVirtualKey(byte key)\n        {\n            keybd_event(key, 0, KEYEVENTF_KEYUP, UIntPtr.Zero);\n        }\n    }\n}\n"
      },
      {
        "instruction": "Service 패턴을 사용하는 C# 코드를 작성해주세요.",
        "context": "프로덕션 환경에서 사용 가능한 수준으로 작성해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// Represents keyboard keys.\n    /// </summary>\n    public enum Key\n    {\n        Ctrl,\n        LCtrl,\n        RCtrl,\n        Alt,\n        Shift,\n        Tab,\n        Esc,\n        Enter,\n        Win,\n        A,\n        B,\n        C,\n        D,\n        E,\n        F,\n        G,\n        H,\n        I,\n        J,\n        K,\n        L,\n        M,\n        N,\n        O,\n        P,\n        Q,\n        R,\n        S,\n        T,\n        U,\n        V,\n        W,\n        X,\n        Y,\n        Z,\n        Num0,\n        Num1,\n        Num2,\n        Num3,\n        Num4,\n        Num5,\n        Num6,\n        Num7,\n        Num8,\n        Num9,\n        F1,\n        F2,\n        F3,\n        F4,\n        F5,\n        F6,\n        F7,\n        F8,\n        F9,\n        F10,\n        F11,\n        F12,\n        Space,\n        Backspace,\n        Delete,\n        Insert,\n        Home,\n        End,\n        PageUp,\n        PageDown,\n        Up,\n        Down,\n        Left,\n        Right,\n        Other,\n    }\n\n    /// <summary>\n    /// Provides methods for simulating keyboard input.\n    /// </summary>\n    internal static class KeyboardHelper\n    {\n        [DllImport(\"user32.dll\")]\n#pragma warning disable SA1300 // Element should begin with upper-case letter\n        private static extern void keybd_event(byte bVk, byte bScan, uint dwFlags, UIntPtr dwExtraInfo);\n#pragma warning restore SA1300 // Element should begin with upper-case letter\n\n#pragma warning disable SA1310 // Field names should not contain underscore\n        private const byte VK_LWIN = 0x5B;\n        private const uint KEYEVENTF_KEYDOWN = 0x0000;\n        private const uint KEYEVENTF_KEYUP = 0x0002;\n#pragma warning restore SA1310 // Field names should not contain underscore\n\n        /// <summary>\n        /// Sends a combination of keys.\n        /// </summary>\n        /// <param name=\"keys\">The keys to send.</param>\n        public static void SendKeys(params Key[] keys)\n        {\n            string keysToSend = string.Join(string.Empty, keys.Select(TranslateKey));\n            SendWinKeyCombination(keysToSend);\n        }\n\n        public static void PressKey(Key key)\n        {\n            PressVirtualKey(TranslateKeyHex(key));\n        }\n\n        public static void ReleaseKey(Key key)\n        {\n            ReleaseVirtualKey(TranslateKeyHex(key));\n        }\n\n        public static void SendKey(Key key)\n        {\n            PressVirtualKey(TranslateKeyHex(key));\n            ReleaseVirtualKey(TranslateKeyHex(key));\n        }\n\n        /// <summary>\n        /// Translates a key to its corresponding SendKeys representation.\n        /// </summary>\n        /// <param name=\"key\">The key to translate.</param>\n        /// <returns>The SendKeys representation of the key.</returns>\n        private static string TranslateKey(Key key)\n        {\n            switch (key)\n            {\n                case Key.Ctrl:\n                    return \"^\";\n                case Key.LCtrl:\n                    return \"^\";\n                case Key.RCtrl:\n                    return \"^\";\n                case Key.Alt:\n                    return \"%\";\n                case Key.Shift:\n                    return \"+\";\n                case Key.Tab:\n                    return \"{TAB}\";\n                case Key.Esc:\n                    return \"{ESC}\";\n                case Key.Enter:\n                    return \"{ENTER}\";\n                case Key.Win:\n                    return \"{WIN}\";\n                case Key.Space:\n                    return \" \";\n                case Key.Backspace:\n                    return \"{BACKSPACE}\";\n                case Key.Delete:\n                    return \"{DELETE}\";\n                case Key.Insert:\n                    return \"{INSERT}\";\n                case Key.Home:\n                    return \"{HOME}\";\n                case Key.End:\n                    return \"{END}\";\n                case Key.PageUp:\n                    return \"{PGUP}\";\n                case Key.PageDown:\n                    return \"{PGDN}\";\n                case Key.Up:\n                    return \"{UP}\";\n                case Key.Down:\n                    return \"{DOWN}\";\n                case Key.Left:\n                    return \"{LEFT}\";\n                case Key.Right:\n                    return \"{RIGHT}\";\n                case Key.F1:\n                    return \"{F1}\";\n                case Key.F2:\n                    return \"{F2}\";\n                case Key.F3:\n                    return \"{F3}\";\n                case Key.F4:\n                    return \"{F4}\";\n                case Key.F5:\n                    return \"{F5}\";\n                case Key.F6:\n                    return \"{F6}\";\n                case Key.F7:\n                    return \"{F7}\";\n                case Key.F8:\n                    return \"{F8}\";\n                case Key.F9:\n                    return \"{F9}\";\n                case Key.F10:\n                    return \"{F10}\";\n                case Key.F11:\n                    return \"{F11}\";\n                case Key.F12:\n                    return \"{F12}\";\n                case Key.A:\n                    return \"a\";\n                case Key.B:\n                    return \"b\";\n                case Key.C:\n                    return \"c\";\n                case Key.D:\n                    return \"d\";\n                case Key.E:\n                    return \"e\";\n                case Key.F:\n                    return \"f\";\n                case Key.G:\n                    return \"g\";\n                case Key.H:\n                    return \"h\";\n                case Key.I:\n                    return \"i\";\n                case Key.J:\n                    return \"j\";\n                case Key.K:\n                    return \"k\";\n                case Key.L:\n                    return \"l\";\n                case Key.M:\n                    return \"m\";\n                case Key.N:\n                    return \"n\";\n                case Key.O:\n                    return \"o\";\n                case Key.P:\n                    return \"p\";\n                case Key.Q:\n                    return \"q\";\n                case Key.R:\n                    return \"r\";\n                case Key.S:\n                    return \"s\";\n                case Key.T:\n                    return \"t\";\n                case Key.U:\n                    return \"u\";\n                case Key.V:\n                    return \"v\";\n                case Key.W:\n                    return \"w\";\n                case Key.X:\n                    return \"x\";\n                case Key.Y:\n                    return \"y\";\n                case Key.Z:\n                    return \"z\";\n                case Key.Num0:\n                    return \"0\";\n                case Key.Num1:\n                    return \"1\";\n                case Key.Num2:\n                    return \"2\";\n                case Key.Num3:\n                    return \"3\";\n                case Key.Num4:\n                    return \"4\";\n                case Key.Num5:\n                    return \"5\";\n                case Key.Num6:\n                    return \"6\";\n                case Key.Num7:\n                    return \"7\";\n                case Key.Num8:\n                    return \"8\";\n                case Key.Num9:\n                    return \"9\";\n                default:\n                    return string.Empty;\n            }\n        }\n\n        /// <summary>\n        /// map the virtual key codes to the corresponding keys.\n        /// </summary>\n        private static byte TranslateKeyHex(Key key)\n        {\n            switch (key)\n            {\n                case Key.Win:\n                    return 0x5B;  // Windows Key - 0x5B in hex\n                case Key.Ctrl:\n                    return 0x11;  // Ctrl Key - 0x11 in hex\n                case Key.Alt:\n                    return 0x12;  // Alt Key - 0x12 in hex\n                case Key.Shift:\n                    return 0x10;  // Shift Key - 0x10 in hex\n                case Key.LCtrl:\n                    return 0xA2;  // Left Ctrl Key - 0xA2 in hex\n                case Key.RCtrl:\n                    return 0xA3;  // Right Ctrl Key - 0xA3 in hex\n                case Key.A:\n                    return 0x41;  // A Key - 0x41 in hex\n                case Key.B:\n                    return 0x42;  // B Key - 0x42 in hex\n                case Key.C:\n                    return 0x43;  // C Key - 0x43 in hex\n                case Key.D:\n                    return 0x44;  // D Key - 0x44 in hex\n                case Key.E:\n                    return 0x45;  // E Key - 0x45 in hex\n                case Key.F:\n                    return 0x46;  // F Key - 0x46 in hex\n                case Key.G:\n                    return 0x47;  // G Key - 0x47 in hex\n                case Key.H:\n                    return 0x48;  // H Key - 0x48 in hex\n                case Key.I:\n                    return 0x49;  // I Key - 0x49 in hex\n                case Key.J:\n                    return 0x4A;  // J Key - 0x4A in hex\n                case Key.K:\n                    return 0x4B;  // K Key - 0x4B in hex\n                case Key.L:\n                    return 0x4C;  // L Key - 0x4C in hex\n                case Key.M:\n                    return 0x4D;  // M Key - 0x4D in hex\n                case Key.N:\n                    return 0x4E;  // N Key - 0x4E in hex\n                case Key.O:\n                    return 0x4F;  // O Key - 0x4F in hex\n                case Key.P:\n                    return 0x50;  // P Key - 0x50 in hex\n                case Key.Q:\n                    return 0x51;  // Q Key - 0x51 in hex\n                case Key.R:\n                    return 0x52;  // R Key - 0x52 in hex\n                case Key.S:\n                    return 0x53;  // S Key - 0x53 in hex\n                case Key.T:\n                    return 0x54;  // T Key - 0x54 in hex\n                case Key.U:\n                    return 0x55;  // U Key - 0x55 in hex\n                case Key.V:\n                    return 0x56;  // V Key - 0x56 in hex\n                case Key.W:\n                    return 0x57;  // W Key - 0x57 in hex\n                case Key.X:\n                    return 0x58;  // X Key - 0x58 in hex\n                case Key.Y:\n                    return 0x59;  // Y Key - 0x59 in hex\n                case Key.Z:\n                    return 0x5A;  // Z Key - 0x5A in hex\n                case Key.Num0:\n                    return 0x30;  // 0 Key - 0x30 in hex\n                case Key.Num1:\n                    return 0x31;  // 1 Key - 0x31 in hex\n                case Key.Num2:\n                    return 0x32;  // 2 Key - 0x32 in hex\n                case Key.Num3:\n                    return 0x33;  // 3 Key - 0x33 in hex\n                case Key.Num4:\n                    return 0x34;  // 4 Key - 0x34 in hex\n                case Key.Num5:\n                    return 0x35;  // 5 Key - 0x35 in hex\n                case Key.Num6:\n                    return 0x36;  // 6 Key - 0x36 in hex\n                case Key.Num7:\n                    return 0x37;  // 7 Key - 0x37 in hex\n                case Key.Num8:\n                    return 0x38;  // 8 Key - 0x38 in hex\n                case Key.Num9:\n                    return 0x39;  // 9 Key - 0x39 in hex\n                case Key.F1:\n                    return 0x70;  // F1 Key - 0x70 in hex\n                case Key.F2:\n                    return 0x71;  // F2 Key - 0x71 in hex\n                case Key.F3:\n                    return 0x72;  // F3 Key - 0x72 in hex\n                case Key.F4:\n                    return 0x73;  // F4 Key - 0x73 in hex\n                case Key.F5:\n                    return 0x74;  // F5 Key - 0x74 in hex\n                case Key.F6:\n                    return 0x75;  // F6 Key - 0x75 in hex\n                case Key.F7:\n                    return 0x76;  // F7 Key - 0x76 in hex\n                case Key.F8:\n                    return 0x77;  // F8 Key - 0x77 in hex\n                case Key.F9:\n                    return 0x78;  // F9 Key - 0x78 in hex\n                case Key.F10:\n                    return 0x79;  // F10 Key - 0x79 in hex\n                case Key.F11:\n                    return 0x7A;  // F11 Key - 0x7A in hex\n                case Key.F12:\n                    return 0x7B;  // F12 Key - 0x7B in hex\n                case Key.Up:\n                    return 0x26;  // Up Arrow Key - 0x26 in hex\n                case Key.Down:\n                    return 0x28;  // Down Arrow Key - 0x28 in hex\n                case Key.Left:\n                    return 0x25;  // Left Arrow Key - 0x25 in hex\n                case Key.Right:\n                    return 0x27;  // Right Arrow Key - 0x27 in hex\n                case Key.Home:\n                    return 0x24;  // Home Key - 0x24 in hex\n                case Key.End:\n                    return 0x23;  // End Key - 0x23 in hex\n                case Key.PageUp:\n                    return 0x21;  // Page Up Key - 0x21 in hex\n                case Key.PageDown:\n                    return 0x22;  // Page Down Key - 0x22 in hex\n                case Key.Space:\n                    return 0x20;  // Space Key - 0x20 in hex\n                case Key.Enter:\n                    return 0x0D;  // Enter Key - 0x0D in hex\n                case Key.Backspace:\n                    return 0x08;  // Backspace Key - 0x08 in hex\n                case Key.Tab:\n                    return 0x09;  // Tab Key - 0x09 in hex\n                case Key.Esc:\n                    return 0x1B;  // Escape Key - 0x1B in hex\n                case Key.Insert:\n                    return 0x2D;  // Insert Key - 0x2D in hex\n                case Key.Delete:\n                    return 0x2E;  // Delete Key - 0x2E in hex\n                default:\n                    throw new ArgumentException($\"Key {key} is not supported, Please add your key at TranslateKeyHex for translation to hex.\");\n            }\n        }\n\n        /// <summary>\n        /// Sends a combination of keys, including the Windows key, to the system.\n        /// </summary>\n        /// <param name=\"keys\">The keys to send.</param>\n        private static void SendWinKeyCombination(string keys)\n        {\n            bool winKeyDown = false;\n\n            if (keys.Contains(\"{WIN}\"))\n            {\n                keybd_event(VK_LWIN, 0, KEYEVENTF_KEYDOWN, UIntPtr.Zero);\n                winKeyDown = true;\n                keys = keys.Replace(\"{WIN}\", string.Empty); // Remove {WIN} from the string\n            }\n\n            System.Windows.Forms.SendKeys.SendWait(keys);\n\n            // Release Windows key\n            if (winKeyDown)\n            {\n                keybd_event(VK_LWIN, 0, KEYEVENTF_KEYUP, UIntPtr.Zero);\n            }\n        }\n\n        /// <summary>\n        /// Just press the key.(no release)\n        /// </summary>\n        private static void PressVirtualKey(byte key)\n        {\n            keybd_event(key, 0, KEYEVENTF_KEYDOWN, UIntPtr.Zero);\n        }\n\n        /// <summary>\n        /// Release only the button (if pressed first)\n        /// </summary>\n        private static void ReleaseVirtualKey(byte key)\n        {\n            keybd_event(key, 0, KEYEVENTF_KEYUP, UIntPtr.Zero);\n        }\n    }\n}\n"
      }
    ]
  },
  {
    "id": "6a046168cb0b3e0fed74d82cd27e812a",
    "source": "github",
    "file_path": "src/common/UITestAutomation/ModuleConfigData.cs",
    "repository": "",
    "code": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Runtime.CompilerServices;\n\n[assembly: InternalsVisibleTo(\"UITestBase\")]\n[assembly: InternalsVisibleTo(\"Session\")]\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// This file manages the configuration of modules for UI tests.\n    /// </summary>\n    /// <remarks>\n    /// How to add a new module:\n    /// 1. Define the new module in the PowerToysModule enum.\n    /// 2. Add the exe window name to the ModuleWindowName dictionary in the ModuleConfigData constructor.\n    /// 3. Add the exe path to the ModulePath dictionary in the ModuleConfigData constructor.\n    /// </remarks>\n\n    /// <summary>\n    /// Represents the modules in PowerToys.\n    /// </summary>\n    public enum PowerToysModule\n    {\n        PowerToysSettings,\n        FancyZone,\n        Hosts,\n        Runner,\n        Workspaces,\n    }\n\n    /// <summary>\n    /// Represents the window size for the UI test.\n    /// </summary>\n    public enum WindowSize\n    {\n        /// <summary>\n        /// Unspecified window size, won't make any size change\n        /// </summary>\n        UnSpecified,\n\n        /// <summary>\n        /// Small window size, 640 * 480\n        /// </summary>\n        Small,\n\n        /// <summary>\n        /// Small window size, 480 * 640\n        /// </summary>\n        Small_Vertical,\n\n        /// <summary>\n        /// Medium window size, 1024 * 768\n        /// </summary>\n        Medium,\n\n        /// <summary>\n        /// Medium window size, 768 * 1024\n        /// </summary>\n        Medium_Vertical,\n\n        /// <summary>\n        /// Large window size, 1920 * 1080\n        /// </summary>\n        Large,\n\n        /// <summary>\n        /// Large window size, 1080 * 1920\n        /// </summary>\n        Large_Vertical,\n    }\n\n    internal class ModuleConfigData\n    {\n        private Dictionary<PowerToysModule, string> ModulePath { get; }\n\n        // Singleton instance of ModuleConfigData.\n        private static readonly Lazy<ModuleConfigData> SingletonInstance = new Lazy<ModuleConfigData>(() => new ModuleConfigData());\n\n        public static ModuleConfigData Instance => SingletonInstance.Value;\n\n        public const string WindowsApplicationDriverUrl = \"http://127.0.0.1:4723\";\n\n        public Dictionary<PowerToysModule, string> ModuleWindowName { get; }\n\n        private ModuleConfigData()\n        {\n            // The exe window name for each module.\n            ModuleWindowName = new Dictionary<PowerToysModule, string>\n            {\n                [PowerToysModule.PowerToysSettings] = \"PowerToys Settings\",\n                [PowerToysModule.FancyZone] = \"FancyZones Layout\",\n                [PowerToysModule.Hosts] = \"Hosts File Editor\",\n                [PowerToysModule.Runner] = \"PowerToys\",\n                [PowerToysModule.Workspaces] = \"Workspaces Editor\",\n            };\n\n            // Exe start path for the module if it exists.\n            ModulePath = new Dictionary<PowerToysModule, string>\n            {\n                [PowerToysModule.PowerToysSettings] = @\"\\..\\..\\..\\WinUI3Apps\\PowerToys.Settings.exe\",\n                [PowerToysModule.FancyZone] = @\"\\..\\..\\..\\PowerToys.FancyZonesEditor.exe\",\n                [PowerToysModule.Hosts] = @\"\\..\\..\\..\\WinUI3Apps\\PowerToys.Hosts.exe\",\n                [PowerToysModule.Runner] = @\"\\..\\..\\..\\PowerToys.exe\",\n                [PowerToysModule.Workspaces] = @\"\\..\\..\\..\\PowerToys.WorkspacesEditor.exe\",\n            };\n        }\n\n        public string GetModulePath(PowerToysModule scope) => ModulePath[scope];\n\n        public string GetWindowsApplicationDriverUrl() => WindowsApplicationDriverUrl;\n\n        public string GetModuleWindowName(PowerToysModule scope) => ModuleWindowName[scope];\n    }\n}\n",
    "patterns": [
      "Service",
      "Uses Generics",
      "Uses Lambda Expressions",
      "Uses Pattern Matching",
      "Uses Expression Bodies"
    ],
    "timestamp": "2025-06-24T22:15:47.191060",
    "quality_score": 0.8000000000000002,
    "training_prompts": [
      {
        "instruction": "string 반환 타입의 GetModulePath 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Runtime.CompilerServices;\n\n[assembly: InternalsVisibleTo(\"UITestBase\")]\n[assembly: InternalsVisibleTo(\"Session\")]\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// This file manages the configuration of modules for UI tests.\n    /// </summary>\n    /// <remarks>\n    /// How to add a new module:\n    /// 1. Define the new module in the PowerToysModule enum.\n    /// 2. Add the exe window name to the ModuleWindowName dictionary in the ModuleConfigData constructor.\n    /// 3. Add the exe path to the ModulePath dictionary in the ModuleConfigData constructor.\n    /// </remarks>\n\n    /// <summary>\n    /// Represents the modules in PowerToys.\n    /// </summary>\n    public enum PowerToysModule\n    {\n        PowerToysSettings,\n        FancyZone,\n        Hosts,\n        Runner,\n        Workspaces,\n    }\n\n    /// <summary>\n    /// Represents the window size for the UI test.\n    /// </summary>\n    public enum WindowSize\n    {\n        /// <summary>\n        /// Unspecified window size, won't make any size change\n        /// </summary>\n        UnSpecified,\n\n        /// <summary>\n        /// Small window size, 640 * 480\n        /// </summary>\n        Small,\n\n        /// <summary>\n        /// Small window size, 480 * 640\n        /// </summary>\n        Small_Vertical,\n\n        /// <summary>\n        /// Medium window size, 1024 * 768\n        /// </summary>\n        Medium,\n\n        /// <summary>\n        /// Medium window size, 768 * 1024\n        /// </summary>\n        Medium_Vertical,\n\n        /// <summary>\n        /// Large window size, 1920 * 1080\n        /// </summary>\n        Large,\n\n        /// <summary>\n        /// Large window size, 1080 * 1920\n        /// </summary>\n        Large_Vertical,\n    }\n\n    internal class ModuleConfigData\n    {\n        private Dictionary<PowerToysModule, string> ModulePath { get; }\n\n        // Singleton instance of ModuleConfigData.\n        private static readonly Lazy<ModuleConfigData> SingletonInstance = new Lazy<ModuleConfigData>(() => new ModuleConfigData());\n\n        public static ModuleConfigData Instance => SingletonInstance.Value;\n\n        public const string WindowsApplicationDriverUrl = \"http://127.0.0.1:4723\";\n\n        public Dictionary<PowerToysModule, string> ModuleWindowName { get; }\n\n        private ModuleConfigData()\n        {\n            // The exe window name for each module.\n            ModuleWindowName = new Dictionary<PowerToysModule, string>\n            {\n                [PowerToysModule.PowerToysSettings] = \"PowerToys Settings\",\n                [PowerToysModule.FancyZone] = \"FancyZones Layout\",\n                [PowerToysModule.Hosts] = \"Hosts File Editor\",\n                [PowerToysModule.Runner] = \"PowerToys\",\n                [PowerToysModule.Workspaces] = \"Workspaces Editor\",\n            };\n\n            // Exe start path for the module if it exists.\n            ModulePath = new Dictionary<PowerToysModule, string>\n            {\n                [PowerToysModule.PowerToysSettings] = @\"\\..\\..\\..\\WinUI3Apps\\PowerToys.Settings.exe\",\n                [PowerToysModule.FancyZone] = @\"\\..\\..\\..\\PowerToys.FancyZonesEditor.exe\",\n                [PowerToysModule.Hosts] = @\"\\..\\..\\..\\WinUI3Apps\\PowerToys.Hosts.exe\",\n                [PowerToysModule.Runner] = @\"\\..\\..\\..\\PowerToys.exe\",\n                [PowerToysModule.Workspaces] = @\"\\..\\..\\..\\PowerToys.WorkspacesEditor.exe\",\n            };\n        }\n\n        public string GetModulePath(PowerToysModule scope) => ModulePath[scope];\n\n        public string GetWindowsApplicationDriverUrl() => WindowsApplicationDriverUrl;\n\n        public string GetModuleWindowName(PowerToysModule scope) => ModuleWindowName[scope];\n    }\n}\n"
      },
      {
        "instruction": "string 반환 타입의 GetWindowsApplicationDriverUrl 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Runtime.CompilerServices;\n\n[assembly: InternalsVisibleTo(\"UITestBase\")]\n[assembly: InternalsVisibleTo(\"Session\")]\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// This file manages the configuration of modules for UI tests.\n    /// </summary>\n    /// <remarks>\n    /// How to add a new module:\n    /// 1. Define the new module in the PowerToysModule enum.\n    /// 2. Add the exe window name to the ModuleWindowName dictionary in the ModuleConfigData constructor.\n    /// 3. Add the exe path to the ModulePath dictionary in the ModuleConfigData constructor.\n    /// </remarks>\n\n    /// <summary>\n    /// Represents the modules in PowerToys.\n    /// </summary>\n    public enum PowerToysModule\n    {\n        PowerToysSettings,\n        FancyZone,\n        Hosts,\n        Runner,\n        Workspaces,\n    }\n\n    /// <summary>\n    /// Represents the window size for the UI test.\n    /// </summary>\n    public enum WindowSize\n    {\n        /// <summary>\n        /// Unspecified window size, won't make any size change\n        /// </summary>\n        UnSpecified,\n\n        /// <summary>\n        /// Small window size, 640 * 480\n        /// </summary>\n        Small,\n\n        /// <summary>\n        /// Small window size, 480 * 640\n        /// </summary>\n        Small_Vertical,\n\n        /// <summary>\n        /// Medium window size, 1024 * 768\n        /// </summary>\n        Medium,\n\n        /// <summary>\n        /// Medium window size, 768 * 1024\n        /// </summary>\n        Medium_Vertical,\n\n        /// <summary>\n        /// Large window size, 1920 * 1080\n        /// </summary>\n        Large,\n\n        /// <summary>\n        /// Large window size, 1080 * 1920\n        /// </summary>\n        Large_Vertical,\n    }\n\n    internal class ModuleConfigData\n    {\n        private Dictionary<PowerToysModule, string> ModulePath { get; }\n\n        // Singleton instance of ModuleConfigData.\n        private static readonly Lazy<ModuleConfigData> SingletonInstance = new Lazy<ModuleConfigData>(() => new ModuleConfigData());\n\n        public static ModuleConfigData Instance => SingletonInstance.Value;\n\n        public const string WindowsApplicationDriverUrl = \"http://127.0.0.1:4723\";\n\n        public Dictionary<PowerToysModule, string> ModuleWindowName { get; }\n\n        private ModuleConfigData()\n        {\n            // The exe window name for each module.\n            ModuleWindowName = new Dictionary<PowerToysModule, string>\n            {\n                [PowerToysModule.PowerToysSettings] = \"PowerToys Settings\",\n                [PowerToysModule.FancyZone] = \"FancyZones Layout\",\n                [PowerToysModule.Hosts] = \"Hosts File Editor\",\n                [PowerToysModule.Runner] = \"PowerToys\",\n                [PowerToysModule.Workspaces] = \"Workspaces Editor\",\n            };\n\n            // Exe start path for the module if it exists.\n            ModulePath = new Dictionary<PowerToysModule, string>\n            {\n                [PowerToysModule.PowerToysSettings] = @\"\\..\\..\\..\\WinUI3Apps\\PowerToys.Settings.exe\",\n                [PowerToysModule.FancyZone] = @\"\\..\\..\\..\\PowerToys.FancyZonesEditor.exe\",\n                [PowerToysModule.Hosts] = @\"\\..\\..\\..\\WinUI3Apps\\PowerToys.Hosts.exe\",\n                [PowerToysModule.Runner] = @\"\\..\\..\\..\\PowerToys.exe\",\n                [PowerToysModule.Workspaces] = @\"\\..\\..\\..\\PowerToys.WorkspacesEditor.exe\",\n            };\n        }\n\n        public string GetModulePath(PowerToysModule scope) => ModulePath[scope];\n\n        public string GetWindowsApplicationDriverUrl() => WindowsApplicationDriverUrl;\n\n        public string GetModuleWindowName(PowerToysModule scope) => ModuleWindowName[scope];\n    }\n}\n"
      },
      {
        "instruction": "string 반환 타입의 GetModuleWindowName 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Runtime.CompilerServices;\n\n[assembly: InternalsVisibleTo(\"UITestBase\")]\n[assembly: InternalsVisibleTo(\"Session\")]\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// This file manages the configuration of modules for UI tests.\n    /// </summary>\n    /// <remarks>\n    /// How to add a new module:\n    /// 1. Define the new module in the PowerToysModule enum.\n    /// 2. Add the exe window name to the ModuleWindowName dictionary in the ModuleConfigData constructor.\n    /// 3. Add the exe path to the ModulePath dictionary in the ModuleConfigData constructor.\n    /// </remarks>\n\n    /// <summary>\n    /// Represents the modules in PowerToys.\n    /// </summary>\n    public enum PowerToysModule\n    {\n        PowerToysSettings,\n        FancyZone,\n        Hosts,\n        Runner,\n        Workspaces,\n    }\n\n    /// <summary>\n    /// Represents the window size for the UI test.\n    /// </summary>\n    public enum WindowSize\n    {\n        /// <summary>\n        /// Unspecified window size, won't make any size change\n        /// </summary>\n        UnSpecified,\n\n        /// <summary>\n        /// Small window size, 640 * 480\n        /// </summary>\n        Small,\n\n        /// <summary>\n        /// Small window size, 480 * 640\n        /// </summary>\n        Small_Vertical,\n\n        /// <summary>\n        /// Medium window size, 1024 * 768\n        /// </summary>\n        Medium,\n\n        /// <summary>\n        /// Medium window size, 768 * 1024\n        /// </summary>\n        Medium_Vertical,\n\n        /// <summary>\n        /// Large window size, 1920 * 1080\n        /// </summary>\n        Large,\n\n        /// <summary>\n        /// Large window size, 1080 * 1920\n        /// </summary>\n        Large_Vertical,\n    }\n\n    internal class ModuleConfigData\n    {\n        private Dictionary<PowerToysModule, string> ModulePath { get; }\n\n        // Singleton instance of ModuleConfigData.\n        private static readonly Lazy<ModuleConfigData> SingletonInstance = new Lazy<ModuleConfigData>(() => new ModuleConfigData());\n\n        public static ModuleConfigData Instance => SingletonInstance.Value;\n\n        public const string WindowsApplicationDriverUrl = \"http://127.0.0.1:4723\";\n\n        public Dictionary<PowerToysModule, string> ModuleWindowName { get; }\n\n        private ModuleConfigData()\n        {\n            // The exe window name for each module.\n            ModuleWindowName = new Dictionary<PowerToysModule, string>\n            {\n                [PowerToysModule.PowerToysSettings] = \"PowerToys Settings\",\n                [PowerToysModule.FancyZone] = \"FancyZones Layout\",\n                [PowerToysModule.Hosts] = \"Hosts File Editor\",\n                [PowerToysModule.Runner] = \"PowerToys\",\n                [PowerToysModule.Workspaces] = \"Workspaces Editor\",\n            };\n\n            // Exe start path for the module if it exists.\n            ModulePath = new Dictionary<PowerToysModule, string>\n            {\n                [PowerToysModule.PowerToysSettings] = @\"\\..\\..\\..\\WinUI3Apps\\PowerToys.Settings.exe\",\n                [PowerToysModule.FancyZone] = @\"\\..\\..\\..\\PowerToys.FancyZonesEditor.exe\",\n                [PowerToysModule.Hosts] = @\"\\..\\..\\..\\WinUI3Apps\\PowerToys.Hosts.exe\",\n                [PowerToysModule.Runner] = @\"\\..\\..\\..\\PowerToys.exe\",\n                [PowerToysModule.Workspaces] = @\"\\..\\..\\..\\PowerToys.WorkspacesEditor.exe\",\n            };\n        }\n\n        public string GetModulePath(PowerToysModule scope) => ModulePath[scope];\n\n        public string GetWindowsApplicationDriverUrl() => WindowsApplicationDriverUrl;\n\n        public string GetModuleWindowName(PowerToysModule scope) => ModuleWindowName[scope];\n    }\n}\n"
      },
      {
        "instruction": "Service 패턴을 사용하는 C# 코드를 작성해주세요.",
        "context": "프로덕션 환경에서 사용 가능한 수준으로 작성해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Runtime.CompilerServices;\n\n[assembly: InternalsVisibleTo(\"UITestBase\")]\n[assembly: InternalsVisibleTo(\"Session\")]\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// This file manages the configuration of modules for UI tests.\n    /// </summary>\n    /// <remarks>\n    /// How to add a new module:\n    /// 1. Define the new module in the PowerToysModule enum.\n    /// 2. Add the exe window name to the ModuleWindowName dictionary in the ModuleConfigData constructor.\n    /// 3. Add the exe path to the ModulePath dictionary in the ModuleConfigData constructor.\n    /// </remarks>\n\n    /// <summary>\n    /// Represents the modules in PowerToys.\n    /// </summary>\n    public enum PowerToysModule\n    {\n        PowerToysSettings,\n        FancyZone,\n        Hosts,\n        Runner,\n        Workspaces,\n    }\n\n    /// <summary>\n    /// Represents the window size for the UI test.\n    /// </summary>\n    public enum WindowSize\n    {\n        /// <summary>\n        /// Unspecified window size, won't make any size change\n        /// </summary>\n        UnSpecified,\n\n        /// <summary>\n        /// Small window size, 640 * 480\n        /// </summary>\n        Small,\n\n        /// <summary>\n        /// Small window size, 480 * 640\n        /// </summary>\n        Small_Vertical,\n\n        /// <summary>\n        /// Medium window size, 1024 * 768\n        /// </summary>\n        Medium,\n\n        /// <summary>\n        /// Medium window size, 768 * 1024\n        /// </summary>\n        Medium_Vertical,\n\n        /// <summary>\n        /// Large window size, 1920 * 1080\n        /// </summary>\n        Large,\n\n        /// <summary>\n        /// Large window size, 1080 * 1920\n        /// </summary>\n        Large_Vertical,\n    }\n\n    internal class ModuleConfigData\n    {\n        private Dictionary<PowerToysModule, string> ModulePath { get; }\n\n        // Singleton instance of ModuleConfigData.\n        private static readonly Lazy<ModuleConfigData> SingletonInstance = new Lazy<ModuleConfigData>(() => new ModuleConfigData());\n\n        public static ModuleConfigData Instance => SingletonInstance.Value;\n\n        public const string WindowsApplicationDriverUrl = \"http://127.0.0.1:4723\";\n\n        public Dictionary<PowerToysModule, string> ModuleWindowName { get; }\n\n        private ModuleConfigData()\n        {\n            // The exe window name for each module.\n            ModuleWindowName = new Dictionary<PowerToysModule, string>\n            {\n                [PowerToysModule.PowerToysSettings] = \"PowerToys Settings\",\n                [PowerToysModule.FancyZone] = \"FancyZones Layout\",\n                [PowerToysModule.Hosts] = \"Hosts File Editor\",\n                [PowerToysModule.Runner] = \"PowerToys\",\n                [PowerToysModule.Workspaces] = \"Workspaces Editor\",\n            };\n\n            // Exe start path for the module if it exists.\n            ModulePath = new Dictionary<PowerToysModule, string>\n            {\n                [PowerToysModule.PowerToysSettings] = @\"\\..\\..\\..\\WinUI3Apps\\PowerToys.Settings.exe\",\n                [PowerToysModule.FancyZone] = @\"\\..\\..\\..\\PowerToys.FancyZonesEditor.exe\",\n                [PowerToysModule.Hosts] = @\"\\..\\..\\..\\WinUI3Apps\\PowerToys.Hosts.exe\",\n                [PowerToysModule.Runner] = @\"\\..\\..\\..\\PowerToys.exe\",\n                [PowerToysModule.Workspaces] = @\"\\..\\..\\..\\PowerToys.WorkspacesEditor.exe\",\n            };\n        }\n\n        public string GetModulePath(PowerToysModule scope) => ModulePath[scope];\n\n        public string GetWindowsApplicationDriverUrl() => WindowsApplicationDriverUrl;\n\n        public string GetModuleWindowName(PowerToysModule scope) => ModuleWindowName[scope];\n    }\n}\n"
      }
    ]
  },
  {
    "id": "b08b7ffa68b43140c62d2bc8da2495e3",
    "source": "github",
    "file_path": "src/common/UITestAutomation/SessionHelper.cs",
    "repository": "",
    "code": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Reflection;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing OpenQA.Selenium.Appium;\nusing OpenQA.Selenium.Appium.Windows;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// Nested class for test initialization.\n    /// </summary>\n    public class SessionHelper\n    {\n        // Default session path is PowerToys settings dashboard\n        private readonly string sessionPath = ModuleConfigData.Instance.GetModulePath(PowerToysModule.PowerToysSettings);\n\n        private readonly string runnerPath = ModuleConfigData.Instance.GetModulePath(PowerToysModule.Runner);\n\n        private string? locationPath;\n\n        private static WindowsDriver<WindowsElement>? root;\n\n        private WindowsDriver<WindowsElement>? Driver { get; set; }\n\n        private static Process? appDriver;\n        private Process? runner;\n\n        private PowerToysModule scope;\n\n        [UnconditionalSuppressMessage(\"SingleFile\", \"IL3000:Avoid accessing Assembly file path when publishing as a single file\", Justification = \"<Pending>\")]\n        public SessionHelper(PowerToysModule scope)\n        {\n            this.scope = scope;\n            this.sessionPath = ModuleConfigData.Instance.GetModulePath(scope);\n            this.locationPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);\n\n            CheckWinAppDriverAndRoot();\n\n            var runnerProcessInfo = new ProcessStartInfo\n            {\n                FileName = locationPath + this.runnerPath,\n                Verb = \"runas\",\n            };\n\n            if (scope == PowerToysModule.PowerToysSettings)\n            {\n                this.ExitExe(runnerProcessInfo.FileName);\n                this.runner = Process.Start(runnerProcessInfo);\n            }\n        }\n\n        /// <summary>\n        /// Initializes WinAppDriver And Root.\n        /// </summary>\n        public void CheckWinAppDriverAndRoot()\n        {\n            if (SessionHelper.root == null || SessionHelper.appDriver?.SessionId == null || SessionHelper.appDriver == null || SessionHelper.appDriver.HasExited)\n            {\n                this.StartWindowsAppDriverApp();\n                var desktopCapabilities = new AppiumOptions();\n                desktopCapabilities.AddAdditionalCapability(\"app\", \"Root\");\n                SessionHelper.root = new WindowsDriver<WindowsElement>(new Uri(ModuleConfigData.Instance.GetWindowsApplicationDriverUrl()), desktopCapabilities);\n            }\n        }\n\n        /// <summary>\n        /// Initializes the test environment.\n        /// </summary>\n        /// <param name=\"scope\">The PowerToys module to start.</param>\n        public SessionHelper Init()\n        {\n            this.ExitExe(this.locationPath + this.sessionPath);\n            this.StartExe(this.locationPath + this.sessionPath);\n\n            Assert.IsNotNull(this.Driver, $\"Failed to initialize the test environment. Driver is null.\");\n\n            return this;\n        }\n\n        /// <summary>\n        /// Cleans up the test environment.\n        /// </summary>\n        public void Cleanup()\n        {\n            ExitScopeExe();\n            try\n            {\n                if (this.scope == PowerToysModule.PowerToysSettings)\n                {\n                    runner?.Kill();\n                    runner?.WaitForExit(); // Optional: Wait for the process to exit\n                }\n            }\n            catch (Exception ex)\n            {\n                // Handle exceptions if needed\n                Debug.WriteLine($\"Exception during Cleanup: {ex.Message}\");\n            }\n        }\n\n        /// <summary>\n        /// Exit a exe.\n        /// </summary>\n        /// <param name=\"appPath\">The path to the application executable.</param>\n        public void ExitExe(string appPath)\n        {\n            // Exit Exe\n            string exeName = Path.GetFileNameWithoutExtension(appPath);\n\n            Process[] processes = Process.GetProcessesByName(exeName);\n            foreach (Process process in processes)\n            {\n                try\n                {\n                    process.Kill();\n                    process.WaitForExit(); // Optional: Wait for the process to exit\n                }\n                catch (Exception ex)\n                {\n                    Assert.Fail($\"Failed to terminate process {process.ProcessName} (ID: {process.Id}): {ex.Message}\");\n                }\n            }\n        }\n\n        /// <summary>\n        /// Starts a new exe and takes control of it.\n        /// </summary>\n        /// <param name=\"appPath\">The path to the application executable.</param>\n        public void StartExe(string appPath)\n        {\n            var opts = new AppiumOptions();\n            opts.AddAdditionalCapability(\"app\", appPath);\n            this.Driver = NewWindowsDriver(opts);\n        }\n\n        /// <summary>\n        /// Starts a new exe and takes control of it.\n        /// </summary>\n        /// <param name=\"info\">The path to the application executable.</param>\n        private WindowsDriver<WindowsElement> NewWindowsDriver(AppiumOptions info)\n        {\n            // Create driver with retry\n            var timeout = TimeSpan.FromMinutes(2);\n            var retryInterval = TimeSpan.FromSeconds(5);\n            DateTime startTime = DateTime.Now;\n\n            while (true)\n            {\n                try\n                {\n                    var res = new WindowsDriver<WindowsElement>(new Uri(ModuleConfigData.Instance.GetWindowsApplicationDriverUrl()), info);\n                    return res;\n                }\n                catch (Exception)\n                {\n                    if (DateTime.Now - startTime > timeout)\n                    {\n                        throw;\n                    }\n\n                    Task.Delay(retryInterval).Wait();\n                    CheckWinAppDriverAndRoot();\n                }\n            }\n        }\n\n        /// <summary>\n        /// Exit now exe.\n        /// </summary>\n        public void ExitScopeExe()\n        {\n            ExitExe(sessionPath);\n        }\n\n        /// <summary>\n        /// Restarts now exe and takes control of it.\n        /// </summary>\n        public void RestartScopeExe()\n        {\n            ExitScopeExe();\n            StartExe(locationPath + sessionPath);\n        }\n\n        public WindowsDriver<WindowsElement> GetRoot()\n        {\n            return SessionHelper.root!;\n        }\n\n        public WindowsDriver<WindowsElement> GetDriver()\n        {\n            Assert.IsNotNull(this.Driver, $\"Failed to get driver. Driver is null.\");\n            return this.Driver;\n        }\n\n        private void StartWindowsAppDriverApp()\n        {\n            var winAppDriverProcessInfo = new ProcessStartInfo\n            {\n                FileName = \"C:\\\\Program Files (x86)\\\\Windows Application Driver\\\\WinAppDriver.exe\",\n                Verb = \"runas\",\n            };\n\n            this.ExitExe(winAppDriverProcessInfo.FileName);\n            SessionHelper.appDriver = Process.Start(winAppDriverProcessInfo);\n        }\n    }\n}\n",
    "patterns": [
      "Uses Generics",
      "Uses Pattern Matching",
      "Uses Nullable Reference Types"
    ],
    "timestamp": "2025-06-24T22:15:48.719402",
    "quality_score": 0.8000000000000002,
    "training_prompts": [
      {
        "instruction": "SessionHelper 클래스와 유사한 구조의 C# 클래스를 작성해주세요.",
        "context": "다음 패턴을 사용해주세요: Uses Generics, Uses Pattern Matching, Uses Nullable Reference Types",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Reflection;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing OpenQA.Selenium.Appium;\nusing OpenQA.Selenium.Appium.Windows;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// Nested class for test initialization.\n    /// </summary>\n    public class SessionHelper\n    {\n        // Default session path is PowerToys settings dashboard\n        private readonly string sessionPath = ModuleConfigData.Instance.GetModulePath(PowerToysModule.PowerToysSettings);\n\n        private readonly string runnerPath = ModuleConfigData.Instance.GetModulePath(PowerToysModule.Runner);\n\n        private string? locationPath;\n\n        private static WindowsDriver<WindowsElement>? root;\n\n        private WindowsDriver<WindowsElement>? Driver { get; set; }\n\n        private static Process? appDriver;\n        private Process? runner;\n\n        private PowerToysModule scope;\n\n        [UnconditionalSuppressMessage(\"SingleFile\", \"IL3000:Avoid accessing Assembly file path when publishing as a single file\", Justification = \"<Pending>\")]\n        public SessionHelper(PowerToysModule scope)\n        {\n            this.scope = scope;\n            this.sessionPath = ModuleConfigData.Instance.GetModulePath(scope);\n            this.locationPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);\n\n            CheckWinAppDriverAndRoot();\n\n            var runnerProcessInfo = new ProcessStartInfo\n            {\n                FileName = locationPath + this.runnerPath,\n                Verb = \"runas\",\n            };\n\n            if (scope == PowerToysModule.PowerToysSettings)\n            {\n                this.ExitExe(runnerProcessInfo.FileName);\n                this.runner = Process.Start(runnerProcessInfo);\n            }\n        }\n\n        /// <summary>\n        /// Initializes WinAppDriver And Root.\n        /// </summary>\n        public void CheckWinAppDriverAndRoot()\n        {\n            if (SessionHelper.root == null || SessionHelper.appDriver?.SessionId == null || SessionHelper.appDriver == null || SessionHelper.appDriver.HasExited)\n            {\n                this.StartWindowsAppDriverApp();\n                var desktopCapabilities = new AppiumOptions();\n                desktopCapabilities.AddAdditionalCapability(\"app\", \"Root\");\n                SessionHelper.root = new WindowsDriver<WindowsElement>(new Uri(ModuleConfigData.Instance.GetWindowsApplicationDriverUrl()), desktopCapabilities);\n            }\n        }\n\n        /// <summary>\n        /// Initializes the test environment.\n        /// </summary>\n        /// <param name=\"scope\">The PowerToys module to start.</param>\n        public SessionHelper Init()\n        {\n            this.ExitExe(this.locationPath + this.sessionPath);\n            this.StartExe(this.locationPath + this.sessionPath);\n\n            Assert.IsNotNull(this.Driver, $\"Failed to initialize the test environment. Driver is null.\");\n\n            return this;\n        }\n\n        /// <summary>\n        /// Cleans up the test environment.\n        /// </summary>\n        public void Cleanup()\n        {\n            ExitScopeExe();\n            try\n            {\n                if (this.scope == PowerToysModule.PowerToysSettings)\n                {\n                    runner?.Kill();\n                    runner?.WaitForExit(); // Optional: Wait for the process to exit\n                }\n            }\n            catch (Exception ex)\n            {\n                // Handle exceptions if needed\n                Debug.WriteLine($\"Exception during Cleanup: {ex.Message}\");\n            }\n        }\n\n        /// <summary>\n        /// Exit a exe.\n        /// </summary>\n        /// <param name=\"appPath\">The path to the application executable.</param>\n        public void ExitExe(string appPath)\n        {\n            // Exit Exe\n            string exeName = Path.GetFileNameWithoutExtension(appPath);\n\n            Process[] processes = Process.GetProcessesByName(exeName);\n            foreach (Process process in processes)\n            {\n                try\n                {\n                    process.Kill();\n                    process.WaitForExit(); // Optional: Wait for the process to exit\n                }\n                catch (Exception ex)\n                {\n                    Assert.Fail($\"Failed to terminate process {process.ProcessName} (ID: {process.Id}): {ex.Message}\");\n                }\n            }\n        }\n\n        /// <summary>\n        /// Starts a new exe and takes control of it.\n        /// </summary>\n        /// <param name=\"appPath\">The path to the application executable.</param>\n        public void StartExe(string appPath)\n        {\n            var opts = new AppiumOptions();\n            opts.AddAdditionalCapability(\"app\", appPath);\n            this.Driver = NewWindowsDriver(opts);\n        }\n\n        /// <summary>\n        /// Starts a new exe and takes control of it.\n        /// </summary>\n        /// <param name=\"info\">The path to the application executable.</param>\n        private WindowsDriver<WindowsElement> NewWindowsDriver(AppiumOptions info)\n        {\n            // Create driver with retry\n            var timeout = TimeSpan.FromMinutes(2);\n            var retryInterval = TimeSpan.FromSeconds(5);\n            DateTime startTime = DateTime.Now;\n\n            while (true)\n            {\n                try\n                {\n                    var res = new WindowsDriver<WindowsElement>(new Uri(ModuleConfigData.Instance.GetWindowsApplicationDriverUrl()), info);\n                    return res;\n                }\n                catch (Exception)\n                {\n                    if (DateTime.Now - startTime > timeout)\n                    {\n                        throw;\n                    }\n\n                    Task.Delay(retryInterval).Wait();\n                    CheckWinAppDriverAndRoot();\n                }\n            }\n        }\n\n        /// <summary>\n        /// Exit now exe.\n        /// </summary>\n        public void ExitScopeExe()\n        {\n            ExitExe(sessionPath);\n        }\n\n        /// <summary>\n        /// Restarts now exe and takes control of it.\n        /// </summary>\n        public void RestartScopeExe()\n        {\n            ExitScopeExe();\n            StartExe(locationPath + sessionPath);\n        }\n\n        public WindowsDriver<WindowsElement> GetRoot()\n        {\n            return SessionHelper.root!;\n        }\n\n        public WindowsDriver<WindowsElement> GetDriver()\n        {\n            Assert.IsNotNull(this.Driver, $\"Failed to get driver. Driver is null.\");\n            return this.Driver;\n        }\n\n        private void StartWindowsAppDriverApp()\n        {\n            var winAppDriverProcessInfo = new ProcessStartInfo\n            {\n                FileName = \"C:\\\\Program Files (x86)\\\\Windows Application Driver\\\\WinAppDriver.exe\",\n                Verb = \"runas\",\n            };\n\n            this.ExitExe(winAppDriverProcessInfo.FileName);\n            SessionHelper.appDriver = Process.Start(winAppDriverProcessInfo);\n        }\n    }\n}\n"
      },
      {
        "instruction": "void 반환 타입의 CheckWinAppDriverAndRoot 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Reflection;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing OpenQA.Selenium.Appium;\nusing OpenQA.Selenium.Appium.Windows;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// Nested class for test initialization.\n    /// </summary>\n    public class SessionHelper\n    {\n        // Default session path is PowerToys settings dashboard\n        private readonly string sessionPath = ModuleConfigData.Instance.GetModulePath(PowerToysModule.PowerToysSettings);\n\n        private readonly string runnerPath = ModuleConfigData.Instance.GetModulePath(PowerToysModule.Runner);\n\n        private string? locationPath;\n\n        private static WindowsDriver<WindowsElement>? root;\n\n        private WindowsDriver<WindowsElement>? Driver { get; set; }\n\n        private static Process? appDriver;\n        private Process? runner;\n\n        private PowerToysModule scope;\n\n        [UnconditionalSuppressMessage(\"SingleFile\", \"IL3000:Avoid accessing Assembly file path when publishing as a single file\", Justification = \"<Pending>\")]\n        public SessionHelper(PowerToysModule scope)\n        {\n            this.scope = scope;\n            this.sessionPath = ModuleConfigData.Instance.GetModulePath(scope);\n            this.locationPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);\n\n            CheckWinAppDriverAndRoot();\n\n            var runnerProcessInfo = new ProcessStartInfo\n            {\n                FileName = locationPath + this.runnerPath,\n                Verb = \"runas\",\n            };\n\n            if (scope == PowerToysModule.PowerToysSettings)\n            {\n                this.ExitExe(runnerProcessInfo.FileName);\n                this.runner = Process.Start(runnerProcessInfo);\n            }\n        }\n\n        /// <summary>\n        /// Initializes WinAppDriver And Root.\n        /// </summary>\n        public void CheckWinAppDriverAndRoot()\n        {\n            if (SessionHelper.root == null || SessionHelper.appDriver?.SessionId == null || SessionHelper.appDriver == null || SessionHelper.appDriver.HasExited)\n            {\n                this.StartWindowsAppDriverApp();\n                var desktopCapabilities = new AppiumOptions();\n                desktopCapabilities.AddAdditionalCapability(\"app\", \"Root\");\n                SessionHelper.root = new WindowsDriver<WindowsElement>(new Uri(ModuleConfigData.Instance.GetWindowsApplicationDriverUrl()), desktopCapabilities);\n            }\n        }\n\n        /// <summary>\n        /// Initializes the test environment.\n        /// </summary>\n        /// <param name=\"scope\">The PowerToys module to start.</param>\n        public SessionHelper Init()\n        {\n            this.ExitExe(this.locationPath + this.sessionPath);\n            this.StartExe(this.locationPath + this.sessionPath);\n\n            Assert.IsNotNull(this.Driver, $\"Failed to initialize the test environment. Driver is null.\");\n\n            return this;\n        }\n\n        /// <summary>\n        /// Cleans up the test environment.\n        /// </summary>\n        public void Cleanup()\n        {\n            ExitScopeExe();\n            try\n            {\n                if (this.scope == PowerToysModule.PowerToysSettings)\n                {\n                    runner?.Kill();\n                    runner?.WaitForExit(); // Optional: Wait for the process to exit\n                }\n            }\n            catch (Exception ex)\n            {\n                // Handle exceptions if needed\n                Debug.WriteLine($\"Exception during Cleanup: {ex.Message}\");\n            }\n        }\n\n        /// <summary>\n        /// Exit a exe.\n        /// </summary>\n        /// <param name=\"appPath\">The path to the application executable.</param>\n        public void ExitExe(string appPath)\n        {\n            // Exit Exe\n            string exeName = Path.GetFileNameWithoutExtension(appPath);\n\n            Process[] processes = Process.GetProcessesByName(exeName);\n            foreach (Process process in processes)\n            {\n                try\n                {\n                    process.Kill();\n                    process.WaitForExit(); // Optional: Wait for the process to exit\n                }\n                catch (Exception ex)\n                {\n                    Assert.Fail($\"Failed to terminate process {process.ProcessName} (ID: {process.Id}): {ex.Message}\");\n                }\n            }\n        }\n\n        /// <summary>\n        /// Starts a new exe and takes control of it.\n        /// </summary>\n        /// <param name=\"appPath\">The path to the application executable.</param>\n        public void StartExe(string appPath)\n        {\n            var opts = new AppiumOptions();\n            opts.AddAdditionalCapability(\"app\", appPath);\n            this.Driver = NewWindowsDriver(opts);\n        }\n\n        /// <summary>\n        /// Starts a new exe and takes control of it.\n        /// </summary>\n        /// <param name=\"info\">The path to the application executable.</param>\n        private WindowsDriver<WindowsElement> NewWindowsDriver(AppiumOptions info)\n        {\n            // Create driver with retry\n            var timeout = TimeSpan.FromMinutes(2);\n            var retryInterval = TimeSpan.FromSeconds(5);\n            DateTime startTime = DateTime.Now;\n\n            while (true)\n            {\n                try\n                {\n                    var res = new WindowsDriver<WindowsElement>(new Uri(ModuleConfigData.Instance.GetWindowsApplicationDriverUrl()), info);\n                    return res;\n                }\n                catch (Exception)\n                {\n                    if (DateTime.Now - startTime > timeout)\n                    {\n                        throw;\n                    }\n\n                    Task.Delay(retryInterval).Wait();\n                    CheckWinAppDriverAndRoot();\n                }\n            }\n        }\n\n        /// <summary>\n        /// Exit now exe.\n        /// </summary>\n        public void ExitScopeExe()\n        {\n            ExitExe(sessionPath);\n        }\n\n        /// <summary>\n        /// Restarts now exe and takes control of it.\n        /// </summary>\n        public void RestartScopeExe()\n        {\n            ExitScopeExe();\n            StartExe(locationPath + sessionPath);\n        }\n\n        public WindowsDriver<WindowsElement> GetRoot()\n        {\n            return SessionHelper.root!;\n        }\n\n        public WindowsDriver<WindowsElement> GetDriver()\n        {\n            Assert.IsNotNull(this.Driver, $\"Failed to get driver. Driver is null.\");\n            return this.Driver;\n        }\n\n        private void StartWindowsAppDriverApp()\n        {\n            var winAppDriverProcessInfo = new ProcessStartInfo\n            {\n                FileName = \"C:\\\\Program Files (x86)\\\\Windows Application Driver\\\\WinAppDriver.exe\",\n                Verb = \"runas\",\n            };\n\n            this.ExitExe(winAppDriverProcessInfo.FileName);\n            SessionHelper.appDriver = Process.Start(winAppDriverProcessInfo);\n        }\n    }\n}\n"
      },
      {
        "instruction": "SessionHelper 반환 타입의 Init 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Reflection;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing OpenQA.Selenium.Appium;\nusing OpenQA.Selenium.Appium.Windows;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// Nested class for test initialization.\n    /// </summary>\n    public class SessionHelper\n    {\n        // Default session path is PowerToys settings dashboard\n        private readonly string sessionPath = ModuleConfigData.Instance.GetModulePath(PowerToysModule.PowerToysSettings);\n\n        private readonly string runnerPath = ModuleConfigData.Instance.GetModulePath(PowerToysModule.Runner);\n\n        private string? locationPath;\n\n        private static WindowsDriver<WindowsElement>? root;\n\n        private WindowsDriver<WindowsElement>? Driver { get; set; }\n\n        private static Process? appDriver;\n        private Process? runner;\n\n        private PowerToysModule scope;\n\n        [UnconditionalSuppressMessage(\"SingleFile\", \"IL3000:Avoid accessing Assembly file path when publishing as a single file\", Justification = \"<Pending>\")]\n        public SessionHelper(PowerToysModule scope)\n        {\n            this.scope = scope;\n            this.sessionPath = ModuleConfigData.Instance.GetModulePath(scope);\n            this.locationPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);\n\n            CheckWinAppDriverAndRoot();\n\n            var runnerProcessInfo = new ProcessStartInfo\n            {\n                FileName = locationPath + this.runnerPath,\n                Verb = \"runas\",\n            };\n\n            if (scope == PowerToysModule.PowerToysSettings)\n            {\n                this.ExitExe(runnerProcessInfo.FileName);\n                this.runner = Process.Start(runnerProcessInfo);\n            }\n        }\n\n        /// <summary>\n        /// Initializes WinAppDriver And Root.\n        /// </summary>\n        public void CheckWinAppDriverAndRoot()\n        {\n            if (SessionHelper.root == null || SessionHelper.appDriver?.SessionId == null || SessionHelper.appDriver == null || SessionHelper.appDriver.HasExited)\n            {\n                this.StartWindowsAppDriverApp();\n                var desktopCapabilities = new AppiumOptions();\n                desktopCapabilities.AddAdditionalCapability(\"app\", \"Root\");\n                SessionHelper.root = new WindowsDriver<WindowsElement>(new Uri(ModuleConfigData.Instance.GetWindowsApplicationDriverUrl()), desktopCapabilities);\n            }\n        }\n\n        /// <summary>\n        /// Initializes the test environment.\n        /// </summary>\n        /// <param name=\"scope\">The PowerToys module to start.</param>\n        public SessionHelper Init()\n        {\n            this.ExitExe(this.locationPath + this.sessionPath);\n            this.StartExe(this.locationPath + this.sessionPath);\n\n            Assert.IsNotNull(this.Driver, $\"Failed to initialize the test environment. Driver is null.\");\n\n            return this;\n        }\n\n        /// <summary>\n        /// Cleans up the test environment.\n        /// </summary>\n        public void Cleanup()\n        {\n            ExitScopeExe();\n            try\n            {\n                if (this.scope == PowerToysModule.PowerToysSettings)\n                {\n                    runner?.Kill();\n                    runner?.WaitForExit(); // Optional: Wait for the process to exit\n                }\n            }\n            catch (Exception ex)\n            {\n                // Handle exceptions if needed\n                Debug.WriteLine($\"Exception during Cleanup: {ex.Message}\");\n            }\n        }\n\n        /// <summary>\n        /// Exit a exe.\n        /// </summary>\n        /// <param name=\"appPath\">The path to the application executable.</param>\n        public void ExitExe(string appPath)\n        {\n            // Exit Exe\n            string exeName = Path.GetFileNameWithoutExtension(appPath);\n\n            Process[] processes = Process.GetProcessesByName(exeName);\n            foreach (Process process in processes)\n            {\n                try\n                {\n                    process.Kill();\n                    process.WaitForExit(); // Optional: Wait for the process to exit\n                }\n                catch (Exception ex)\n                {\n                    Assert.Fail($\"Failed to terminate process {process.ProcessName} (ID: {process.Id}): {ex.Message}\");\n                }\n            }\n        }\n\n        /// <summary>\n        /// Starts a new exe and takes control of it.\n        /// </summary>\n        /// <param name=\"appPath\">The path to the application executable.</param>\n        public void StartExe(string appPath)\n        {\n            var opts = new AppiumOptions();\n            opts.AddAdditionalCapability(\"app\", appPath);\n            this.Driver = NewWindowsDriver(opts);\n        }\n\n        /// <summary>\n        /// Starts a new exe and takes control of it.\n        /// </summary>\n        /// <param name=\"info\">The path to the application executable.</param>\n        private WindowsDriver<WindowsElement> NewWindowsDriver(AppiumOptions info)\n        {\n            // Create driver with retry\n            var timeout = TimeSpan.FromMinutes(2);\n            var retryInterval = TimeSpan.FromSeconds(5);\n            DateTime startTime = DateTime.Now;\n\n            while (true)\n            {\n                try\n                {\n                    var res = new WindowsDriver<WindowsElement>(new Uri(ModuleConfigData.Instance.GetWindowsApplicationDriverUrl()), info);\n                    return res;\n                }\n                catch (Exception)\n                {\n                    if (DateTime.Now - startTime > timeout)\n                    {\n                        throw;\n                    }\n\n                    Task.Delay(retryInterval).Wait();\n                    CheckWinAppDriverAndRoot();\n                }\n            }\n        }\n\n        /// <summary>\n        /// Exit now exe.\n        /// </summary>\n        public void ExitScopeExe()\n        {\n            ExitExe(sessionPath);\n        }\n\n        /// <summary>\n        /// Restarts now exe and takes control of it.\n        /// </summary>\n        public void RestartScopeExe()\n        {\n            ExitScopeExe();\n            StartExe(locationPath + sessionPath);\n        }\n\n        public WindowsDriver<WindowsElement> GetRoot()\n        {\n            return SessionHelper.root!;\n        }\n\n        public WindowsDriver<WindowsElement> GetDriver()\n        {\n            Assert.IsNotNull(this.Driver, $\"Failed to get driver. Driver is null.\");\n            return this.Driver;\n        }\n\n        private void StartWindowsAppDriverApp()\n        {\n            var winAppDriverProcessInfo = new ProcessStartInfo\n            {\n                FileName = \"C:\\\\Program Files (x86)\\\\Windows Application Driver\\\\WinAppDriver.exe\",\n                Verb = \"runas\",\n            };\n\n            this.ExitExe(winAppDriverProcessInfo.FileName);\n            SessionHelper.appDriver = Process.Start(winAppDriverProcessInfo);\n        }\n    }\n}\n"
      },
      {
        "instruction": "void 반환 타입의 Cleanup 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Reflection;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing OpenQA.Selenium.Appium;\nusing OpenQA.Selenium.Appium.Windows;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// Nested class for test initialization.\n    /// </summary>\n    public class SessionHelper\n    {\n        // Default session path is PowerToys settings dashboard\n        private readonly string sessionPath = ModuleConfigData.Instance.GetModulePath(PowerToysModule.PowerToysSettings);\n\n        private readonly string runnerPath = ModuleConfigData.Instance.GetModulePath(PowerToysModule.Runner);\n\n        private string? locationPath;\n\n        private static WindowsDriver<WindowsElement>? root;\n\n        private WindowsDriver<WindowsElement>? Driver { get; set; }\n\n        private static Process? appDriver;\n        private Process? runner;\n\n        private PowerToysModule scope;\n\n        [UnconditionalSuppressMessage(\"SingleFile\", \"IL3000:Avoid accessing Assembly file path when publishing as a single file\", Justification = \"<Pending>\")]\n        public SessionHelper(PowerToysModule scope)\n        {\n            this.scope = scope;\n            this.sessionPath = ModuleConfigData.Instance.GetModulePath(scope);\n            this.locationPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);\n\n            CheckWinAppDriverAndRoot();\n\n            var runnerProcessInfo = new ProcessStartInfo\n            {\n                FileName = locationPath + this.runnerPath,\n                Verb = \"runas\",\n            };\n\n            if (scope == PowerToysModule.PowerToysSettings)\n            {\n                this.ExitExe(runnerProcessInfo.FileName);\n                this.runner = Process.Start(runnerProcessInfo);\n            }\n        }\n\n        /// <summary>\n        /// Initializes WinAppDriver And Root.\n        /// </summary>\n        public void CheckWinAppDriverAndRoot()\n        {\n            if (SessionHelper.root == null || SessionHelper.appDriver?.SessionId == null || SessionHelper.appDriver == null || SessionHelper.appDriver.HasExited)\n            {\n                this.StartWindowsAppDriverApp();\n                var desktopCapabilities = new AppiumOptions();\n                desktopCapabilities.AddAdditionalCapability(\"app\", \"Root\");\n                SessionHelper.root = new WindowsDriver<WindowsElement>(new Uri(ModuleConfigData.Instance.GetWindowsApplicationDriverUrl()), desktopCapabilities);\n            }\n        }\n\n        /// <summary>\n        /// Initializes the test environment.\n        /// </summary>\n        /// <param name=\"scope\">The PowerToys module to start.</param>\n        public SessionHelper Init()\n        {\n            this.ExitExe(this.locationPath + this.sessionPath);\n            this.StartExe(this.locationPath + this.sessionPath);\n\n            Assert.IsNotNull(this.Driver, $\"Failed to initialize the test environment. Driver is null.\");\n\n            return this;\n        }\n\n        /// <summary>\n        /// Cleans up the test environment.\n        /// </summary>\n        public void Cleanup()\n        {\n            ExitScopeExe();\n            try\n            {\n                if (this.scope == PowerToysModule.PowerToysSettings)\n                {\n                    runner?.Kill();\n                    runner?.WaitForExit(); // Optional: Wait for the process to exit\n                }\n            }\n            catch (Exception ex)\n            {\n                // Handle exceptions if needed\n                Debug.WriteLine($\"Exception during Cleanup: {ex.Message}\");\n            }\n        }\n\n        /// <summary>\n        /// Exit a exe.\n        /// </summary>\n        /// <param name=\"appPath\">The path to the application executable.</param>\n        public void ExitExe(string appPath)\n        {\n            // Exit Exe\n            string exeName = Path.GetFileNameWithoutExtension(appPath);\n\n            Process[] processes = Process.GetProcessesByName(exeName);\n            foreach (Process process in processes)\n            {\n                try\n                {\n                    process.Kill();\n                    process.WaitForExit(); // Optional: Wait for the process to exit\n                }\n                catch (Exception ex)\n                {\n                    Assert.Fail($\"Failed to terminate process {process.ProcessName} (ID: {process.Id}): {ex.Message}\");\n                }\n            }\n        }\n\n        /// <summary>\n        /// Starts a new exe and takes control of it.\n        /// </summary>\n        /// <param name=\"appPath\">The path to the application executable.</param>\n        public void StartExe(string appPath)\n        {\n            var opts = new AppiumOptions();\n            opts.AddAdditionalCapability(\"app\", appPath);\n            this.Driver = NewWindowsDriver(opts);\n        }\n\n        /// <summary>\n        /// Starts a new exe and takes control of it.\n        /// </summary>\n        /// <param name=\"info\">The path to the application executable.</param>\n        private WindowsDriver<WindowsElement> NewWindowsDriver(AppiumOptions info)\n        {\n            // Create driver with retry\n            var timeout = TimeSpan.FromMinutes(2);\n            var retryInterval = TimeSpan.FromSeconds(5);\n            DateTime startTime = DateTime.Now;\n\n            while (true)\n            {\n                try\n                {\n                    var res = new WindowsDriver<WindowsElement>(new Uri(ModuleConfigData.Instance.GetWindowsApplicationDriverUrl()), info);\n                    return res;\n                }\n                catch (Exception)\n                {\n                    if (DateTime.Now - startTime > timeout)\n                    {\n                        throw;\n                    }\n\n                    Task.Delay(retryInterval).Wait();\n                    CheckWinAppDriverAndRoot();\n                }\n            }\n        }\n\n        /// <summary>\n        /// Exit now exe.\n        /// </summary>\n        public void ExitScopeExe()\n        {\n            ExitExe(sessionPath);\n        }\n\n        /// <summary>\n        /// Restarts now exe and takes control of it.\n        /// </summary>\n        public void RestartScopeExe()\n        {\n            ExitScopeExe();\n            StartExe(locationPath + sessionPath);\n        }\n\n        public WindowsDriver<WindowsElement> GetRoot()\n        {\n            return SessionHelper.root!;\n        }\n\n        public WindowsDriver<WindowsElement> GetDriver()\n        {\n            Assert.IsNotNull(this.Driver, $\"Failed to get driver. Driver is null.\");\n            return this.Driver;\n        }\n\n        private void StartWindowsAppDriverApp()\n        {\n            var winAppDriverProcessInfo = new ProcessStartInfo\n            {\n                FileName = \"C:\\\\Program Files (x86)\\\\Windows Application Driver\\\\WinAppDriver.exe\",\n                Verb = \"runas\",\n            };\n\n            this.ExitExe(winAppDriverProcessInfo.FileName);\n            SessionHelper.appDriver = Process.Start(winAppDriverProcessInfo);\n        }\n    }\n}\n"
      },
      {
        "instruction": "void 반환 타입의 ExitExe 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Reflection;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing OpenQA.Selenium.Appium;\nusing OpenQA.Selenium.Appium.Windows;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// Nested class for test initialization.\n    /// </summary>\n    public class SessionHelper\n    {\n        // Default session path is PowerToys settings dashboard\n        private readonly string sessionPath = ModuleConfigData.Instance.GetModulePath(PowerToysModule.PowerToysSettings);\n\n        private readonly string runnerPath = ModuleConfigData.Instance.GetModulePath(PowerToysModule.Runner);\n\n        private string? locationPath;\n\n        private static WindowsDriver<WindowsElement>? root;\n\n        private WindowsDriver<WindowsElement>? Driver { get; set; }\n\n        private static Process? appDriver;\n        private Process? runner;\n\n        private PowerToysModule scope;\n\n        [UnconditionalSuppressMessage(\"SingleFile\", \"IL3000:Avoid accessing Assembly file path when publishing as a single file\", Justification = \"<Pending>\")]\n        public SessionHelper(PowerToysModule scope)\n        {\n            this.scope = scope;\n            this.sessionPath = ModuleConfigData.Instance.GetModulePath(scope);\n            this.locationPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);\n\n            CheckWinAppDriverAndRoot();\n\n            var runnerProcessInfo = new ProcessStartInfo\n            {\n                FileName = locationPath + this.runnerPath,\n                Verb = \"runas\",\n            };\n\n            if (scope == PowerToysModule.PowerToysSettings)\n            {\n                this.ExitExe(runnerProcessInfo.FileName);\n                this.runner = Process.Start(runnerProcessInfo);\n            }\n        }\n\n        /// <summary>\n        /// Initializes WinAppDriver And Root.\n        /// </summary>\n        public void CheckWinAppDriverAndRoot()\n        {\n            if (SessionHelper.root == null || SessionHelper.appDriver?.SessionId == null || SessionHelper.appDriver == null || SessionHelper.appDriver.HasExited)\n            {\n                this.StartWindowsAppDriverApp();\n                var desktopCapabilities = new AppiumOptions();\n                desktopCapabilities.AddAdditionalCapability(\"app\", \"Root\");\n                SessionHelper.root = new WindowsDriver<WindowsElement>(new Uri(ModuleConfigData.Instance.GetWindowsApplicationDriverUrl()), desktopCapabilities);\n            }\n        }\n\n        /// <summary>\n        /// Initializes the test environment.\n        /// </summary>\n        /// <param name=\"scope\">The PowerToys module to start.</param>\n        public SessionHelper Init()\n        {\n            this.ExitExe(this.locationPath + this.sessionPath);\n            this.StartExe(this.locationPath + this.sessionPath);\n\n            Assert.IsNotNull(this.Driver, $\"Failed to initialize the test environment. Driver is null.\");\n\n            return this;\n        }\n\n        /// <summary>\n        /// Cleans up the test environment.\n        /// </summary>\n        public void Cleanup()\n        {\n            ExitScopeExe();\n            try\n            {\n                if (this.scope == PowerToysModule.PowerToysSettings)\n                {\n                    runner?.Kill();\n                    runner?.WaitForExit(); // Optional: Wait for the process to exit\n                }\n            }\n            catch (Exception ex)\n            {\n                // Handle exceptions if needed\n                Debug.WriteLine($\"Exception during Cleanup: {ex.Message}\");\n            }\n        }\n\n        /// <summary>\n        /// Exit a exe.\n        /// </summary>\n        /// <param name=\"appPath\">The path to the application executable.</param>\n        public void ExitExe(string appPath)\n        {\n            // Exit Exe\n            string exeName = Path.GetFileNameWithoutExtension(appPath);\n\n            Process[] processes = Process.GetProcessesByName(exeName);\n            foreach (Process process in processes)\n            {\n                try\n                {\n                    process.Kill();\n                    process.WaitForExit(); // Optional: Wait for the process to exit\n                }\n                catch (Exception ex)\n                {\n                    Assert.Fail($\"Failed to terminate process {process.ProcessName} (ID: {process.Id}): {ex.Message}\");\n                }\n            }\n        }\n\n        /// <summary>\n        /// Starts a new exe and takes control of it.\n        /// </summary>\n        /// <param name=\"appPath\">The path to the application executable.</param>\n        public void StartExe(string appPath)\n        {\n            var opts = new AppiumOptions();\n            opts.AddAdditionalCapability(\"app\", appPath);\n            this.Driver = NewWindowsDriver(opts);\n        }\n\n        /// <summary>\n        /// Starts a new exe and takes control of it.\n        /// </summary>\n        /// <param name=\"info\">The path to the application executable.</param>\n        private WindowsDriver<WindowsElement> NewWindowsDriver(AppiumOptions info)\n        {\n            // Create driver with retry\n            var timeout = TimeSpan.FromMinutes(2);\n            var retryInterval = TimeSpan.FromSeconds(5);\n            DateTime startTime = DateTime.Now;\n\n            while (true)\n            {\n                try\n                {\n                    var res = new WindowsDriver<WindowsElement>(new Uri(ModuleConfigData.Instance.GetWindowsApplicationDriverUrl()), info);\n                    return res;\n                }\n                catch (Exception)\n                {\n                    if (DateTime.Now - startTime > timeout)\n                    {\n                        throw;\n                    }\n\n                    Task.Delay(retryInterval).Wait();\n                    CheckWinAppDriverAndRoot();\n                }\n            }\n        }\n\n        /// <summary>\n        /// Exit now exe.\n        /// </summary>\n        public void ExitScopeExe()\n        {\n            ExitExe(sessionPath);\n        }\n\n        /// <summary>\n        /// Restarts now exe and takes control of it.\n        /// </summary>\n        public void RestartScopeExe()\n        {\n            ExitScopeExe();\n            StartExe(locationPath + sessionPath);\n        }\n\n        public WindowsDriver<WindowsElement> GetRoot()\n        {\n            return SessionHelper.root!;\n        }\n\n        public WindowsDriver<WindowsElement> GetDriver()\n        {\n            Assert.IsNotNull(this.Driver, $\"Failed to get driver. Driver is null.\");\n            return this.Driver;\n        }\n\n        private void StartWindowsAppDriverApp()\n        {\n            var winAppDriverProcessInfo = new ProcessStartInfo\n            {\n                FileName = \"C:\\\\Program Files (x86)\\\\Windows Application Driver\\\\WinAppDriver.exe\",\n                Verb = \"runas\",\n            };\n\n            this.ExitExe(winAppDriverProcessInfo.FileName);\n            SessionHelper.appDriver = Process.Start(winAppDriverProcessInfo);\n        }\n    }\n}\n"
      },
      {
        "instruction": "void 반환 타입의 StartExe 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Reflection;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing OpenQA.Selenium.Appium;\nusing OpenQA.Selenium.Appium.Windows;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// Nested class for test initialization.\n    /// </summary>\n    public class SessionHelper\n    {\n        // Default session path is PowerToys settings dashboard\n        private readonly string sessionPath = ModuleConfigData.Instance.GetModulePath(PowerToysModule.PowerToysSettings);\n\n        private readonly string runnerPath = ModuleConfigData.Instance.GetModulePath(PowerToysModule.Runner);\n\n        private string? locationPath;\n\n        private static WindowsDriver<WindowsElement>? root;\n\n        private WindowsDriver<WindowsElement>? Driver { get; set; }\n\n        private static Process? appDriver;\n        private Process? runner;\n\n        private PowerToysModule scope;\n\n        [UnconditionalSuppressMessage(\"SingleFile\", \"IL3000:Avoid accessing Assembly file path when publishing as a single file\", Justification = \"<Pending>\")]\n        public SessionHelper(PowerToysModule scope)\n        {\n            this.scope = scope;\n            this.sessionPath = ModuleConfigData.Instance.GetModulePath(scope);\n            this.locationPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);\n\n            CheckWinAppDriverAndRoot();\n\n            var runnerProcessInfo = new ProcessStartInfo\n            {\n                FileName = locationPath + this.runnerPath,\n                Verb = \"runas\",\n            };\n\n            if (scope == PowerToysModule.PowerToysSettings)\n            {\n                this.ExitExe(runnerProcessInfo.FileName);\n                this.runner = Process.Start(runnerProcessInfo);\n            }\n        }\n\n        /// <summary>\n        /// Initializes WinAppDriver And Root.\n        /// </summary>\n        public void CheckWinAppDriverAndRoot()\n        {\n            if (SessionHelper.root == null || SessionHelper.appDriver?.SessionId == null || SessionHelper.appDriver == null || SessionHelper.appDriver.HasExited)\n            {\n                this.StartWindowsAppDriverApp();\n                var desktopCapabilities = new AppiumOptions();\n                desktopCapabilities.AddAdditionalCapability(\"app\", \"Root\");\n                SessionHelper.root = new WindowsDriver<WindowsElement>(new Uri(ModuleConfigData.Instance.GetWindowsApplicationDriverUrl()), desktopCapabilities);\n            }\n        }\n\n        /// <summary>\n        /// Initializes the test environment.\n        /// </summary>\n        /// <param name=\"scope\">The PowerToys module to start.</param>\n        public SessionHelper Init()\n        {\n            this.ExitExe(this.locationPath + this.sessionPath);\n            this.StartExe(this.locationPath + this.sessionPath);\n\n            Assert.IsNotNull(this.Driver, $\"Failed to initialize the test environment. Driver is null.\");\n\n            return this;\n        }\n\n        /// <summary>\n        /// Cleans up the test environment.\n        /// </summary>\n        public void Cleanup()\n        {\n            ExitScopeExe();\n            try\n            {\n                if (this.scope == PowerToysModule.PowerToysSettings)\n                {\n                    runner?.Kill();\n                    runner?.WaitForExit(); // Optional: Wait for the process to exit\n                }\n            }\n            catch (Exception ex)\n            {\n                // Handle exceptions if needed\n                Debug.WriteLine($\"Exception during Cleanup: {ex.Message}\");\n            }\n        }\n\n        /// <summary>\n        /// Exit a exe.\n        /// </summary>\n        /// <param name=\"appPath\">The path to the application executable.</param>\n        public void ExitExe(string appPath)\n        {\n            // Exit Exe\n            string exeName = Path.GetFileNameWithoutExtension(appPath);\n\n            Process[] processes = Process.GetProcessesByName(exeName);\n            foreach (Process process in processes)\n            {\n                try\n                {\n                    process.Kill();\n                    process.WaitForExit(); // Optional: Wait for the process to exit\n                }\n                catch (Exception ex)\n                {\n                    Assert.Fail($\"Failed to terminate process {process.ProcessName} (ID: {process.Id}): {ex.Message}\");\n                }\n            }\n        }\n\n        /// <summary>\n        /// Starts a new exe and takes control of it.\n        /// </summary>\n        /// <param name=\"appPath\">The path to the application executable.</param>\n        public void StartExe(string appPath)\n        {\n            var opts = new AppiumOptions();\n            opts.AddAdditionalCapability(\"app\", appPath);\n            this.Driver = NewWindowsDriver(opts);\n        }\n\n        /// <summary>\n        /// Starts a new exe and takes control of it.\n        /// </summary>\n        /// <param name=\"info\">The path to the application executable.</param>\n        private WindowsDriver<WindowsElement> NewWindowsDriver(AppiumOptions info)\n        {\n            // Create driver with retry\n            var timeout = TimeSpan.FromMinutes(2);\n            var retryInterval = TimeSpan.FromSeconds(5);\n            DateTime startTime = DateTime.Now;\n\n            while (true)\n            {\n                try\n                {\n                    var res = new WindowsDriver<WindowsElement>(new Uri(ModuleConfigData.Instance.GetWindowsApplicationDriverUrl()), info);\n                    return res;\n                }\n                catch (Exception)\n                {\n                    if (DateTime.Now - startTime > timeout)\n                    {\n                        throw;\n                    }\n\n                    Task.Delay(retryInterval).Wait();\n                    CheckWinAppDriverAndRoot();\n                }\n            }\n        }\n\n        /// <summary>\n        /// Exit now exe.\n        /// </summary>\n        public void ExitScopeExe()\n        {\n            ExitExe(sessionPath);\n        }\n\n        /// <summary>\n        /// Restarts now exe and takes control of it.\n        /// </summary>\n        public void RestartScopeExe()\n        {\n            ExitScopeExe();\n            StartExe(locationPath + sessionPath);\n        }\n\n        public WindowsDriver<WindowsElement> GetRoot()\n        {\n            return SessionHelper.root!;\n        }\n\n        public WindowsDriver<WindowsElement> GetDriver()\n        {\n            Assert.IsNotNull(this.Driver, $\"Failed to get driver. Driver is null.\");\n            return this.Driver;\n        }\n\n        private void StartWindowsAppDriverApp()\n        {\n            var winAppDriverProcessInfo = new ProcessStartInfo\n            {\n                FileName = \"C:\\\\Program Files (x86)\\\\Windows Application Driver\\\\WinAppDriver.exe\",\n                Verb = \"runas\",\n            };\n\n            this.ExitExe(winAppDriverProcessInfo.FileName);\n            SessionHelper.appDriver = Process.Start(winAppDriverProcessInfo);\n        }\n    }\n}\n"
      },
      {
        "instruction": "Uses Generics 패턴을 사용하는 C# 코드를 작성해주세요.",
        "context": "프로덕션 환경에서 사용 가능한 수준으로 작성해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Reflection;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing OpenQA.Selenium.Appium;\nusing OpenQA.Selenium.Appium.Windows;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// Nested class for test initialization.\n    /// </summary>\n    public class SessionHelper\n    {\n        // Default session path is PowerToys settings dashboard\n        private readonly string sessionPath = ModuleConfigData.Instance.GetModulePath(PowerToysModule.PowerToysSettings);\n\n        private readonly string runnerPath = ModuleConfigData.Instance.GetModulePath(PowerToysModule.Runner);\n\n        private string? locationPath;\n\n        private static WindowsDriver<WindowsElement>? root;\n\n        private WindowsDriver<WindowsElement>? Driver { get; set; }\n\n        private static Process? appDriver;\n        private Process? runner;\n\n        private PowerToysModule scope;\n\n        [UnconditionalSuppressMessage(\"SingleFile\", \"IL3000:Avoid accessing Assembly file path when publishing as a single file\", Justification = \"<Pending>\")]\n        public SessionHelper(PowerToysModule scope)\n        {\n            this.scope = scope;\n            this.sessionPath = ModuleConfigData.Instance.GetModulePath(scope);\n            this.locationPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);\n\n            CheckWinAppDriverAndRoot();\n\n            var runnerProcessInfo = new ProcessStartInfo\n            {\n                FileName = locationPath + this.runnerPath,\n                Verb = \"runas\",\n            };\n\n            if (scope == PowerToysModule.PowerToysSettings)\n            {\n                this.ExitExe(runnerProcessInfo.FileName);\n                this.runner = Process.Start(runnerProcessInfo);\n            }\n        }\n\n        /// <summary>\n        /// Initializes WinAppDriver And Root.\n        /// </summary>\n        public void CheckWinAppDriverAndRoot()\n        {\n            if (SessionHelper.root == null || SessionHelper.appDriver?.SessionId == null || SessionHelper.appDriver == null || SessionHelper.appDriver.HasExited)\n            {\n                this.StartWindowsAppDriverApp();\n                var desktopCapabilities = new AppiumOptions();\n                desktopCapabilities.AddAdditionalCapability(\"app\", \"Root\");\n                SessionHelper.root = new WindowsDriver<WindowsElement>(new Uri(ModuleConfigData.Instance.GetWindowsApplicationDriverUrl()), desktopCapabilities);\n            }\n        }\n\n        /// <summary>\n        /// Initializes the test environment.\n        /// </summary>\n        /// <param name=\"scope\">The PowerToys module to start.</param>\n        public SessionHelper Init()\n        {\n            this.ExitExe(this.locationPath + this.sessionPath);\n            this.StartExe(this.locationPath + this.sessionPath);\n\n            Assert.IsNotNull(this.Driver, $\"Failed to initialize the test environment. Driver is null.\");\n\n            return this;\n        }\n\n        /// <summary>\n        /// Cleans up the test environment.\n        /// </summary>\n        public void Cleanup()\n        {\n            ExitScopeExe();\n            try\n            {\n                if (this.scope == PowerToysModule.PowerToysSettings)\n                {\n                    runner?.Kill();\n                    runner?.WaitForExit(); // Optional: Wait for the process to exit\n                }\n            }\n            catch (Exception ex)\n            {\n                // Handle exceptions if needed\n                Debug.WriteLine($\"Exception during Cleanup: {ex.Message}\");\n            }\n        }\n\n        /// <summary>\n        /// Exit a exe.\n        /// </summary>\n        /// <param name=\"appPath\">The path to the application executable.</param>\n        public void ExitExe(string appPath)\n        {\n            // Exit Exe\n            string exeName = Path.GetFileNameWithoutExtension(appPath);\n\n            Process[] processes = Process.GetProcessesByName(exeName);\n            foreach (Process process in processes)\n            {\n                try\n                {\n                    process.Kill();\n                    process.WaitForExit(); // Optional: Wait for the process to exit\n                }\n                catch (Exception ex)\n                {\n                    Assert.Fail($\"Failed to terminate process {process.ProcessName} (ID: {process.Id}): {ex.Message}\");\n                }\n            }\n        }\n\n        /// <summary>\n        /// Starts a new exe and takes control of it.\n        /// </summary>\n        /// <param name=\"appPath\">The path to the application executable.</param>\n        public void StartExe(string appPath)\n        {\n            var opts = new AppiumOptions();\n            opts.AddAdditionalCapability(\"app\", appPath);\n            this.Driver = NewWindowsDriver(opts);\n        }\n\n        /// <summary>\n        /// Starts a new exe and takes control of it.\n        /// </summary>\n        /// <param name=\"info\">The path to the application executable.</param>\n        private WindowsDriver<WindowsElement> NewWindowsDriver(AppiumOptions info)\n        {\n            // Create driver with retry\n            var timeout = TimeSpan.FromMinutes(2);\n            var retryInterval = TimeSpan.FromSeconds(5);\n            DateTime startTime = DateTime.Now;\n\n            while (true)\n            {\n                try\n                {\n                    var res = new WindowsDriver<WindowsElement>(new Uri(ModuleConfigData.Instance.GetWindowsApplicationDriverUrl()), info);\n                    return res;\n                }\n                catch (Exception)\n                {\n                    if (DateTime.Now - startTime > timeout)\n                    {\n                        throw;\n                    }\n\n                    Task.Delay(retryInterval).Wait();\n                    CheckWinAppDriverAndRoot();\n                }\n            }\n        }\n\n        /// <summary>\n        /// Exit now exe.\n        /// </summary>\n        public void ExitScopeExe()\n        {\n            ExitExe(sessionPath);\n        }\n\n        /// <summary>\n        /// Restarts now exe and takes control of it.\n        /// </summary>\n        public void RestartScopeExe()\n        {\n            ExitScopeExe();\n            StartExe(locationPath + sessionPath);\n        }\n\n        public WindowsDriver<WindowsElement> GetRoot()\n        {\n            return SessionHelper.root!;\n        }\n\n        public WindowsDriver<WindowsElement> GetDriver()\n        {\n            Assert.IsNotNull(this.Driver, $\"Failed to get driver. Driver is null.\");\n            return this.Driver;\n        }\n\n        private void StartWindowsAppDriverApp()\n        {\n            var winAppDriverProcessInfo = new ProcessStartInfo\n            {\n                FileName = \"C:\\\\Program Files (x86)\\\\Windows Application Driver\\\\WinAppDriver.exe\",\n                Verb = \"runas\",\n            };\n\n            this.ExitExe(winAppDriverProcessInfo.FileName);\n            SessionHelper.appDriver = Process.Start(winAppDriverProcessInfo);\n        }\n    }\n}\n"
      }
    ]
  },
  {
    "id": "563c3fabc5477044a3ec6aeb91986afe",
    "source": "github",
    "file_path": "src/common/UITestAutomation/UITestBase.cs",
    "repository": "",
    "code": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System.Collections.ObjectModel;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Reflection;\nusing System.Runtime.InteropServices;\nusing System.Xml.Linq;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing OpenQA.Selenium;\nusing OpenQA.Selenium.Appium;\nusing OpenQA.Selenium.Appium.Windows;\nusing Windows.Devices.Display.Core;\nusing Windows.Foundation.Metadata;\nusing static Microsoft.PowerToys.UITest.UITestBase.NativeMethods;\nusing static Microsoft.PowerToys.UITest.WindowHelper;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// Base class that should be inherited by all Test Classes.\n    /// </summary>\n    [TestClass]\n    public class UITestBase : IDisposable\n    {\n        public required TestContext TestContext { get; set; }\n\n        public required Session Session { get; set; }\n\n        public bool IsInPipeline { get; }\n\n        public static MonitorInfoData.ParamsWrapper MonitorInfoData { get; set; } = new MonitorInfoData.ParamsWrapper() { Monitors = new List<MonitorInfoData.MonitorInfoDataWrapper>() };\n\n        private readonly PowerToysModule scope;\n        private readonly WindowSize size;\n        private SessionHelper? sessionHelper;\n        private System.Threading.Timer? screenshotTimer;\n        private string? screenshotDirectory;\n\n        public UITestBase(PowerToysModule scope = PowerToysModule.PowerToysSettings, WindowSize size = WindowSize.UnSpecified)\n        {\n            this.IsInPipeline = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"platform\"));\n            Console.WriteLine($\"Running tests on platform: {Environment.GetEnvironmentVariable(\"platform\")}\");\n            if (IsInPipeline)\n            {\n                NativeMethods.ChangeDisplayResolution(1920, 1080);\n                NativeMethods.GetMonitorInfo();\n\n                // Escape Popups before starting\n                System.Windows.Forms.SendKeys.SendWait(\"{ESC}\");\n            }\n\n            this.scope = scope;\n            this.size = size;\n        }\n\n        /// <summary>\n        /// Initializes the test.\n        /// </summary>\n        [TestInitialize]\n        public void TestInit()\n        {\n            CloseOtherApplications();\n            if (IsInPipeline)\n            {\n                screenshotDirectory = Path.Combine(this.TestContext.TestResultsDirectory ?? string.Empty, \"UITestScreenshots_\" + Guid.NewGuid().ToString());\n                Directory.CreateDirectory(screenshotDirectory);\n\n                // Take screenshot every 1 second\n                screenshotTimer = new System.Threading.Timer(ScreenCapture.TimerCallback, screenshotDirectory, TimeSpan.Zero, TimeSpan.FromMilliseconds(1000));\n\n                // Escape Popups before starting\n                System.Windows.Forms.SendKeys.SendWait(\"{ESC}\");\n            }\n\n            this.sessionHelper = new SessionHelper(scope).Init();\n            this.Session = new Session(this.sessionHelper.GetRoot(), this.sessionHelper.GetDriver(), scope, size);\n\n            if (this.scope == PowerToysModule.PowerToysSettings)\n            {\n                // close Debug warning dialog if any\n                // Such debug warning dialog seems only appear in PowerToys Settings\n                if (this.FindAll(\"DEBUG\").Count > 0)\n                {\n                    this.Find(\"DEBUG\").Find<Button>(\"Close\").Click();\n                }\n            }\n        }\n\n        /// <summary>\n        /// Cleanups the test.\n        /// </summary>\n        [TestCleanup]\n        public void TestCleanup()\n        {\n            if (IsInPipeline)\n            {\n                screenshotTimer?.Change(Timeout.Infinite, Timeout.Infinite);\n                Dispose();\n                if (TestContext.CurrentTestOutcome is UnitTestOutcome.Failed\n                    or UnitTestOutcome.Error\n                    or UnitTestOutcome.Unknown)\n                {\n                    Task.Delay(1000).Wait();\n                    AddScreenShotsToTestResultsDirectory();\n                }\n            }\n\n            this.Session.Cleanup();\n            this.sessionHelper!.Cleanup();\n        }\n\n        public void Dispose()\n        {\n            screenshotTimer?.Dispose();\n            GC.SuppressFinalize(this);\n        }\n\n        /// <summary>\n        /// Finds an element by selector.\n        /// Shortcut for this.Session.Find<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected T Find<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Find<T>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(name, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected T Find<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Find<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected Element Find(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Find(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected Element Find(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Find(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Has only one Element or its derived class by selector.\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.FindAll<T>(by, timeoutMS, global).Count == 1;\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.HasOne<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<T>(name, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.HasOne<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.HasOne<Element>(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(by, timeoutMS, global).Count >= 1;\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Has<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<T>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Has<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Has<Element>(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the elements, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<T> FindAll<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the elements, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<T> FindAll<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<Element> FindAll(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.FindAll<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<Element> FindAll(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.FindAll<Element>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Scrolls the page\n        /// </summary>\n        /// <param name=\"scrollCount\">The number of scroll attempts.</param>\n        /// <param name=\"direction\">The direction to scroll.</param>\n        /// <param name=\"msPreAction\">Pre-action delay in milliseconds.</param>\n        /// <param name=\"msPostAction\">Post-action delay in milliseconds.</param>\n        public void Scroll(int scrollCount = 5, string direction = \"Up\", int msPreAction = 500, int msPostAction = 500)\n        {\n            MouseActionType mouseAction = direction == \"Up\" ? MouseActionType.ScrollUp : MouseActionType.ScrollDown;\n            for (int i = 0; i < scrollCount; i++)\n            {\n                Session.PerformMouseAction(mouseAction, msPreAction, msPostAction); // Ensure settings are visible\n            }\n        }\n\n        /// <summary>\n        /// Captures the last screenshot when the test fails.\n        /// </summary>\n        protected void CaptureLastScreenshot()\n        {\n            // Implement your screenshot capture logic here\n            // For example, save a screenshot to a file and return the file path\n            string screenshotPath = Path.Combine(this.TestContext.TestResultsDirectory ?? string.Empty, \"last_screenshot.png\");\n\n            this.Session.Root.GetScreenshot().SaveAsFile(screenshotPath, ScreenshotImageFormat.Png);\n\n            // Save screenshot to screenshotPath & upload to test attachment\n            this.TestContext.AddResultFile(screenshotPath);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public Color GetPixelColor(int x, int y)\n        {\n            return WindowHelper.GetPixelColor(x, y);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates as a string.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public string GetPixelColorString(int x, int y)\n        {\n            return WindowHelper.GetPixelColorString(x, y);\n        }\n\n        /// <summary>\n        /// Gets the size of the display.\n        /// </summary>\n        /// <returns>\n        /// A tuple containing the width and height of the display.\n        /// </returns\n        public Tuple<int, int> GetDisplaySize()\n        {\n            return WindowHelper.GetDisplaySize();\n        }\n\n        /// <summary>\n        /// Sends a combination of keys.\n        /// </summary>\n        /// <param name=\"keys\">The keys to send.</param>\n        public void SendKeys(params Key[] keys)\n        {\n            this.Session.SendKeys(keys);\n        }\n\n        /// <summary>\n        /// Sends a sequence of keys.\n        /// </summary>\n        /// <param name=\"keys\">An array of keys to send.</param>\n        public void SendKeySequence(params Key[] keys)\n        {\n            this.Session.SendKeySequence(keys);\n        }\n\n        /// <summary>\n        /// Gets the current position of the mouse cursor as a tuple.\n        /// </summary>\n        /// <returns>A tuple containing the X and Y coordinates of the cursor.</returns>\n        public Tuple<int, int> GetMousePosition()\n        {\n            return this.Session.GetMousePosition();\n        }\n\n        /// <summary>\n        /// Gets the screen center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public (int CenterX, int CenterY) GetScreenCenter()\n        {\n            return WindowHelper.GetScreenCenter();\n        }\n\n        public bool IsWindowOpen(string windowName)\n        {\n            return WindowHelper.IsWindowOpen(windowName);\n        }\n\n        /// <summary>\n        /// Moves the mouse cursor to the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The new x-coordinate of the cursor.</param>\n        /// <param name=\"y\">The new y-coordinate of the cursor.</param\n        public void MoveMouseTo(int x, int y)\n        {\n            this.Session.MoveMouseTo(x, y);\n        }\n\n        protected void AddScreenShotsToTestResultsDirectory()\n        {\n            if (screenshotDirectory != null)\n            {\n                foreach (string file in Directory.GetFiles(screenshotDirectory))\n                {\n                    this.TestContext.AddResultFile(file);\n                }\n            }\n        }\n\n        /// <summary>\n        /// Restart scope exe.\n        /// </summary>\n        public void RestartScopeExe()\n        {\n            this.sessionHelper!.RestartScopeExe();\n            this.Session = new Session(this.sessionHelper.GetRoot(), this.sessionHelper.GetDriver(), this.scope, this.size);\n            return;\n        }\n\n        /// <summary>\n        /// Restart scope exe.\n        /// </summary>\n        public void ExitScopeExe()\n        {\n            this.sessionHelper!.ExitScopeExe();\n            return;\n        }\n\n        private void CloseOtherApplications()\n        {\n            // Close other applications\n            var processNamesToClose = new List<string>\n            {\n                \"PowerToys\",\n                \"PowerToys.Settings\",\n                \"PowerToys.FancyZonesEditor\",\n            };\n            foreach (var processName in processNamesToClose)\n            {\n                foreach (var process in Process.GetProcessesByName(processName))\n                {\n                    process.Kill();\n                    process.WaitForExit();\n                }\n            }\n        }\n\n        public class NativeMethods\n        {\n            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]\n            public struct DISPLAY_DEVICE\n            {\n                public int cb;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DeviceName;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceString;\n                public int StateFlags;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceID;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceKey;\n            }\n\n            [DllImport(\"user32.dll\")]\n            private static extern int EnumDisplaySettings(IntPtr deviceName, int modeNum, ref DEVMODE devMode);\n\n            [DllImport(\"user32.dll\")]\n            private static extern int EnumDisplaySettings(string deviceName, int modeNum, ref DEVMODE devMode);\n\n            [DllImport(\"user32.dll\", CharSet = CharSet.Ansi)]\n            private static extern bool EnumDisplayDevices(IntPtr lpDevice, int iDevNum, ref DISPLAY_DEVICE lpDisplayDevice, int dwFlags);\n\n            [DllImport(\"user32.dll\")]\n            private static extern int ChangeDisplaySettings(ref DEVMODE devMode, int flags);\n\n            [DllImport(\"user32.dll\", CharSet = CharSet.Ansi)]\n            private static extern int ChangeDisplaySettingsEx(IntPtr lpszDeviceName, ref DEVMODE lpDevMode, IntPtr hwnd, uint dwflags, IntPtr lParam);\n\n            private const int DM_PELSWIDTH = 0x80000;\n            private const int DM_PELSHEIGHT = 0x100000;\n\n            public const int ENUM_CURRENT_SETTINGS = -1;\n            public const int CDS_TEST = 0x00000002;\n            public const int CDS_UPDATEREGISTRY = 0x01;\n            public const int DISP_CHANGE_SUCCESSFUL = 0;\n            public const int DISP_CHANGE_RESTART = 1;\n            public const int DISP_CHANGE_FAILED = -1;\n\n            [StructLayout(LayoutKind.Sequential)]\n            public struct DEVMODE\n            {\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DmDeviceName;\n                public short DmSpecVersion;\n                public short DmDriverVersion;\n                public short DmSize;\n                public short DmDriverExtra;\n                public int DmFields;\n                public int DmPositionX;\n                public int DmPositionY;\n                public int DmDisplayOrientation;\n                public int DmDisplayFixedOutput;\n                public short DmColor;\n                public short DmDuplex;\n                public short DmYResolution;\n                public short DmTTOption;\n                public short DmCollate;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DmFormName;\n                public short DmLogPixels;\n                public int DmBitsPerPel;\n                public int DmPelsWidth;\n                public int DmPelsHeight;\n                public int DmDisplayFlags;\n                public int DmDisplayFrequency;\n                public int DmICMMethod;\n                public int DmICMIntent;\n                public int DmMediaType;\n                public int DmDitherType;\n                public int DmReserved1;\n                public int DmReserved2;\n                public int DmPanningWidth;\n                public int DmPanningHeight;\n            }\n\n            public static void GetMonitorInfo()\n            {\n                int deviceIndex = 0;\n                DISPLAY_DEVICE d = default(DISPLAY_DEVICE);\n                d.cb = Marshal.SizeOf(d);\n\n                Console.WriteLine(\"monitor list :\");\n                while (EnumDisplayDevices(IntPtr.Zero, deviceIndex, ref d, 0))\n                {\n                    Console.WriteLine($\"monitor {deviceIndex + 1}:\");\n                    Console.WriteLine($\"  name: {d.DeviceName}\");\n                    Console.WriteLine($\"  string: {d.DeviceString}\");\n                    Console.WriteLine($\"  ID: {d.DeviceID}\");\n                    Console.WriteLine($\"  key: {d.DeviceKey}\");\n                    Console.WriteLine();\n\n                    DEVMODE dm = default(DEVMODE);\n                    dm.DmSize = (short)Marshal.SizeOf<DEVMODE>();\n                    int modeNum = 0;\n                    while (EnumDisplaySettings(d.DeviceName, modeNum, ref dm) > 0)\n                    {\n                        MonitorInfoData.Monitors.Add(new MonitorInfoData.MonitorInfoDataWrapper()\n                        {\n                            DeviceName = d.DeviceName,\n                            DeviceString = d.DeviceString,\n                            DeviceID = d.DeviceID,\n                            DeviceKey = d.DeviceKey,\n                            PelsWidth = dm.DmPelsWidth,\n                            PelsHeight = dm.DmPelsHeight,\n                            DisplayFrequency = dm.DmDisplayFrequency,\n                        });\n                        Console.WriteLine($\"  mode {modeNum}: {dm.DmPelsWidth}x{dm.DmPelsHeight} @ {dm.DmDisplayFrequency}Hz\");\n                        modeNum++;\n                    }\n\n                    deviceIndex++;\n                    d.cb = Marshal.SizeOf(d); // Reset the size for the next device\n                }\n            }\n\n            public static void ChangeDisplayResolution(int PelsWidth, int PelsHeight)\n            {\n                Screen screen = Screen.PrimaryScreen!;\n                if (screen.Bounds.Width == PelsWidth && screen.Bounds.Height == PelsHeight)\n                {\n                    return;\n                }\n\n                DEVMODE devMode = default(DEVMODE);\n                devMode.DmDeviceName = new string(new char[32]);\n                devMode.DmFormName = new string(new char[32]);\n                devMode.DmSize = (short)Marshal.SizeOf<DEVMODE>();\n\n                int modeNum = 0;\n                while (EnumDisplaySettings(IntPtr.Zero, modeNum, ref devMode) > 0)\n                {\n                    Console.WriteLine($\"Mode {modeNum}: {devMode.DmPelsWidth}x{devMode.DmPelsHeight} @ {devMode.DmDisplayFrequency}Hz\");\n                    modeNum++;\n                }\n\n                devMode.DmPelsWidth = PelsWidth;\n                devMode.DmPelsHeight = PelsHeight;\n\n                int result = NativeMethods.ChangeDisplaySettings(ref devMode, NativeMethods.CDS_TEST);\n\n                if (result == DISP_CHANGE_SUCCESSFUL)\n                {\n                    result = ChangeDisplaySettings(ref devMode, CDS_UPDATEREGISTRY);\n                    if (result == DISP_CHANGE_SUCCESSFUL)\n                    {\n                        Console.WriteLine($\"Changing display resolution to {devMode.DmPelsWidth}x{devMode.DmPelsHeight}\");\n                    }\n                    else\n                    {\n                        Console.WriteLine($\"Failed to change display resolution. Error code: {result}\");\n                    }\n                }\n                else if (result == DISP_CHANGE_RESTART)\n                {\n                    Console.WriteLine($\"Changing display resolution to {devMode.DmPelsWidth}x{devMode.DmPelsHeight} requires a restart\");\n                }\n                else\n                {\n                    Console.WriteLine($\"Failed to change display resolution. Error code: {result}\");\n                }\n            }\n        }\n    }\n}\n",
    "patterns": [
      "Factory",
      "Service",
      "Uses Generics",
      "Uses Pattern Matching",
      "Uses Nullable Reference Types",
      "Uses Tuples"
    ],
    "timestamp": "2025-06-24T22:15:49.097237",
    "quality_score": 0.9000000000000002,
    "training_prompts": [
      {
        "instruction": "UITestBase 클래스와 유사한 구조의 C# 클래스를 작성해주세요.",
        "context": "다음 패턴을 사용해주세요: Factory, Service, Uses Generics",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System.Collections.ObjectModel;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Reflection;\nusing System.Runtime.InteropServices;\nusing System.Xml.Linq;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing OpenQA.Selenium;\nusing OpenQA.Selenium.Appium;\nusing OpenQA.Selenium.Appium.Windows;\nusing Windows.Devices.Display.Core;\nusing Windows.Foundation.Metadata;\nusing static Microsoft.PowerToys.UITest.UITestBase.NativeMethods;\nusing static Microsoft.PowerToys.UITest.WindowHelper;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// Base class that should be inherited by all Test Classes.\n    /// </summary>\n    [TestClass]\n    public class UITestBase : IDisposable\n    {\n        public required TestContext TestContext { get; set; }\n\n        public required Session Session { get; set; }\n\n        public bool IsInPipeline { get; }\n\n        public static MonitorInfoData.ParamsWrapper MonitorInfoData { get; set; } = new MonitorInfoData.ParamsWrapper() { Monitors = new List<MonitorInfoData.MonitorInfoDataWrapper>() };\n\n        private readonly PowerToysModule scope;\n        private readonly WindowSize size;\n        private SessionHelper? sessionHelper;\n        private System.Threading.Timer? screenshotTimer;\n        private string? screenshotDirectory;\n\n        public UITestBase(PowerToysModule scope = PowerToysModule.PowerToysSettings, WindowSize size = WindowSize.UnSpecified)\n        {\n            this.IsInPipeline = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"platform\"));\n            Console.WriteLine($\"Running tests on platform: {Environment.GetEnvironmentVariable(\"platform\")}\");\n            if (IsInPipeline)\n            {\n                NativeMethods.ChangeDisplayResolution(1920, 1080);\n                NativeMethods.GetMonitorInfo();\n\n                // Escape Popups before starting\n                System.Windows.Forms.SendKeys.SendWait(\"{ESC}\");\n            }\n\n            this.scope = scope;\n            this.size = size;\n        }\n\n        /// <summary>\n        /// Initializes the test.\n        /// </summary>\n        [TestInitialize]\n        public void TestInit()\n        {\n            CloseOtherApplications();\n            if (IsInPipeline)\n            {\n                screenshotDirectory = Path.Combine(this.TestContext.TestResultsDirectory ?? string.Empty, \"UITestScreenshots_\" + Guid.NewGuid().ToString());\n                Directory.CreateDirectory(screenshotDirectory);\n\n                // Take screenshot every 1 second\n                screenshotTimer = new System.Threading.Timer(ScreenCapture.TimerCallback, screenshotDirectory, TimeSpan.Zero, TimeSpan.FromMilliseconds(1000));\n\n                // Escape Popups before starting\n                System.Windows.Forms.SendKeys.SendWait(\"{ESC}\");\n            }\n\n            this.sessionHelper = new SessionHelper(scope).Init();\n            this.Session = new Session(this.sessionHelper.GetRoot(), this.sessionHelper.GetDriver(), scope, size);\n\n            if (this.scope == PowerToysModule.PowerToysSettings)\n            {\n                // close Debug warning dialog if any\n                // Such debug warning dialog seems only appear in PowerToys Settings\n                if (this.FindAll(\"DEBUG\").Count > 0)\n                {\n                    this.Find(\"DEBUG\").Find<Button>(\"Close\").Click();\n                }\n            }\n        }\n\n        /// <summary>\n        /// Cleanups the test.\n        /// </summary>\n        [TestCleanup]\n        public void TestCleanup()\n        {\n            if (IsInPipeline)\n            {\n                screenshotTimer?.Change(Timeout.Infinite, Timeout.Infinite);\n                Dispose();\n                if (TestContext.CurrentTestOutcome is UnitTestOutcome.Failed\n                    or UnitTestOutcome.Error\n                    or UnitTestOutcome.Unknown)\n                {\n                    Task.Delay(1000).Wait();\n                    AddScreenShotsToTestResultsDirectory();\n                }\n            }\n\n            this.Session.Cleanup();\n            this.sessionHelper!.Cleanup();\n        }\n\n        public void Dispose()\n        {\n            screenshotTimer?.Dispose();\n            GC.SuppressFinalize(this);\n        }\n\n        /// <summary>\n        /// Finds an element by selector.\n        /// Shortcut for this.Session.Find<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected T Find<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Find<T>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(name, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected T Find<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Find<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected Element Find(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Find(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected Element Find(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Find(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Has only one Element or its derived class by selector.\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.FindAll<T>(by, timeoutMS, global).Count == 1;\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.HasOne<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<T>(name, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.HasOne<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.HasOne<Element>(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(by, timeoutMS, global).Count >= 1;\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Has<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<T>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Has<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Has<Element>(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the elements, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<T> FindAll<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the elements, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<T> FindAll<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<Element> FindAll(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.FindAll<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<Element> FindAll(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.FindAll<Element>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Scrolls the page\n        /// </summary>\n        /// <param name=\"scrollCount\">The number of scroll attempts.</param>\n        /// <param name=\"direction\">The direction to scroll.</param>\n        /// <param name=\"msPreAction\">Pre-action delay in milliseconds.</param>\n        /// <param name=\"msPostAction\">Post-action delay in milliseconds.</param>\n        public void Scroll(int scrollCount = 5, string direction = \"Up\", int msPreAction = 500, int msPostAction = 500)\n        {\n            MouseActionType mouseAction = direction == \"Up\" ? MouseActionType.ScrollUp : MouseActionType.ScrollDown;\n            for (int i = 0; i < scrollCount; i++)\n            {\n                Session.PerformMouseAction(mouseAction, msPreAction, msPostAction); // Ensure settings are visible\n            }\n        }\n\n        /// <summary>\n        /// Captures the last screenshot when the test fails.\n        /// </summary>\n        protected void CaptureLastScreenshot()\n        {\n            // Implement your screenshot capture logic here\n            // For example, save a screenshot to a file and return the file path\n            string screenshotPath = Path.Combine(this.TestContext.TestResultsDirectory ?? string.Empty, \"last_screenshot.png\");\n\n            this.Session.Root.GetScreenshot().SaveAsFile(screenshotPath, ScreenshotImageFormat.Png);\n\n            // Save screenshot to screenshotPath & upload to test attachment\n            this.TestContext.AddResultFile(screenshotPath);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public Color GetPixelColor(int x, int y)\n        {\n            return WindowHelper.GetPixelColor(x, y);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates as a string.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public string GetPixelColorString(int x, int y)\n        {\n            return WindowHelper.GetPixelColorString(x, y);\n        }\n\n        /// <summary>\n        /// Gets the size of the display.\n        /// </summary>\n        /// <returns>\n        /// A tuple containing the width and height of the display.\n        /// </returns\n        public Tuple<int, int> GetDisplaySize()\n        {\n            return WindowHelper.GetDisplaySize();\n        }\n\n        /// <summary>\n        /// Sends a combination of keys.\n        /// </summary>\n        /// <param name=\"keys\">The keys to send.</param>\n        public void SendKeys(params Key[] keys)\n        {\n            this.Session.SendKeys(keys);\n        }\n\n        /// <summary>\n        /// Sends a sequence of keys.\n        /// </summary>\n        /// <param name=\"keys\">An array of keys to send.</param>\n        public void SendKeySequence(params Key[] keys)\n        {\n            this.Session.SendKeySequence(keys);\n        }\n\n        /// <summary>\n        /// Gets the current position of the mouse cursor as a tuple.\n        /// </summary>\n        /// <returns>A tuple containing the X and Y coordinates of the cursor.</returns>\n        public Tuple<int, int> GetMousePosition()\n        {\n            return this.Session.GetMousePosition();\n        }\n\n        /// <summary>\n        /// Gets the screen center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public (int CenterX, int CenterY) GetScreenCenter()\n        {\n            return WindowHelper.GetScreenCenter();\n        }\n\n        public bool IsWindowOpen(string windowName)\n        {\n            return WindowHelper.IsWindowOpen(windowName);\n        }\n\n        /// <summary>\n        /// Moves the mouse cursor to the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The new x-coordinate of the cursor.</param>\n        /// <param name=\"y\">The new y-coordinate of the cursor.</param\n        public void MoveMouseTo(int x, int y)\n        {\n            this.Session.MoveMouseTo(x, y);\n        }\n\n        protected void AddScreenShotsToTestResultsDirectory()\n        {\n            if (screenshotDirectory != null)\n            {\n                foreach (string file in Directory.GetFiles(screenshotDirectory))\n                {\n                    this.TestContext.AddResultFile(file);\n                }\n            }\n        }\n\n        /// <summary>\n        /// Restart scope exe.\n        /// </summary>\n        public void RestartScopeExe()\n        {\n            this.sessionHelper!.RestartScopeExe();\n            this.Session = new Session(this.sessionHelper.GetRoot(), this.sessionHelper.GetDriver(), this.scope, this.size);\n            return;\n        }\n\n        /// <summary>\n        /// Restart scope exe.\n        /// </summary>\n        public void ExitScopeExe()\n        {\n            this.sessionHelper!.ExitScopeExe();\n            return;\n        }\n\n        private void CloseOtherApplications()\n        {\n            // Close other applications\n            var processNamesToClose = new List<string>\n            {\n                \"PowerToys\",\n                \"PowerToys.Settings\",\n                \"PowerToys.FancyZonesEditor\",\n            };\n            foreach (var processName in processNamesToClose)\n            {\n                foreach (var process in Process.GetProcessesByName(processName))\n                {\n                    process.Kill();\n                    process.WaitForExit();\n                }\n            }\n        }\n\n        public class NativeMethods\n        {\n            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]\n            public struct DISPLAY_DEVICE\n            {\n                public int cb;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DeviceName;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceString;\n                public int StateFlags;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceID;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceKey;\n            }\n\n            [DllImport(\"user32.dll\")]\n            private static extern int EnumDisplaySettings(IntPtr deviceName, int modeNum, ref DEVMODE devMode);\n\n            [DllImport(\"user32.dll\")]\n            private static extern int EnumDisplaySettings(string deviceName, int modeNum, ref DEVMODE devMode);\n\n            [DllImport(\"user32.dll\", CharSet = CharSet.Ansi)]\n            private static extern bool EnumDisplayDevices(IntPtr lpDevice, int iDevNum, ref DISPLAY_DEVICE lpDisplayDevice, int dwFlags);\n\n            [DllImport(\"user32.dll\")]\n            private static extern int ChangeDisplaySettings(ref DEVMODE devMode, int flags);\n\n            [DllImport(\"user32.dll\", CharSet = CharSet.Ansi)]\n            private static extern int ChangeDisplaySettingsEx(IntPtr lpszDeviceName, ref DEVMODE lpDevMode, IntPtr hwnd, uint dwflags, IntPtr lParam);\n\n            private const int DM_PELSWIDTH = 0x80000;\n            private const int DM_PELSHEIGHT = 0x100000;\n\n            public const int ENUM_CURRENT_SETTINGS = -1;\n            public const int CDS_TEST = 0x00000002;\n            public const int CDS_UPDATEREGISTRY = 0x01;\n            public const int DISP_CHANGE_SUCCESSFUL = 0;\n            public const int DISP_CHANGE_RESTART = 1;\n            public const int DISP_CHANGE_FAILED = -1;\n\n            [StructLayout(LayoutKind.Sequential)]\n            public struct DEVMODE\n            {\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DmDeviceName;\n                public short DmSpecVersion;\n                public short DmDriverVersion;\n                public short DmSize;\n                public short DmDriverExtra;\n                public int DmFields;\n                public int DmPositionX;\n                public int DmPositionY;\n                public int DmDisplayOrientation;\n                public int DmDisplayFixedOutput;\n                public short DmColor;\n                public short DmDuplex;\n                public short DmYResolution;\n                public short DmTTOption;\n                public short DmCollate;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DmFormName;\n                public short DmLogPixels;\n                public int DmBitsPerPel;\n                public int DmPelsWidth;\n                public int DmPelsHeight;\n                public int DmDisplayFlags;\n                public int DmDisplayFrequency;\n                public int DmICMMethod;\n                public int DmICMIntent;\n                public int DmMediaType;\n                public int DmDitherType;\n                public int DmReserved1;\n                public int DmReserved2;\n                public int DmPanningWidth;\n                public int DmPanningHeight;\n            }\n\n            public static void GetMonitorInfo()\n            {\n                int deviceIndex = 0;\n                DISPLAY_DEVICE d = default(DISPLAY_DEVICE);\n                d.cb = Marshal.SizeOf(d);\n\n                Console.WriteLine(\"monitor list :\");\n                while (EnumDisplayDevices(IntPtr.Zero, deviceIndex, ref d, 0))\n                {\n                    Console.WriteLine($\"monitor {deviceIndex + 1}:\");\n                    Console.WriteLine($\"  name: {d.DeviceName}\");\n                    Console.WriteLine($\"  string: {d.DeviceString}\");\n                    Console.WriteLine($\"  ID: {d.DeviceID}\");\n                    Console.WriteLine($\"  key: {d.DeviceKey}\");\n                    Console.WriteLine();\n\n                    DEVMODE dm = default(DEVMODE);\n                    dm.DmSize = (short)Marshal.SizeOf<DEVMODE>();\n                    int modeNum = 0;\n                    while (EnumDisplaySettings(d.DeviceName, modeNum, ref dm) > 0)\n                    {\n                        MonitorInfoData.Monitors.Add(new MonitorInfoData.MonitorInfoDataWrapper()\n                        {\n                            DeviceName = d.DeviceName,\n                            DeviceString = d.DeviceString,\n                            DeviceID = d.DeviceID,\n                            DeviceKey = d.DeviceKey,\n                            PelsWidth = dm.DmPelsWidth,\n                            PelsHeight = dm.DmPelsHeight,\n                            DisplayFrequency = dm.DmDisplayFrequency,\n                        });\n                        Console.WriteLine($\"  mode {modeNum}: {dm.DmPelsWidth}x{dm.DmPelsHeight} @ {dm.DmDisplayFrequency}Hz\");\n                        modeNum++;\n                    }\n\n                    deviceIndex++;\n                    d.cb = Marshal.SizeOf(d); // Reset the size for the next device\n                }\n            }\n\n            public static void ChangeDisplayResolution(int PelsWidth, int PelsHeight)\n            {\n                Screen screen = Screen.PrimaryScreen!;\n                if (screen.Bounds.Width == PelsWidth && screen.Bounds.Height == PelsHeight)\n                {\n                    return;\n                }\n\n                DEVMODE devMode = default(DEVMODE);\n                devMode.DmDeviceName = new string(new char[32]);\n                devMode.DmFormName = new string(new char[32]);\n                devMode.DmSize = (short)Marshal.SizeOf<DEVMODE>();\n\n                int modeNum = 0;\n                while (EnumDisplaySettings(IntPtr.Zero, modeNum, ref devMode) > 0)\n                {\n                    Console.WriteLine($\"Mode {modeNum}: {devMode.DmPelsWidth}x{devMode.DmPelsHeight} @ {devMode.DmDisplayFrequency}Hz\");\n                    modeNum++;\n                }\n\n                devMode.DmPelsWidth = PelsWidth;\n                devMode.DmPelsHeight = PelsHeight;\n\n                int result = NativeMethods.ChangeDisplaySettings(ref devMode, NativeMethods.CDS_TEST);\n\n                if (result == DISP_CHANGE_SUCCESSFUL)\n                {\n                    result = ChangeDisplaySettings(ref devMode, CDS_UPDATEREGISTRY);\n                    if (result == DISP_CHANGE_SUCCESSFUL)\n                    {\n                        Console.WriteLine($\"Changing display resolution to {devMode.DmPelsWidth}x{devMode.DmPelsHeight}\");\n                    }\n                    else\n                    {\n                        Console.WriteLine($\"Failed to change display resolution. Error code: {result}\");\n                    }\n                }\n                else if (result == DISP_CHANGE_RESTART)\n                {\n                    Console.WriteLine($\"Changing display resolution to {devMode.DmPelsWidth}x{devMode.DmPelsHeight} requires a restart\");\n                }\n                else\n                {\n                    Console.WriteLine($\"Failed to change display resolution. Error code: {result}\");\n                }\n            }\n        }\n    }\n}\n"
      },
      {
        "instruction": "NativeMethods 클래스와 유사한 구조의 C# 클래스를 작성해주세요.",
        "context": "다음 패턴을 사용해주세요: Factory, Service, Uses Generics",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System.Collections.ObjectModel;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Reflection;\nusing System.Runtime.InteropServices;\nusing System.Xml.Linq;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing OpenQA.Selenium;\nusing OpenQA.Selenium.Appium;\nusing OpenQA.Selenium.Appium.Windows;\nusing Windows.Devices.Display.Core;\nusing Windows.Foundation.Metadata;\nusing static Microsoft.PowerToys.UITest.UITestBase.NativeMethods;\nusing static Microsoft.PowerToys.UITest.WindowHelper;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// Base class that should be inherited by all Test Classes.\n    /// </summary>\n    [TestClass]\n    public class UITestBase : IDisposable\n    {\n        public required TestContext TestContext { get; set; }\n\n        public required Session Session { get; set; }\n\n        public bool IsInPipeline { get; }\n\n        public static MonitorInfoData.ParamsWrapper MonitorInfoData { get; set; } = new MonitorInfoData.ParamsWrapper() { Monitors = new List<MonitorInfoData.MonitorInfoDataWrapper>() };\n\n        private readonly PowerToysModule scope;\n        private readonly WindowSize size;\n        private SessionHelper? sessionHelper;\n        private System.Threading.Timer? screenshotTimer;\n        private string? screenshotDirectory;\n\n        public UITestBase(PowerToysModule scope = PowerToysModule.PowerToysSettings, WindowSize size = WindowSize.UnSpecified)\n        {\n            this.IsInPipeline = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"platform\"));\n            Console.WriteLine($\"Running tests on platform: {Environment.GetEnvironmentVariable(\"platform\")}\");\n            if (IsInPipeline)\n            {\n                NativeMethods.ChangeDisplayResolution(1920, 1080);\n                NativeMethods.GetMonitorInfo();\n\n                // Escape Popups before starting\n                System.Windows.Forms.SendKeys.SendWait(\"{ESC}\");\n            }\n\n            this.scope = scope;\n            this.size = size;\n        }\n\n        /// <summary>\n        /// Initializes the test.\n        /// </summary>\n        [TestInitialize]\n        public void TestInit()\n        {\n            CloseOtherApplications();\n            if (IsInPipeline)\n            {\n                screenshotDirectory = Path.Combine(this.TestContext.TestResultsDirectory ?? string.Empty, \"UITestScreenshots_\" + Guid.NewGuid().ToString());\n                Directory.CreateDirectory(screenshotDirectory);\n\n                // Take screenshot every 1 second\n                screenshotTimer = new System.Threading.Timer(ScreenCapture.TimerCallback, screenshotDirectory, TimeSpan.Zero, TimeSpan.FromMilliseconds(1000));\n\n                // Escape Popups before starting\n                System.Windows.Forms.SendKeys.SendWait(\"{ESC}\");\n            }\n\n            this.sessionHelper = new SessionHelper(scope).Init();\n            this.Session = new Session(this.sessionHelper.GetRoot(), this.sessionHelper.GetDriver(), scope, size);\n\n            if (this.scope == PowerToysModule.PowerToysSettings)\n            {\n                // close Debug warning dialog if any\n                // Such debug warning dialog seems only appear in PowerToys Settings\n                if (this.FindAll(\"DEBUG\").Count > 0)\n                {\n                    this.Find(\"DEBUG\").Find<Button>(\"Close\").Click();\n                }\n            }\n        }\n\n        /// <summary>\n        /// Cleanups the test.\n        /// </summary>\n        [TestCleanup]\n        public void TestCleanup()\n        {\n            if (IsInPipeline)\n            {\n                screenshotTimer?.Change(Timeout.Infinite, Timeout.Infinite);\n                Dispose();\n                if (TestContext.CurrentTestOutcome is UnitTestOutcome.Failed\n                    or UnitTestOutcome.Error\n                    or UnitTestOutcome.Unknown)\n                {\n                    Task.Delay(1000).Wait();\n                    AddScreenShotsToTestResultsDirectory();\n                }\n            }\n\n            this.Session.Cleanup();\n            this.sessionHelper!.Cleanup();\n        }\n\n        public void Dispose()\n        {\n            screenshotTimer?.Dispose();\n            GC.SuppressFinalize(this);\n        }\n\n        /// <summary>\n        /// Finds an element by selector.\n        /// Shortcut for this.Session.Find<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected T Find<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Find<T>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(name, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected T Find<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Find<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected Element Find(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Find(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected Element Find(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Find(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Has only one Element or its derived class by selector.\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.FindAll<T>(by, timeoutMS, global).Count == 1;\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.HasOne<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<T>(name, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.HasOne<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.HasOne<Element>(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(by, timeoutMS, global).Count >= 1;\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Has<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<T>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Has<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Has<Element>(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the elements, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<T> FindAll<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the elements, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<T> FindAll<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<Element> FindAll(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.FindAll<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<Element> FindAll(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.FindAll<Element>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Scrolls the page\n        /// </summary>\n        /// <param name=\"scrollCount\">The number of scroll attempts.</param>\n        /// <param name=\"direction\">The direction to scroll.</param>\n        /// <param name=\"msPreAction\">Pre-action delay in milliseconds.</param>\n        /// <param name=\"msPostAction\">Post-action delay in milliseconds.</param>\n        public void Scroll(int scrollCount = 5, string direction = \"Up\", int msPreAction = 500, int msPostAction = 500)\n        {\n            MouseActionType mouseAction = direction == \"Up\" ? MouseActionType.ScrollUp : MouseActionType.ScrollDown;\n            for (int i = 0; i < scrollCount; i++)\n            {\n                Session.PerformMouseAction(mouseAction, msPreAction, msPostAction); // Ensure settings are visible\n            }\n        }\n\n        /// <summary>\n        /// Captures the last screenshot when the test fails.\n        /// </summary>\n        protected void CaptureLastScreenshot()\n        {\n            // Implement your screenshot capture logic here\n            // For example, save a screenshot to a file and return the file path\n            string screenshotPath = Path.Combine(this.TestContext.TestResultsDirectory ?? string.Empty, \"last_screenshot.png\");\n\n            this.Session.Root.GetScreenshot().SaveAsFile(screenshotPath, ScreenshotImageFormat.Png);\n\n            // Save screenshot to screenshotPath & upload to test attachment\n            this.TestContext.AddResultFile(screenshotPath);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public Color GetPixelColor(int x, int y)\n        {\n            return WindowHelper.GetPixelColor(x, y);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates as a string.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public string GetPixelColorString(int x, int y)\n        {\n            return WindowHelper.GetPixelColorString(x, y);\n        }\n\n        /// <summary>\n        /// Gets the size of the display.\n        /// </summary>\n        /// <returns>\n        /// A tuple containing the width and height of the display.\n        /// </returns\n        public Tuple<int, int> GetDisplaySize()\n        {\n            return WindowHelper.GetDisplaySize();\n        }\n\n        /// <summary>\n        /// Sends a combination of keys.\n        /// </summary>\n        /// <param name=\"keys\">The keys to send.</param>\n        public void SendKeys(params Key[] keys)\n        {\n            this.Session.SendKeys(keys);\n        }\n\n        /// <summary>\n        /// Sends a sequence of keys.\n        /// </summary>\n        /// <param name=\"keys\">An array of keys to send.</param>\n        public void SendKeySequence(params Key[] keys)\n        {\n            this.Session.SendKeySequence(keys);\n        }\n\n        /// <summary>\n        /// Gets the current position of the mouse cursor as a tuple.\n        /// </summary>\n        /// <returns>A tuple containing the X and Y coordinates of the cursor.</returns>\n        public Tuple<int, int> GetMousePosition()\n        {\n            return this.Session.GetMousePosition();\n        }\n\n        /// <summary>\n        /// Gets the screen center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public (int CenterX, int CenterY) GetScreenCenter()\n        {\n            return WindowHelper.GetScreenCenter();\n        }\n\n        public bool IsWindowOpen(string windowName)\n        {\n            return WindowHelper.IsWindowOpen(windowName);\n        }\n\n        /// <summary>\n        /// Moves the mouse cursor to the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The new x-coordinate of the cursor.</param>\n        /// <param name=\"y\">The new y-coordinate of the cursor.</param\n        public void MoveMouseTo(int x, int y)\n        {\n            this.Session.MoveMouseTo(x, y);\n        }\n\n        protected void AddScreenShotsToTestResultsDirectory()\n        {\n            if (screenshotDirectory != null)\n            {\n                foreach (string file in Directory.GetFiles(screenshotDirectory))\n                {\n                    this.TestContext.AddResultFile(file);\n                }\n            }\n        }\n\n        /// <summary>\n        /// Restart scope exe.\n        /// </summary>\n        public void RestartScopeExe()\n        {\n            this.sessionHelper!.RestartScopeExe();\n            this.Session = new Session(this.sessionHelper.GetRoot(), this.sessionHelper.GetDriver(), this.scope, this.size);\n            return;\n        }\n\n        /// <summary>\n        /// Restart scope exe.\n        /// </summary>\n        public void ExitScopeExe()\n        {\n            this.sessionHelper!.ExitScopeExe();\n            return;\n        }\n\n        private void CloseOtherApplications()\n        {\n            // Close other applications\n            var processNamesToClose = new List<string>\n            {\n                \"PowerToys\",\n                \"PowerToys.Settings\",\n                \"PowerToys.FancyZonesEditor\",\n            };\n            foreach (var processName in processNamesToClose)\n            {\n                foreach (var process in Process.GetProcessesByName(processName))\n                {\n                    process.Kill();\n                    process.WaitForExit();\n                }\n            }\n        }\n\n        public class NativeMethods\n        {\n            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]\n            public struct DISPLAY_DEVICE\n            {\n                public int cb;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DeviceName;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceString;\n                public int StateFlags;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceID;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceKey;\n            }\n\n            [DllImport(\"user32.dll\")]\n            private static extern int EnumDisplaySettings(IntPtr deviceName, int modeNum, ref DEVMODE devMode);\n\n            [DllImport(\"user32.dll\")]\n            private static extern int EnumDisplaySettings(string deviceName, int modeNum, ref DEVMODE devMode);\n\n            [DllImport(\"user32.dll\", CharSet = CharSet.Ansi)]\n            private static extern bool EnumDisplayDevices(IntPtr lpDevice, int iDevNum, ref DISPLAY_DEVICE lpDisplayDevice, int dwFlags);\n\n            [DllImport(\"user32.dll\")]\n            private static extern int ChangeDisplaySettings(ref DEVMODE devMode, int flags);\n\n            [DllImport(\"user32.dll\", CharSet = CharSet.Ansi)]\n            private static extern int ChangeDisplaySettingsEx(IntPtr lpszDeviceName, ref DEVMODE lpDevMode, IntPtr hwnd, uint dwflags, IntPtr lParam);\n\n            private const int DM_PELSWIDTH = 0x80000;\n            private const int DM_PELSHEIGHT = 0x100000;\n\n            public const int ENUM_CURRENT_SETTINGS = -1;\n            public const int CDS_TEST = 0x00000002;\n            public const int CDS_UPDATEREGISTRY = 0x01;\n            public const int DISP_CHANGE_SUCCESSFUL = 0;\n            public const int DISP_CHANGE_RESTART = 1;\n            public const int DISP_CHANGE_FAILED = -1;\n\n            [StructLayout(LayoutKind.Sequential)]\n            public struct DEVMODE\n            {\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DmDeviceName;\n                public short DmSpecVersion;\n                public short DmDriverVersion;\n                public short DmSize;\n                public short DmDriverExtra;\n                public int DmFields;\n                public int DmPositionX;\n                public int DmPositionY;\n                public int DmDisplayOrientation;\n                public int DmDisplayFixedOutput;\n                public short DmColor;\n                public short DmDuplex;\n                public short DmYResolution;\n                public short DmTTOption;\n                public short DmCollate;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DmFormName;\n                public short DmLogPixels;\n                public int DmBitsPerPel;\n                public int DmPelsWidth;\n                public int DmPelsHeight;\n                public int DmDisplayFlags;\n                public int DmDisplayFrequency;\n                public int DmICMMethod;\n                public int DmICMIntent;\n                public int DmMediaType;\n                public int DmDitherType;\n                public int DmReserved1;\n                public int DmReserved2;\n                public int DmPanningWidth;\n                public int DmPanningHeight;\n            }\n\n            public static void GetMonitorInfo()\n            {\n                int deviceIndex = 0;\n                DISPLAY_DEVICE d = default(DISPLAY_DEVICE);\n                d.cb = Marshal.SizeOf(d);\n\n                Console.WriteLine(\"monitor list :\");\n                while (EnumDisplayDevices(IntPtr.Zero, deviceIndex, ref d, 0))\n                {\n                    Console.WriteLine($\"monitor {deviceIndex + 1}:\");\n                    Console.WriteLine($\"  name: {d.DeviceName}\");\n                    Console.WriteLine($\"  string: {d.DeviceString}\");\n                    Console.WriteLine($\"  ID: {d.DeviceID}\");\n                    Console.WriteLine($\"  key: {d.DeviceKey}\");\n                    Console.WriteLine();\n\n                    DEVMODE dm = default(DEVMODE);\n                    dm.DmSize = (short)Marshal.SizeOf<DEVMODE>();\n                    int modeNum = 0;\n                    while (EnumDisplaySettings(d.DeviceName, modeNum, ref dm) > 0)\n                    {\n                        MonitorInfoData.Monitors.Add(new MonitorInfoData.MonitorInfoDataWrapper()\n                        {\n                            DeviceName = d.DeviceName,\n                            DeviceString = d.DeviceString,\n                            DeviceID = d.DeviceID,\n                            DeviceKey = d.DeviceKey,\n                            PelsWidth = dm.DmPelsWidth,\n                            PelsHeight = dm.DmPelsHeight,\n                            DisplayFrequency = dm.DmDisplayFrequency,\n                        });\n                        Console.WriteLine($\"  mode {modeNum}: {dm.DmPelsWidth}x{dm.DmPelsHeight} @ {dm.DmDisplayFrequency}Hz\");\n                        modeNum++;\n                    }\n\n                    deviceIndex++;\n                    d.cb = Marshal.SizeOf(d); // Reset the size for the next device\n                }\n            }\n\n            public static void ChangeDisplayResolution(int PelsWidth, int PelsHeight)\n            {\n                Screen screen = Screen.PrimaryScreen!;\n                if (screen.Bounds.Width == PelsWidth && screen.Bounds.Height == PelsHeight)\n                {\n                    return;\n                }\n\n                DEVMODE devMode = default(DEVMODE);\n                devMode.DmDeviceName = new string(new char[32]);\n                devMode.DmFormName = new string(new char[32]);\n                devMode.DmSize = (short)Marshal.SizeOf<DEVMODE>();\n\n                int modeNum = 0;\n                while (EnumDisplaySettings(IntPtr.Zero, modeNum, ref devMode) > 0)\n                {\n                    Console.WriteLine($\"Mode {modeNum}: {devMode.DmPelsWidth}x{devMode.DmPelsHeight} @ {devMode.DmDisplayFrequency}Hz\");\n                    modeNum++;\n                }\n\n                devMode.DmPelsWidth = PelsWidth;\n                devMode.DmPelsHeight = PelsHeight;\n\n                int result = NativeMethods.ChangeDisplaySettings(ref devMode, NativeMethods.CDS_TEST);\n\n                if (result == DISP_CHANGE_SUCCESSFUL)\n                {\n                    result = ChangeDisplaySettings(ref devMode, CDS_UPDATEREGISTRY);\n                    if (result == DISP_CHANGE_SUCCESSFUL)\n                    {\n                        Console.WriteLine($\"Changing display resolution to {devMode.DmPelsWidth}x{devMode.DmPelsHeight}\");\n                    }\n                    else\n                    {\n                        Console.WriteLine($\"Failed to change display resolution. Error code: {result}\");\n                    }\n                }\n                else if (result == DISP_CHANGE_RESTART)\n                {\n                    Console.WriteLine($\"Changing display resolution to {devMode.DmPelsWidth}x{devMode.DmPelsHeight} requires a restart\");\n                }\n                else\n                {\n                    Console.WriteLine($\"Failed to change display resolution. Error code: {result}\");\n                }\n            }\n        }\n    }\n}\n"
      },
      {
        "instruction": "void 반환 타입의 TestInit 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System.Collections.ObjectModel;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Reflection;\nusing System.Runtime.InteropServices;\nusing System.Xml.Linq;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing OpenQA.Selenium;\nusing OpenQA.Selenium.Appium;\nusing OpenQA.Selenium.Appium.Windows;\nusing Windows.Devices.Display.Core;\nusing Windows.Foundation.Metadata;\nusing static Microsoft.PowerToys.UITest.UITestBase.NativeMethods;\nusing static Microsoft.PowerToys.UITest.WindowHelper;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// Base class that should be inherited by all Test Classes.\n    /// </summary>\n    [TestClass]\n    public class UITestBase : IDisposable\n    {\n        public required TestContext TestContext { get; set; }\n\n        public required Session Session { get; set; }\n\n        public bool IsInPipeline { get; }\n\n        public static MonitorInfoData.ParamsWrapper MonitorInfoData { get; set; } = new MonitorInfoData.ParamsWrapper() { Monitors = new List<MonitorInfoData.MonitorInfoDataWrapper>() };\n\n        private readonly PowerToysModule scope;\n        private readonly WindowSize size;\n        private SessionHelper? sessionHelper;\n        private System.Threading.Timer? screenshotTimer;\n        private string? screenshotDirectory;\n\n        public UITestBase(PowerToysModule scope = PowerToysModule.PowerToysSettings, WindowSize size = WindowSize.UnSpecified)\n        {\n            this.IsInPipeline = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"platform\"));\n            Console.WriteLine($\"Running tests on platform: {Environment.GetEnvironmentVariable(\"platform\")}\");\n            if (IsInPipeline)\n            {\n                NativeMethods.ChangeDisplayResolution(1920, 1080);\n                NativeMethods.GetMonitorInfo();\n\n                // Escape Popups before starting\n                System.Windows.Forms.SendKeys.SendWait(\"{ESC}\");\n            }\n\n            this.scope = scope;\n            this.size = size;\n        }\n\n        /// <summary>\n        /// Initializes the test.\n        /// </summary>\n        [TestInitialize]\n        public void TestInit()\n        {\n            CloseOtherApplications();\n            if (IsInPipeline)\n            {\n                screenshotDirectory = Path.Combine(this.TestContext.TestResultsDirectory ?? string.Empty, \"UITestScreenshots_\" + Guid.NewGuid().ToString());\n                Directory.CreateDirectory(screenshotDirectory);\n\n                // Take screenshot every 1 second\n                screenshotTimer = new System.Threading.Timer(ScreenCapture.TimerCallback, screenshotDirectory, TimeSpan.Zero, TimeSpan.FromMilliseconds(1000));\n\n                // Escape Popups before starting\n                System.Windows.Forms.SendKeys.SendWait(\"{ESC}\");\n            }\n\n            this.sessionHelper = new SessionHelper(scope).Init();\n            this.Session = new Session(this.sessionHelper.GetRoot(), this.sessionHelper.GetDriver(), scope, size);\n\n            if (this.scope == PowerToysModule.PowerToysSettings)\n            {\n                // close Debug warning dialog if any\n                // Such debug warning dialog seems only appear in PowerToys Settings\n                if (this.FindAll(\"DEBUG\").Count > 0)\n                {\n                    this.Find(\"DEBUG\").Find<Button>(\"Close\").Click();\n                }\n            }\n        }\n\n        /// <summary>\n        /// Cleanups the test.\n        /// </summary>\n        [TestCleanup]\n        public void TestCleanup()\n        {\n            if (IsInPipeline)\n            {\n                screenshotTimer?.Change(Timeout.Infinite, Timeout.Infinite);\n                Dispose();\n                if (TestContext.CurrentTestOutcome is UnitTestOutcome.Failed\n                    or UnitTestOutcome.Error\n                    or UnitTestOutcome.Unknown)\n                {\n                    Task.Delay(1000).Wait();\n                    AddScreenShotsToTestResultsDirectory();\n                }\n            }\n\n            this.Session.Cleanup();\n            this.sessionHelper!.Cleanup();\n        }\n\n        public void Dispose()\n        {\n            screenshotTimer?.Dispose();\n            GC.SuppressFinalize(this);\n        }\n\n        /// <summary>\n        /// Finds an element by selector.\n        /// Shortcut for this.Session.Find<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected T Find<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Find<T>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(name, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected T Find<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Find<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected Element Find(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Find(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected Element Find(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Find(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Has only one Element or its derived class by selector.\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.FindAll<T>(by, timeoutMS, global).Count == 1;\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.HasOne<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<T>(name, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.HasOne<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.HasOne<Element>(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(by, timeoutMS, global).Count >= 1;\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Has<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<T>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Has<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Has<Element>(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the elements, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<T> FindAll<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the elements, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<T> FindAll<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<Element> FindAll(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.FindAll<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<Element> FindAll(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.FindAll<Element>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Scrolls the page\n        /// </summary>\n        /// <param name=\"scrollCount\">The number of scroll attempts.</param>\n        /// <param name=\"direction\">The direction to scroll.</param>\n        /// <param name=\"msPreAction\">Pre-action delay in milliseconds.</param>\n        /// <param name=\"msPostAction\">Post-action delay in milliseconds.</param>\n        public void Scroll(int scrollCount = 5, string direction = \"Up\", int msPreAction = 500, int msPostAction = 500)\n        {\n            MouseActionType mouseAction = direction == \"Up\" ? MouseActionType.ScrollUp : MouseActionType.ScrollDown;\n            for (int i = 0; i < scrollCount; i++)\n            {\n                Session.PerformMouseAction(mouseAction, msPreAction, msPostAction); // Ensure settings are visible\n            }\n        }\n\n        /// <summary>\n        /// Captures the last screenshot when the test fails.\n        /// </summary>\n        protected void CaptureLastScreenshot()\n        {\n            // Implement your screenshot capture logic here\n            // For example, save a screenshot to a file and return the file path\n            string screenshotPath = Path.Combine(this.TestContext.TestResultsDirectory ?? string.Empty, \"last_screenshot.png\");\n\n            this.Session.Root.GetScreenshot().SaveAsFile(screenshotPath, ScreenshotImageFormat.Png);\n\n            // Save screenshot to screenshotPath & upload to test attachment\n            this.TestContext.AddResultFile(screenshotPath);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public Color GetPixelColor(int x, int y)\n        {\n            return WindowHelper.GetPixelColor(x, y);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates as a string.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public string GetPixelColorString(int x, int y)\n        {\n            return WindowHelper.GetPixelColorString(x, y);\n        }\n\n        /// <summary>\n        /// Gets the size of the display.\n        /// </summary>\n        /// <returns>\n        /// A tuple containing the width and height of the display.\n        /// </returns\n        public Tuple<int, int> GetDisplaySize()\n        {\n            return WindowHelper.GetDisplaySize();\n        }\n\n        /// <summary>\n        /// Sends a combination of keys.\n        /// </summary>\n        /// <param name=\"keys\">The keys to send.</param>\n        public void SendKeys(params Key[] keys)\n        {\n            this.Session.SendKeys(keys);\n        }\n\n        /// <summary>\n        /// Sends a sequence of keys.\n        /// </summary>\n        /// <param name=\"keys\">An array of keys to send.</param>\n        public void SendKeySequence(params Key[] keys)\n        {\n            this.Session.SendKeySequence(keys);\n        }\n\n        /// <summary>\n        /// Gets the current position of the mouse cursor as a tuple.\n        /// </summary>\n        /// <returns>A tuple containing the X and Y coordinates of the cursor.</returns>\n        public Tuple<int, int> GetMousePosition()\n        {\n            return this.Session.GetMousePosition();\n        }\n\n        /// <summary>\n        /// Gets the screen center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public (int CenterX, int CenterY) GetScreenCenter()\n        {\n            return WindowHelper.GetScreenCenter();\n        }\n\n        public bool IsWindowOpen(string windowName)\n        {\n            return WindowHelper.IsWindowOpen(windowName);\n        }\n\n        /// <summary>\n        /// Moves the mouse cursor to the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The new x-coordinate of the cursor.</param>\n        /// <param name=\"y\">The new y-coordinate of the cursor.</param\n        public void MoveMouseTo(int x, int y)\n        {\n            this.Session.MoveMouseTo(x, y);\n        }\n\n        protected void AddScreenShotsToTestResultsDirectory()\n        {\n            if (screenshotDirectory != null)\n            {\n                foreach (string file in Directory.GetFiles(screenshotDirectory))\n                {\n                    this.TestContext.AddResultFile(file);\n                }\n            }\n        }\n\n        /// <summary>\n        /// Restart scope exe.\n        /// </summary>\n        public void RestartScopeExe()\n        {\n            this.sessionHelper!.RestartScopeExe();\n            this.Session = new Session(this.sessionHelper.GetRoot(), this.sessionHelper.GetDriver(), this.scope, this.size);\n            return;\n        }\n\n        /// <summary>\n        /// Restart scope exe.\n        /// </summary>\n        public void ExitScopeExe()\n        {\n            this.sessionHelper!.ExitScopeExe();\n            return;\n        }\n\n        private void CloseOtherApplications()\n        {\n            // Close other applications\n            var processNamesToClose = new List<string>\n            {\n                \"PowerToys\",\n                \"PowerToys.Settings\",\n                \"PowerToys.FancyZonesEditor\",\n            };\n            foreach (var processName in processNamesToClose)\n            {\n                foreach (var process in Process.GetProcessesByName(processName))\n                {\n                    process.Kill();\n                    process.WaitForExit();\n                }\n            }\n        }\n\n        public class NativeMethods\n        {\n            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]\n            public struct DISPLAY_DEVICE\n            {\n                public int cb;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DeviceName;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceString;\n                public int StateFlags;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceID;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceKey;\n            }\n\n            [DllImport(\"user32.dll\")]\n            private static extern int EnumDisplaySettings(IntPtr deviceName, int modeNum, ref DEVMODE devMode);\n\n            [DllImport(\"user32.dll\")]\n            private static extern int EnumDisplaySettings(string deviceName, int modeNum, ref DEVMODE devMode);\n\n            [DllImport(\"user32.dll\", CharSet = CharSet.Ansi)]\n            private static extern bool EnumDisplayDevices(IntPtr lpDevice, int iDevNum, ref DISPLAY_DEVICE lpDisplayDevice, int dwFlags);\n\n            [DllImport(\"user32.dll\")]\n            private static extern int ChangeDisplaySettings(ref DEVMODE devMode, int flags);\n\n            [DllImport(\"user32.dll\", CharSet = CharSet.Ansi)]\n            private static extern int ChangeDisplaySettingsEx(IntPtr lpszDeviceName, ref DEVMODE lpDevMode, IntPtr hwnd, uint dwflags, IntPtr lParam);\n\n            private const int DM_PELSWIDTH = 0x80000;\n            private const int DM_PELSHEIGHT = 0x100000;\n\n            public const int ENUM_CURRENT_SETTINGS = -1;\n            public const int CDS_TEST = 0x00000002;\n            public const int CDS_UPDATEREGISTRY = 0x01;\n            public const int DISP_CHANGE_SUCCESSFUL = 0;\n            public const int DISP_CHANGE_RESTART = 1;\n            public const int DISP_CHANGE_FAILED = -1;\n\n            [StructLayout(LayoutKind.Sequential)]\n            public struct DEVMODE\n            {\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DmDeviceName;\n                public short DmSpecVersion;\n                public short DmDriverVersion;\n                public short DmSize;\n                public short DmDriverExtra;\n                public int DmFields;\n                public int DmPositionX;\n                public int DmPositionY;\n                public int DmDisplayOrientation;\n                public int DmDisplayFixedOutput;\n                public short DmColor;\n                public short DmDuplex;\n                public short DmYResolution;\n                public short DmTTOption;\n                public short DmCollate;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DmFormName;\n                public short DmLogPixels;\n                public int DmBitsPerPel;\n                public int DmPelsWidth;\n                public int DmPelsHeight;\n                public int DmDisplayFlags;\n                public int DmDisplayFrequency;\n                public int DmICMMethod;\n                public int DmICMIntent;\n                public int DmMediaType;\n                public int DmDitherType;\n                public int DmReserved1;\n                public int DmReserved2;\n                public int DmPanningWidth;\n                public int DmPanningHeight;\n            }\n\n            public static void GetMonitorInfo()\n            {\n                int deviceIndex = 0;\n                DISPLAY_DEVICE d = default(DISPLAY_DEVICE);\n                d.cb = Marshal.SizeOf(d);\n\n                Console.WriteLine(\"monitor list :\");\n                while (EnumDisplayDevices(IntPtr.Zero, deviceIndex, ref d, 0))\n                {\n                    Console.WriteLine($\"monitor {deviceIndex + 1}:\");\n                    Console.WriteLine($\"  name: {d.DeviceName}\");\n                    Console.WriteLine($\"  string: {d.DeviceString}\");\n                    Console.WriteLine($\"  ID: {d.DeviceID}\");\n                    Console.WriteLine($\"  key: {d.DeviceKey}\");\n                    Console.WriteLine();\n\n                    DEVMODE dm = default(DEVMODE);\n                    dm.DmSize = (short)Marshal.SizeOf<DEVMODE>();\n                    int modeNum = 0;\n                    while (EnumDisplaySettings(d.DeviceName, modeNum, ref dm) > 0)\n                    {\n                        MonitorInfoData.Monitors.Add(new MonitorInfoData.MonitorInfoDataWrapper()\n                        {\n                            DeviceName = d.DeviceName,\n                            DeviceString = d.DeviceString,\n                            DeviceID = d.DeviceID,\n                            DeviceKey = d.DeviceKey,\n                            PelsWidth = dm.DmPelsWidth,\n                            PelsHeight = dm.DmPelsHeight,\n                            DisplayFrequency = dm.DmDisplayFrequency,\n                        });\n                        Console.WriteLine($\"  mode {modeNum}: {dm.DmPelsWidth}x{dm.DmPelsHeight} @ {dm.DmDisplayFrequency}Hz\");\n                        modeNum++;\n                    }\n\n                    deviceIndex++;\n                    d.cb = Marshal.SizeOf(d); // Reset the size for the next device\n                }\n            }\n\n            public static void ChangeDisplayResolution(int PelsWidth, int PelsHeight)\n            {\n                Screen screen = Screen.PrimaryScreen!;\n                if (screen.Bounds.Width == PelsWidth && screen.Bounds.Height == PelsHeight)\n                {\n                    return;\n                }\n\n                DEVMODE devMode = default(DEVMODE);\n                devMode.DmDeviceName = new string(new char[32]);\n                devMode.DmFormName = new string(new char[32]);\n                devMode.DmSize = (short)Marshal.SizeOf<DEVMODE>();\n\n                int modeNum = 0;\n                while (EnumDisplaySettings(IntPtr.Zero, modeNum, ref devMode) > 0)\n                {\n                    Console.WriteLine($\"Mode {modeNum}: {devMode.DmPelsWidth}x{devMode.DmPelsHeight} @ {devMode.DmDisplayFrequency}Hz\");\n                    modeNum++;\n                }\n\n                devMode.DmPelsWidth = PelsWidth;\n                devMode.DmPelsHeight = PelsHeight;\n\n                int result = NativeMethods.ChangeDisplaySettings(ref devMode, NativeMethods.CDS_TEST);\n\n                if (result == DISP_CHANGE_SUCCESSFUL)\n                {\n                    result = ChangeDisplaySettings(ref devMode, CDS_UPDATEREGISTRY);\n                    if (result == DISP_CHANGE_SUCCESSFUL)\n                    {\n                        Console.WriteLine($\"Changing display resolution to {devMode.DmPelsWidth}x{devMode.DmPelsHeight}\");\n                    }\n                    else\n                    {\n                        Console.WriteLine($\"Failed to change display resolution. Error code: {result}\");\n                    }\n                }\n                else if (result == DISP_CHANGE_RESTART)\n                {\n                    Console.WriteLine($\"Changing display resolution to {devMode.DmPelsWidth}x{devMode.DmPelsHeight} requires a restart\");\n                }\n                else\n                {\n                    Console.WriteLine($\"Failed to change display resolution. Error code: {result}\");\n                }\n            }\n        }\n    }\n}\n"
      },
      {
        "instruction": "void 반환 타입의 TestCleanup 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System.Collections.ObjectModel;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Reflection;\nusing System.Runtime.InteropServices;\nusing System.Xml.Linq;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing OpenQA.Selenium;\nusing OpenQA.Selenium.Appium;\nusing OpenQA.Selenium.Appium.Windows;\nusing Windows.Devices.Display.Core;\nusing Windows.Foundation.Metadata;\nusing static Microsoft.PowerToys.UITest.UITestBase.NativeMethods;\nusing static Microsoft.PowerToys.UITest.WindowHelper;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// Base class that should be inherited by all Test Classes.\n    /// </summary>\n    [TestClass]\n    public class UITestBase : IDisposable\n    {\n        public required TestContext TestContext { get; set; }\n\n        public required Session Session { get; set; }\n\n        public bool IsInPipeline { get; }\n\n        public static MonitorInfoData.ParamsWrapper MonitorInfoData { get; set; } = new MonitorInfoData.ParamsWrapper() { Monitors = new List<MonitorInfoData.MonitorInfoDataWrapper>() };\n\n        private readonly PowerToysModule scope;\n        private readonly WindowSize size;\n        private SessionHelper? sessionHelper;\n        private System.Threading.Timer? screenshotTimer;\n        private string? screenshotDirectory;\n\n        public UITestBase(PowerToysModule scope = PowerToysModule.PowerToysSettings, WindowSize size = WindowSize.UnSpecified)\n        {\n            this.IsInPipeline = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"platform\"));\n            Console.WriteLine($\"Running tests on platform: {Environment.GetEnvironmentVariable(\"platform\")}\");\n            if (IsInPipeline)\n            {\n                NativeMethods.ChangeDisplayResolution(1920, 1080);\n                NativeMethods.GetMonitorInfo();\n\n                // Escape Popups before starting\n                System.Windows.Forms.SendKeys.SendWait(\"{ESC}\");\n            }\n\n            this.scope = scope;\n            this.size = size;\n        }\n\n        /// <summary>\n        /// Initializes the test.\n        /// </summary>\n        [TestInitialize]\n        public void TestInit()\n        {\n            CloseOtherApplications();\n            if (IsInPipeline)\n            {\n                screenshotDirectory = Path.Combine(this.TestContext.TestResultsDirectory ?? string.Empty, \"UITestScreenshots_\" + Guid.NewGuid().ToString());\n                Directory.CreateDirectory(screenshotDirectory);\n\n                // Take screenshot every 1 second\n                screenshotTimer = new System.Threading.Timer(ScreenCapture.TimerCallback, screenshotDirectory, TimeSpan.Zero, TimeSpan.FromMilliseconds(1000));\n\n                // Escape Popups before starting\n                System.Windows.Forms.SendKeys.SendWait(\"{ESC}\");\n            }\n\n            this.sessionHelper = new SessionHelper(scope).Init();\n            this.Session = new Session(this.sessionHelper.GetRoot(), this.sessionHelper.GetDriver(), scope, size);\n\n            if (this.scope == PowerToysModule.PowerToysSettings)\n            {\n                // close Debug warning dialog if any\n                // Such debug warning dialog seems only appear in PowerToys Settings\n                if (this.FindAll(\"DEBUG\").Count > 0)\n                {\n                    this.Find(\"DEBUG\").Find<Button>(\"Close\").Click();\n                }\n            }\n        }\n\n        /// <summary>\n        /// Cleanups the test.\n        /// </summary>\n        [TestCleanup]\n        public void TestCleanup()\n        {\n            if (IsInPipeline)\n            {\n                screenshotTimer?.Change(Timeout.Infinite, Timeout.Infinite);\n                Dispose();\n                if (TestContext.CurrentTestOutcome is UnitTestOutcome.Failed\n                    or UnitTestOutcome.Error\n                    or UnitTestOutcome.Unknown)\n                {\n                    Task.Delay(1000).Wait();\n                    AddScreenShotsToTestResultsDirectory();\n                }\n            }\n\n            this.Session.Cleanup();\n            this.sessionHelper!.Cleanup();\n        }\n\n        public void Dispose()\n        {\n            screenshotTimer?.Dispose();\n            GC.SuppressFinalize(this);\n        }\n\n        /// <summary>\n        /// Finds an element by selector.\n        /// Shortcut for this.Session.Find<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected T Find<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Find<T>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(name, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected T Find<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Find<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected Element Find(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Find(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected Element Find(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Find(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Has only one Element or its derived class by selector.\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.FindAll<T>(by, timeoutMS, global).Count == 1;\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.HasOne<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<T>(name, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.HasOne<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.HasOne<Element>(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(by, timeoutMS, global).Count >= 1;\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Has<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<T>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Has<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Has<Element>(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the elements, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<T> FindAll<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the elements, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<T> FindAll<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<Element> FindAll(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.FindAll<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<Element> FindAll(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.FindAll<Element>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Scrolls the page\n        /// </summary>\n        /// <param name=\"scrollCount\">The number of scroll attempts.</param>\n        /// <param name=\"direction\">The direction to scroll.</param>\n        /// <param name=\"msPreAction\">Pre-action delay in milliseconds.</param>\n        /// <param name=\"msPostAction\">Post-action delay in milliseconds.</param>\n        public void Scroll(int scrollCount = 5, string direction = \"Up\", int msPreAction = 500, int msPostAction = 500)\n        {\n            MouseActionType mouseAction = direction == \"Up\" ? MouseActionType.ScrollUp : MouseActionType.ScrollDown;\n            for (int i = 0; i < scrollCount; i++)\n            {\n                Session.PerformMouseAction(mouseAction, msPreAction, msPostAction); // Ensure settings are visible\n            }\n        }\n\n        /// <summary>\n        /// Captures the last screenshot when the test fails.\n        /// </summary>\n        protected void CaptureLastScreenshot()\n        {\n            // Implement your screenshot capture logic here\n            // For example, save a screenshot to a file and return the file path\n            string screenshotPath = Path.Combine(this.TestContext.TestResultsDirectory ?? string.Empty, \"last_screenshot.png\");\n\n            this.Session.Root.GetScreenshot().SaveAsFile(screenshotPath, ScreenshotImageFormat.Png);\n\n            // Save screenshot to screenshotPath & upload to test attachment\n            this.TestContext.AddResultFile(screenshotPath);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public Color GetPixelColor(int x, int y)\n        {\n            return WindowHelper.GetPixelColor(x, y);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates as a string.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public string GetPixelColorString(int x, int y)\n        {\n            return WindowHelper.GetPixelColorString(x, y);\n        }\n\n        /// <summary>\n        /// Gets the size of the display.\n        /// </summary>\n        /// <returns>\n        /// A tuple containing the width and height of the display.\n        /// </returns\n        public Tuple<int, int> GetDisplaySize()\n        {\n            return WindowHelper.GetDisplaySize();\n        }\n\n        /// <summary>\n        /// Sends a combination of keys.\n        /// </summary>\n        /// <param name=\"keys\">The keys to send.</param>\n        public void SendKeys(params Key[] keys)\n        {\n            this.Session.SendKeys(keys);\n        }\n\n        /// <summary>\n        /// Sends a sequence of keys.\n        /// </summary>\n        /// <param name=\"keys\">An array of keys to send.</param>\n        public void SendKeySequence(params Key[] keys)\n        {\n            this.Session.SendKeySequence(keys);\n        }\n\n        /// <summary>\n        /// Gets the current position of the mouse cursor as a tuple.\n        /// </summary>\n        /// <returns>A tuple containing the X and Y coordinates of the cursor.</returns>\n        public Tuple<int, int> GetMousePosition()\n        {\n            return this.Session.GetMousePosition();\n        }\n\n        /// <summary>\n        /// Gets the screen center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public (int CenterX, int CenterY) GetScreenCenter()\n        {\n            return WindowHelper.GetScreenCenter();\n        }\n\n        public bool IsWindowOpen(string windowName)\n        {\n            return WindowHelper.IsWindowOpen(windowName);\n        }\n\n        /// <summary>\n        /// Moves the mouse cursor to the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The new x-coordinate of the cursor.</param>\n        /// <param name=\"y\">The new y-coordinate of the cursor.</param\n        public void MoveMouseTo(int x, int y)\n        {\n            this.Session.MoveMouseTo(x, y);\n        }\n\n        protected void AddScreenShotsToTestResultsDirectory()\n        {\n            if (screenshotDirectory != null)\n            {\n                foreach (string file in Directory.GetFiles(screenshotDirectory))\n                {\n                    this.TestContext.AddResultFile(file);\n                }\n            }\n        }\n\n        /// <summary>\n        /// Restart scope exe.\n        /// </summary>\n        public void RestartScopeExe()\n        {\n            this.sessionHelper!.RestartScopeExe();\n            this.Session = new Session(this.sessionHelper.GetRoot(), this.sessionHelper.GetDriver(), this.scope, this.size);\n            return;\n        }\n\n        /// <summary>\n        /// Restart scope exe.\n        /// </summary>\n        public void ExitScopeExe()\n        {\n            this.sessionHelper!.ExitScopeExe();\n            return;\n        }\n\n        private void CloseOtherApplications()\n        {\n            // Close other applications\n            var processNamesToClose = new List<string>\n            {\n                \"PowerToys\",\n                \"PowerToys.Settings\",\n                \"PowerToys.FancyZonesEditor\",\n            };\n            foreach (var processName in processNamesToClose)\n            {\n                foreach (var process in Process.GetProcessesByName(processName))\n                {\n                    process.Kill();\n                    process.WaitForExit();\n                }\n            }\n        }\n\n        public class NativeMethods\n        {\n            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]\n            public struct DISPLAY_DEVICE\n            {\n                public int cb;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DeviceName;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceString;\n                public int StateFlags;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceID;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceKey;\n            }\n\n            [DllImport(\"user32.dll\")]\n            private static extern int EnumDisplaySettings(IntPtr deviceName, int modeNum, ref DEVMODE devMode);\n\n            [DllImport(\"user32.dll\")]\n            private static extern int EnumDisplaySettings(string deviceName, int modeNum, ref DEVMODE devMode);\n\n            [DllImport(\"user32.dll\", CharSet = CharSet.Ansi)]\n            private static extern bool EnumDisplayDevices(IntPtr lpDevice, int iDevNum, ref DISPLAY_DEVICE lpDisplayDevice, int dwFlags);\n\n            [DllImport(\"user32.dll\")]\n            private static extern int ChangeDisplaySettings(ref DEVMODE devMode, int flags);\n\n            [DllImport(\"user32.dll\", CharSet = CharSet.Ansi)]\n            private static extern int ChangeDisplaySettingsEx(IntPtr lpszDeviceName, ref DEVMODE lpDevMode, IntPtr hwnd, uint dwflags, IntPtr lParam);\n\n            private const int DM_PELSWIDTH = 0x80000;\n            private const int DM_PELSHEIGHT = 0x100000;\n\n            public const int ENUM_CURRENT_SETTINGS = -1;\n            public const int CDS_TEST = 0x00000002;\n            public const int CDS_UPDATEREGISTRY = 0x01;\n            public const int DISP_CHANGE_SUCCESSFUL = 0;\n            public const int DISP_CHANGE_RESTART = 1;\n            public const int DISP_CHANGE_FAILED = -1;\n\n            [StructLayout(LayoutKind.Sequential)]\n            public struct DEVMODE\n            {\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DmDeviceName;\n                public short DmSpecVersion;\n                public short DmDriverVersion;\n                public short DmSize;\n                public short DmDriverExtra;\n                public int DmFields;\n                public int DmPositionX;\n                public int DmPositionY;\n                public int DmDisplayOrientation;\n                public int DmDisplayFixedOutput;\n                public short DmColor;\n                public short DmDuplex;\n                public short DmYResolution;\n                public short DmTTOption;\n                public short DmCollate;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DmFormName;\n                public short DmLogPixels;\n                public int DmBitsPerPel;\n                public int DmPelsWidth;\n                public int DmPelsHeight;\n                public int DmDisplayFlags;\n                public int DmDisplayFrequency;\n                public int DmICMMethod;\n                public int DmICMIntent;\n                public int DmMediaType;\n                public int DmDitherType;\n                public int DmReserved1;\n                public int DmReserved2;\n                public int DmPanningWidth;\n                public int DmPanningHeight;\n            }\n\n            public static void GetMonitorInfo()\n            {\n                int deviceIndex = 0;\n                DISPLAY_DEVICE d = default(DISPLAY_DEVICE);\n                d.cb = Marshal.SizeOf(d);\n\n                Console.WriteLine(\"monitor list :\");\n                while (EnumDisplayDevices(IntPtr.Zero, deviceIndex, ref d, 0))\n                {\n                    Console.WriteLine($\"monitor {deviceIndex + 1}:\");\n                    Console.WriteLine($\"  name: {d.DeviceName}\");\n                    Console.WriteLine($\"  string: {d.DeviceString}\");\n                    Console.WriteLine($\"  ID: {d.DeviceID}\");\n                    Console.WriteLine($\"  key: {d.DeviceKey}\");\n                    Console.WriteLine();\n\n                    DEVMODE dm = default(DEVMODE);\n                    dm.DmSize = (short)Marshal.SizeOf<DEVMODE>();\n                    int modeNum = 0;\n                    while (EnumDisplaySettings(d.DeviceName, modeNum, ref dm) > 0)\n                    {\n                        MonitorInfoData.Monitors.Add(new MonitorInfoData.MonitorInfoDataWrapper()\n                        {\n                            DeviceName = d.DeviceName,\n                            DeviceString = d.DeviceString,\n                            DeviceID = d.DeviceID,\n                            DeviceKey = d.DeviceKey,\n                            PelsWidth = dm.DmPelsWidth,\n                            PelsHeight = dm.DmPelsHeight,\n                            DisplayFrequency = dm.DmDisplayFrequency,\n                        });\n                        Console.WriteLine($\"  mode {modeNum}: {dm.DmPelsWidth}x{dm.DmPelsHeight} @ {dm.DmDisplayFrequency}Hz\");\n                        modeNum++;\n                    }\n\n                    deviceIndex++;\n                    d.cb = Marshal.SizeOf(d); // Reset the size for the next device\n                }\n            }\n\n            public static void ChangeDisplayResolution(int PelsWidth, int PelsHeight)\n            {\n                Screen screen = Screen.PrimaryScreen!;\n                if (screen.Bounds.Width == PelsWidth && screen.Bounds.Height == PelsHeight)\n                {\n                    return;\n                }\n\n                DEVMODE devMode = default(DEVMODE);\n                devMode.DmDeviceName = new string(new char[32]);\n                devMode.DmFormName = new string(new char[32]);\n                devMode.DmSize = (short)Marshal.SizeOf<DEVMODE>();\n\n                int modeNum = 0;\n                while (EnumDisplaySettings(IntPtr.Zero, modeNum, ref devMode) > 0)\n                {\n                    Console.WriteLine($\"Mode {modeNum}: {devMode.DmPelsWidth}x{devMode.DmPelsHeight} @ {devMode.DmDisplayFrequency}Hz\");\n                    modeNum++;\n                }\n\n                devMode.DmPelsWidth = PelsWidth;\n                devMode.DmPelsHeight = PelsHeight;\n\n                int result = NativeMethods.ChangeDisplaySettings(ref devMode, NativeMethods.CDS_TEST);\n\n                if (result == DISP_CHANGE_SUCCESSFUL)\n                {\n                    result = ChangeDisplaySettings(ref devMode, CDS_UPDATEREGISTRY);\n                    if (result == DISP_CHANGE_SUCCESSFUL)\n                    {\n                        Console.WriteLine($\"Changing display resolution to {devMode.DmPelsWidth}x{devMode.DmPelsHeight}\");\n                    }\n                    else\n                    {\n                        Console.WriteLine($\"Failed to change display resolution. Error code: {result}\");\n                    }\n                }\n                else if (result == DISP_CHANGE_RESTART)\n                {\n                    Console.WriteLine($\"Changing display resolution to {devMode.DmPelsWidth}x{devMode.DmPelsHeight} requires a restart\");\n                }\n                else\n                {\n                    Console.WriteLine($\"Failed to change display resolution. Error code: {result}\");\n                }\n            }\n        }\n    }\n}\n"
      },
      {
        "instruction": "void 반환 타입의 Dispose 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System.Collections.ObjectModel;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Reflection;\nusing System.Runtime.InteropServices;\nusing System.Xml.Linq;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing OpenQA.Selenium;\nusing OpenQA.Selenium.Appium;\nusing OpenQA.Selenium.Appium.Windows;\nusing Windows.Devices.Display.Core;\nusing Windows.Foundation.Metadata;\nusing static Microsoft.PowerToys.UITest.UITestBase.NativeMethods;\nusing static Microsoft.PowerToys.UITest.WindowHelper;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// Base class that should be inherited by all Test Classes.\n    /// </summary>\n    [TestClass]\n    public class UITestBase : IDisposable\n    {\n        public required TestContext TestContext { get; set; }\n\n        public required Session Session { get; set; }\n\n        public bool IsInPipeline { get; }\n\n        public static MonitorInfoData.ParamsWrapper MonitorInfoData { get; set; } = new MonitorInfoData.ParamsWrapper() { Monitors = new List<MonitorInfoData.MonitorInfoDataWrapper>() };\n\n        private readonly PowerToysModule scope;\n        private readonly WindowSize size;\n        private SessionHelper? sessionHelper;\n        private System.Threading.Timer? screenshotTimer;\n        private string? screenshotDirectory;\n\n        public UITestBase(PowerToysModule scope = PowerToysModule.PowerToysSettings, WindowSize size = WindowSize.UnSpecified)\n        {\n            this.IsInPipeline = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"platform\"));\n            Console.WriteLine($\"Running tests on platform: {Environment.GetEnvironmentVariable(\"platform\")}\");\n            if (IsInPipeline)\n            {\n                NativeMethods.ChangeDisplayResolution(1920, 1080);\n                NativeMethods.GetMonitorInfo();\n\n                // Escape Popups before starting\n                System.Windows.Forms.SendKeys.SendWait(\"{ESC}\");\n            }\n\n            this.scope = scope;\n            this.size = size;\n        }\n\n        /// <summary>\n        /// Initializes the test.\n        /// </summary>\n        [TestInitialize]\n        public void TestInit()\n        {\n            CloseOtherApplications();\n            if (IsInPipeline)\n            {\n                screenshotDirectory = Path.Combine(this.TestContext.TestResultsDirectory ?? string.Empty, \"UITestScreenshots_\" + Guid.NewGuid().ToString());\n                Directory.CreateDirectory(screenshotDirectory);\n\n                // Take screenshot every 1 second\n                screenshotTimer = new System.Threading.Timer(ScreenCapture.TimerCallback, screenshotDirectory, TimeSpan.Zero, TimeSpan.FromMilliseconds(1000));\n\n                // Escape Popups before starting\n                System.Windows.Forms.SendKeys.SendWait(\"{ESC}\");\n            }\n\n            this.sessionHelper = new SessionHelper(scope).Init();\n            this.Session = new Session(this.sessionHelper.GetRoot(), this.sessionHelper.GetDriver(), scope, size);\n\n            if (this.scope == PowerToysModule.PowerToysSettings)\n            {\n                // close Debug warning dialog if any\n                // Such debug warning dialog seems only appear in PowerToys Settings\n                if (this.FindAll(\"DEBUG\").Count > 0)\n                {\n                    this.Find(\"DEBUG\").Find<Button>(\"Close\").Click();\n                }\n            }\n        }\n\n        /// <summary>\n        /// Cleanups the test.\n        /// </summary>\n        [TestCleanup]\n        public void TestCleanup()\n        {\n            if (IsInPipeline)\n            {\n                screenshotTimer?.Change(Timeout.Infinite, Timeout.Infinite);\n                Dispose();\n                if (TestContext.CurrentTestOutcome is UnitTestOutcome.Failed\n                    or UnitTestOutcome.Error\n                    or UnitTestOutcome.Unknown)\n                {\n                    Task.Delay(1000).Wait();\n                    AddScreenShotsToTestResultsDirectory();\n                }\n            }\n\n            this.Session.Cleanup();\n            this.sessionHelper!.Cleanup();\n        }\n\n        public void Dispose()\n        {\n            screenshotTimer?.Dispose();\n            GC.SuppressFinalize(this);\n        }\n\n        /// <summary>\n        /// Finds an element by selector.\n        /// Shortcut for this.Session.Find<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected T Find<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Find<T>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(name, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected T Find<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Find<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected Element Find(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Find(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected Element Find(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Find(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Has only one Element or its derived class by selector.\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.FindAll<T>(by, timeoutMS, global).Count == 1;\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.HasOne<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<T>(name, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.HasOne<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.HasOne<Element>(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(by, timeoutMS, global).Count >= 1;\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Has<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<T>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Has<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Has<Element>(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the elements, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<T> FindAll<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the elements, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<T> FindAll<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<Element> FindAll(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.FindAll<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<Element> FindAll(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.FindAll<Element>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Scrolls the page\n        /// </summary>\n        /// <param name=\"scrollCount\">The number of scroll attempts.</param>\n        /// <param name=\"direction\">The direction to scroll.</param>\n        /// <param name=\"msPreAction\">Pre-action delay in milliseconds.</param>\n        /// <param name=\"msPostAction\">Post-action delay in milliseconds.</param>\n        public void Scroll(int scrollCount = 5, string direction = \"Up\", int msPreAction = 500, int msPostAction = 500)\n        {\n            MouseActionType mouseAction = direction == \"Up\" ? MouseActionType.ScrollUp : MouseActionType.ScrollDown;\n            for (int i = 0; i < scrollCount; i++)\n            {\n                Session.PerformMouseAction(mouseAction, msPreAction, msPostAction); // Ensure settings are visible\n            }\n        }\n\n        /// <summary>\n        /// Captures the last screenshot when the test fails.\n        /// </summary>\n        protected void CaptureLastScreenshot()\n        {\n            // Implement your screenshot capture logic here\n            // For example, save a screenshot to a file and return the file path\n            string screenshotPath = Path.Combine(this.TestContext.TestResultsDirectory ?? string.Empty, \"last_screenshot.png\");\n\n            this.Session.Root.GetScreenshot().SaveAsFile(screenshotPath, ScreenshotImageFormat.Png);\n\n            // Save screenshot to screenshotPath & upload to test attachment\n            this.TestContext.AddResultFile(screenshotPath);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public Color GetPixelColor(int x, int y)\n        {\n            return WindowHelper.GetPixelColor(x, y);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates as a string.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public string GetPixelColorString(int x, int y)\n        {\n            return WindowHelper.GetPixelColorString(x, y);\n        }\n\n        /// <summary>\n        /// Gets the size of the display.\n        /// </summary>\n        /// <returns>\n        /// A tuple containing the width and height of the display.\n        /// </returns\n        public Tuple<int, int> GetDisplaySize()\n        {\n            return WindowHelper.GetDisplaySize();\n        }\n\n        /// <summary>\n        /// Sends a combination of keys.\n        /// </summary>\n        /// <param name=\"keys\">The keys to send.</param>\n        public void SendKeys(params Key[] keys)\n        {\n            this.Session.SendKeys(keys);\n        }\n\n        /// <summary>\n        /// Sends a sequence of keys.\n        /// </summary>\n        /// <param name=\"keys\">An array of keys to send.</param>\n        public void SendKeySequence(params Key[] keys)\n        {\n            this.Session.SendKeySequence(keys);\n        }\n\n        /// <summary>\n        /// Gets the current position of the mouse cursor as a tuple.\n        /// </summary>\n        /// <returns>A tuple containing the X and Y coordinates of the cursor.</returns>\n        public Tuple<int, int> GetMousePosition()\n        {\n            return this.Session.GetMousePosition();\n        }\n\n        /// <summary>\n        /// Gets the screen center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public (int CenterX, int CenterY) GetScreenCenter()\n        {\n            return WindowHelper.GetScreenCenter();\n        }\n\n        public bool IsWindowOpen(string windowName)\n        {\n            return WindowHelper.IsWindowOpen(windowName);\n        }\n\n        /// <summary>\n        /// Moves the mouse cursor to the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The new x-coordinate of the cursor.</param>\n        /// <param name=\"y\">The new y-coordinate of the cursor.</param\n        public void MoveMouseTo(int x, int y)\n        {\n            this.Session.MoveMouseTo(x, y);\n        }\n\n        protected void AddScreenShotsToTestResultsDirectory()\n        {\n            if (screenshotDirectory != null)\n            {\n                foreach (string file in Directory.GetFiles(screenshotDirectory))\n                {\n                    this.TestContext.AddResultFile(file);\n                }\n            }\n        }\n\n        /// <summary>\n        /// Restart scope exe.\n        /// </summary>\n        public void RestartScopeExe()\n        {\n            this.sessionHelper!.RestartScopeExe();\n            this.Session = new Session(this.sessionHelper.GetRoot(), this.sessionHelper.GetDriver(), this.scope, this.size);\n            return;\n        }\n\n        /// <summary>\n        /// Restart scope exe.\n        /// </summary>\n        public void ExitScopeExe()\n        {\n            this.sessionHelper!.ExitScopeExe();\n            return;\n        }\n\n        private void CloseOtherApplications()\n        {\n            // Close other applications\n            var processNamesToClose = new List<string>\n            {\n                \"PowerToys\",\n                \"PowerToys.Settings\",\n                \"PowerToys.FancyZonesEditor\",\n            };\n            foreach (var processName in processNamesToClose)\n            {\n                foreach (var process in Process.GetProcessesByName(processName))\n                {\n                    process.Kill();\n                    process.WaitForExit();\n                }\n            }\n        }\n\n        public class NativeMethods\n        {\n            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]\n            public struct DISPLAY_DEVICE\n            {\n                public int cb;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DeviceName;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceString;\n                public int StateFlags;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceID;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceKey;\n            }\n\n            [DllImport(\"user32.dll\")]\n            private static extern int EnumDisplaySettings(IntPtr deviceName, int modeNum, ref DEVMODE devMode);\n\n            [DllImport(\"user32.dll\")]\n            private static extern int EnumDisplaySettings(string deviceName, int modeNum, ref DEVMODE devMode);\n\n            [DllImport(\"user32.dll\", CharSet = CharSet.Ansi)]\n            private static extern bool EnumDisplayDevices(IntPtr lpDevice, int iDevNum, ref DISPLAY_DEVICE lpDisplayDevice, int dwFlags);\n\n            [DllImport(\"user32.dll\")]\n            private static extern int ChangeDisplaySettings(ref DEVMODE devMode, int flags);\n\n            [DllImport(\"user32.dll\", CharSet = CharSet.Ansi)]\n            private static extern int ChangeDisplaySettingsEx(IntPtr lpszDeviceName, ref DEVMODE lpDevMode, IntPtr hwnd, uint dwflags, IntPtr lParam);\n\n            private const int DM_PELSWIDTH = 0x80000;\n            private const int DM_PELSHEIGHT = 0x100000;\n\n            public const int ENUM_CURRENT_SETTINGS = -1;\n            public const int CDS_TEST = 0x00000002;\n            public const int CDS_UPDATEREGISTRY = 0x01;\n            public const int DISP_CHANGE_SUCCESSFUL = 0;\n            public const int DISP_CHANGE_RESTART = 1;\n            public const int DISP_CHANGE_FAILED = -1;\n\n            [StructLayout(LayoutKind.Sequential)]\n            public struct DEVMODE\n            {\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DmDeviceName;\n                public short DmSpecVersion;\n                public short DmDriverVersion;\n                public short DmSize;\n                public short DmDriverExtra;\n                public int DmFields;\n                public int DmPositionX;\n                public int DmPositionY;\n                public int DmDisplayOrientation;\n                public int DmDisplayFixedOutput;\n                public short DmColor;\n                public short DmDuplex;\n                public short DmYResolution;\n                public short DmTTOption;\n                public short DmCollate;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DmFormName;\n                public short DmLogPixels;\n                public int DmBitsPerPel;\n                public int DmPelsWidth;\n                public int DmPelsHeight;\n                public int DmDisplayFlags;\n                public int DmDisplayFrequency;\n                public int DmICMMethod;\n                public int DmICMIntent;\n                public int DmMediaType;\n                public int DmDitherType;\n                public int DmReserved1;\n                public int DmReserved2;\n                public int DmPanningWidth;\n                public int DmPanningHeight;\n            }\n\n            public static void GetMonitorInfo()\n            {\n                int deviceIndex = 0;\n                DISPLAY_DEVICE d = default(DISPLAY_DEVICE);\n                d.cb = Marshal.SizeOf(d);\n\n                Console.WriteLine(\"monitor list :\");\n                while (EnumDisplayDevices(IntPtr.Zero, deviceIndex, ref d, 0))\n                {\n                    Console.WriteLine($\"monitor {deviceIndex + 1}:\");\n                    Console.WriteLine($\"  name: {d.DeviceName}\");\n                    Console.WriteLine($\"  string: {d.DeviceString}\");\n                    Console.WriteLine($\"  ID: {d.DeviceID}\");\n                    Console.WriteLine($\"  key: {d.DeviceKey}\");\n                    Console.WriteLine();\n\n                    DEVMODE dm = default(DEVMODE);\n                    dm.DmSize = (short)Marshal.SizeOf<DEVMODE>();\n                    int modeNum = 0;\n                    while (EnumDisplaySettings(d.DeviceName, modeNum, ref dm) > 0)\n                    {\n                        MonitorInfoData.Monitors.Add(new MonitorInfoData.MonitorInfoDataWrapper()\n                        {\n                            DeviceName = d.DeviceName,\n                            DeviceString = d.DeviceString,\n                            DeviceID = d.DeviceID,\n                            DeviceKey = d.DeviceKey,\n                            PelsWidth = dm.DmPelsWidth,\n                            PelsHeight = dm.DmPelsHeight,\n                            DisplayFrequency = dm.DmDisplayFrequency,\n                        });\n                        Console.WriteLine($\"  mode {modeNum}: {dm.DmPelsWidth}x{dm.DmPelsHeight} @ {dm.DmDisplayFrequency}Hz\");\n                        modeNum++;\n                    }\n\n                    deviceIndex++;\n                    d.cb = Marshal.SizeOf(d); // Reset the size for the next device\n                }\n            }\n\n            public static void ChangeDisplayResolution(int PelsWidth, int PelsHeight)\n            {\n                Screen screen = Screen.PrimaryScreen!;\n                if (screen.Bounds.Width == PelsWidth && screen.Bounds.Height == PelsHeight)\n                {\n                    return;\n                }\n\n                DEVMODE devMode = default(DEVMODE);\n                devMode.DmDeviceName = new string(new char[32]);\n                devMode.DmFormName = new string(new char[32]);\n                devMode.DmSize = (short)Marshal.SizeOf<DEVMODE>();\n\n                int modeNum = 0;\n                while (EnumDisplaySettings(IntPtr.Zero, modeNum, ref devMode) > 0)\n                {\n                    Console.WriteLine($\"Mode {modeNum}: {devMode.DmPelsWidth}x{devMode.DmPelsHeight} @ {devMode.DmDisplayFrequency}Hz\");\n                    modeNum++;\n                }\n\n                devMode.DmPelsWidth = PelsWidth;\n                devMode.DmPelsHeight = PelsHeight;\n\n                int result = NativeMethods.ChangeDisplaySettings(ref devMode, NativeMethods.CDS_TEST);\n\n                if (result == DISP_CHANGE_SUCCESSFUL)\n                {\n                    result = ChangeDisplaySettings(ref devMode, CDS_UPDATEREGISTRY);\n                    if (result == DISP_CHANGE_SUCCESSFUL)\n                    {\n                        Console.WriteLine($\"Changing display resolution to {devMode.DmPelsWidth}x{devMode.DmPelsHeight}\");\n                    }\n                    else\n                    {\n                        Console.WriteLine($\"Failed to change display resolution. Error code: {result}\");\n                    }\n                }\n                else if (result == DISP_CHANGE_RESTART)\n                {\n                    Console.WriteLine($\"Changing display resolution to {devMode.DmPelsWidth}x{devMode.DmPelsHeight} requires a restart\");\n                }\n                else\n                {\n                    Console.WriteLine($\"Failed to change display resolution. Error code: {result}\");\n                }\n            }\n        }\n    }\n}\n"
      },
      {
        "instruction": "bool 반환 타입의 HasOne 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System.Collections.ObjectModel;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Reflection;\nusing System.Runtime.InteropServices;\nusing System.Xml.Linq;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing OpenQA.Selenium;\nusing OpenQA.Selenium.Appium;\nusing OpenQA.Selenium.Appium.Windows;\nusing Windows.Devices.Display.Core;\nusing Windows.Foundation.Metadata;\nusing static Microsoft.PowerToys.UITest.UITestBase.NativeMethods;\nusing static Microsoft.PowerToys.UITest.WindowHelper;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// Base class that should be inherited by all Test Classes.\n    /// </summary>\n    [TestClass]\n    public class UITestBase : IDisposable\n    {\n        public required TestContext TestContext { get; set; }\n\n        public required Session Session { get; set; }\n\n        public bool IsInPipeline { get; }\n\n        public static MonitorInfoData.ParamsWrapper MonitorInfoData { get; set; } = new MonitorInfoData.ParamsWrapper() { Monitors = new List<MonitorInfoData.MonitorInfoDataWrapper>() };\n\n        private readonly PowerToysModule scope;\n        private readonly WindowSize size;\n        private SessionHelper? sessionHelper;\n        private System.Threading.Timer? screenshotTimer;\n        private string? screenshotDirectory;\n\n        public UITestBase(PowerToysModule scope = PowerToysModule.PowerToysSettings, WindowSize size = WindowSize.UnSpecified)\n        {\n            this.IsInPipeline = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"platform\"));\n            Console.WriteLine($\"Running tests on platform: {Environment.GetEnvironmentVariable(\"platform\")}\");\n            if (IsInPipeline)\n            {\n                NativeMethods.ChangeDisplayResolution(1920, 1080);\n                NativeMethods.GetMonitorInfo();\n\n                // Escape Popups before starting\n                System.Windows.Forms.SendKeys.SendWait(\"{ESC}\");\n            }\n\n            this.scope = scope;\n            this.size = size;\n        }\n\n        /// <summary>\n        /// Initializes the test.\n        /// </summary>\n        [TestInitialize]\n        public void TestInit()\n        {\n            CloseOtherApplications();\n            if (IsInPipeline)\n            {\n                screenshotDirectory = Path.Combine(this.TestContext.TestResultsDirectory ?? string.Empty, \"UITestScreenshots_\" + Guid.NewGuid().ToString());\n                Directory.CreateDirectory(screenshotDirectory);\n\n                // Take screenshot every 1 second\n                screenshotTimer = new System.Threading.Timer(ScreenCapture.TimerCallback, screenshotDirectory, TimeSpan.Zero, TimeSpan.FromMilliseconds(1000));\n\n                // Escape Popups before starting\n                System.Windows.Forms.SendKeys.SendWait(\"{ESC}\");\n            }\n\n            this.sessionHelper = new SessionHelper(scope).Init();\n            this.Session = new Session(this.sessionHelper.GetRoot(), this.sessionHelper.GetDriver(), scope, size);\n\n            if (this.scope == PowerToysModule.PowerToysSettings)\n            {\n                // close Debug warning dialog if any\n                // Such debug warning dialog seems only appear in PowerToys Settings\n                if (this.FindAll(\"DEBUG\").Count > 0)\n                {\n                    this.Find(\"DEBUG\").Find<Button>(\"Close\").Click();\n                }\n            }\n        }\n\n        /// <summary>\n        /// Cleanups the test.\n        /// </summary>\n        [TestCleanup]\n        public void TestCleanup()\n        {\n            if (IsInPipeline)\n            {\n                screenshotTimer?.Change(Timeout.Infinite, Timeout.Infinite);\n                Dispose();\n                if (TestContext.CurrentTestOutcome is UnitTestOutcome.Failed\n                    or UnitTestOutcome.Error\n                    or UnitTestOutcome.Unknown)\n                {\n                    Task.Delay(1000).Wait();\n                    AddScreenShotsToTestResultsDirectory();\n                }\n            }\n\n            this.Session.Cleanup();\n            this.sessionHelper!.Cleanup();\n        }\n\n        public void Dispose()\n        {\n            screenshotTimer?.Dispose();\n            GC.SuppressFinalize(this);\n        }\n\n        /// <summary>\n        /// Finds an element by selector.\n        /// Shortcut for this.Session.Find<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected T Find<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Find<T>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(name, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected T Find<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Find<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected Element Find(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Find(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected Element Find(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Find(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Has only one Element or its derived class by selector.\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.FindAll<T>(by, timeoutMS, global).Count == 1;\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.HasOne<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<T>(name, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.HasOne<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.HasOne<Element>(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(by, timeoutMS, global).Count >= 1;\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Has<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<T>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Has<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Has<Element>(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the elements, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<T> FindAll<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the elements, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<T> FindAll<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<Element> FindAll(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.FindAll<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<Element> FindAll(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.FindAll<Element>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Scrolls the page\n        /// </summary>\n        /// <param name=\"scrollCount\">The number of scroll attempts.</param>\n        /// <param name=\"direction\">The direction to scroll.</param>\n        /// <param name=\"msPreAction\">Pre-action delay in milliseconds.</param>\n        /// <param name=\"msPostAction\">Post-action delay in milliseconds.</param>\n        public void Scroll(int scrollCount = 5, string direction = \"Up\", int msPreAction = 500, int msPostAction = 500)\n        {\n            MouseActionType mouseAction = direction == \"Up\" ? MouseActionType.ScrollUp : MouseActionType.ScrollDown;\n            for (int i = 0; i < scrollCount; i++)\n            {\n                Session.PerformMouseAction(mouseAction, msPreAction, msPostAction); // Ensure settings are visible\n            }\n        }\n\n        /// <summary>\n        /// Captures the last screenshot when the test fails.\n        /// </summary>\n        protected void CaptureLastScreenshot()\n        {\n            // Implement your screenshot capture logic here\n            // For example, save a screenshot to a file and return the file path\n            string screenshotPath = Path.Combine(this.TestContext.TestResultsDirectory ?? string.Empty, \"last_screenshot.png\");\n\n            this.Session.Root.GetScreenshot().SaveAsFile(screenshotPath, ScreenshotImageFormat.Png);\n\n            // Save screenshot to screenshotPath & upload to test attachment\n            this.TestContext.AddResultFile(screenshotPath);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public Color GetPixelColor(int x, int y)\n        {\n            return WindowHelper.GetPixelColor(x, y);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates as a string.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public string GetPixelColorString(int x, int y)\n        {\n            return WindowHelper.GetPixelColorString(x, y);\n        }\n\n        /// <summary>\n        /// Gets the size of the display.\n        /// </summary>\n        /// <returns>\n        /// A tuple containing the width and height of the display.\n        /// </returns\n        public Tuple<int, int> GetDisplaySize()\n        {\n            return WindowHelper.GetDisplaySize();\n        }\n\n        /// <summary>\n        /// Sends a combination of keys.\n        /// </summary>\n        /// <param name=\"keys\">The keys to send.</param>\n        public void SendKeys(params Key[] keys)\n        {\n            this.Session.SendKeys(keys);\n        }\n\n        /// <summary>\n        /// Sends a sequence of keys.\n        /// </summary>\n        /// <param name=\"keys\">An array of keys to send.</param>\n        public void SendKeySequence(params Key[] keys)\n        {\n            this.Session.SendKeySequence(keys);\n        }\n\n        /// <summary>\n        /// Gets the current position of the mouse cursor as a tuple.\n        /// </summary>\n        /// <returns>A tuple containing the X and Y coordinates of the cursor.</returns>\n        public Tuple<int, int> GetMousePosition()\n        {\n            return this.Session.GetMousePosition();\n        }\n\n        /// <summary>\n        /// Gets the screen center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public (int CenterX, int CenterY) GetScreenCenter()\n        {\n            return WindowHelper.GetScreenCenter();\n        }\n\n        public bool IsWindowOpen(string windowName)\n        {\n            return WindowHelper.IsWindowOpen(windowName);\n        }\n\n        /// <summary>\n        /// Moves the mouse cursor to the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The new x-coordinate of the cursor.</param>\n        /// <param name=\"y\">The new y-coordinate of the cursor.</param\n        public void MoveMouseTo(int x, int y)\n        {\n            this.Session.MoveMouseTo(x, y);\n        }\n\n        protected void AddScreenShotsToTestResultsDirectory()\n        {\n            if (screenshotDirectory != null)\n            {\n                foreach (string file in Directory.GetFiles(screenshotDirectory))\n                {\n                    this.TestContext.AddResultFile(file);\n                }\n            }\n        }\n\n        /// <summary>\n        /// Restart scope exe.\n        /// </summary>\n        public void RestartScopeExe()\n        {\n            this.sessionHelper!.RestartScopeExe();\n            this.Session = new Session(this.sessionHelper.GetRoot(), this.sessionHelper.GetDriver(), this.scope, this.size);\n            return;\n        }\n\n        /// <summary>\n        /// Restart scope exe.\n        /// </summary>\n        public void ExitScopeExe()\n        {\n            this.sessionHelper!.ExitScopeExe();\n            return;\n        }\n\n        private void CloseOtherApplications()\n        {\n            // Close other applications\n            var processNamesToClose = new List<string>\n            {\n                \"PowerToys\",\n                \"PowerToys.Settings\",\n                \"PowerToys.FancyZonesEditor\",\n            };\n            foreach (var processName in processNamesToClose)\n            {\n                foreach (var process in Process.GetProcessesByName(processName))\n                {\n                    process.Kill();\n                    process.WaitForExit();\n                }\n            }\n        }\n\n        public class NativeMethods\n        {\n            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]\n            public struct DISPLAY_DEVICE\n            {\n                public int cb;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DeviceName;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceString;\n                public int StateFlags;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceID;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceKey;\n            }\n\n            [DllImport(\"user32.dll\")]\n            private static extern int EnumDisplaySettings(IntPtr deviceName, int modeNum, ref DEVMODE devMode);\n\n            [DllImport(\"user32.dll\")]\n            private static extern int EnumDisplaySettings(string deviceName, int modeNum, ref DEVMODE devMode);\n\n            [DllImport(\"user32.dll\", CharSet = CharSet.Ansi)]\n            private static extern bool EnumDisplayDevices(IntPtr lpDevice, int iDevNum, ref DISPLAY_DEVICE lpDisplayDevice, int dwFlags);\n\n            [DllImport(\"user32.dll\")]\n            private static extern int ChangeDisplaySettings(ref DEVMODE devMode, int flags);\n\n            [DllImport(\"user32.dll\", CharSet = CharSet.Ansi)]\n            private static extern int ChangeDisplaySettingsEx(IntPtr lpszDeviceName, ref DEVMODE lpDevMode, IntPtr hwnd, uint dwflags, IntPtr lParam);\n\n            private const int DM_PELSWIDTH = 0x80000;\n            private const int DM_PELSHEIGHT = 0x100000;\n\n            public const int ENUM_CURRENT_SETTINGS = -1;\n            public const int CDS_TEST = 0x00000002;\n            public const int CDS_UPDATEREGISTRY = 0x01;\n            public const int DISP_CHANGE_SUCCESSFUL = 0;\n            public const int DISP_CHANGE_RESTART = 1;\n            public const int DISP_CHANGE_FAILED = -1;\n\n            [StructLayout(LayoutKind.Sequential)]\n            public struct DEVMODE\n            {\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DmDeviceName;\n                public short DmSpecVersion;\n                public short DmDriverVersion;\n                public short DmSize;\n                public short DmDriverExtra;\n                public int DmFields;\n                public int DmPositionX;\n                public int DmPositionY;\n                public int DmDisplayOrientation;\n                public int DmDisplayFixedOutput;\n                public short DmColor;\n                public short DmDuplex;\n                public short DmYResolution;\n                public short DmTTOption;\n                public short DmCollate;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DmFormName;\n                public short DmLogPixels;\n                public int DmBitsPerPel;\n                public int DmPelsWidth;\n                public int DmPelsHeight;\n                public int DmDisplayFlags;\n                public int DmDisplayFrequency;\n                public int DmICMMethod;\n                public int DmICMIntent;\n                public int DmMediaType;\n                public int DmDitherType;\n                public int DmReserved1;\n                public int DmReserved2;\n                public int DmPanningWidth;\n                public int DmPanningHeight;\n            }\n\n            public static void GetMonitorInfo()\n            {\n                int deviceIndex = 0;\n                DISPLAY_DEVICE d = default(DISPLAY_DEVICE);\n                d.cb = Marshal.SizeOf(d);\n\n                Console.WriteLine(\"monitor list :\");\n                while (EnumDisplayDevices(IntPtr.Zero, deviceIndex, ref d, 0))\n                {\n                    Console.WriteLine($\"monitor {deviceIndex + 1}:\");\n                    Console.WriteLine($\"  name: {d.DeviceName}\");\n                    Console.WriteLine($\"  string: {d.DeviceString}\");\n                    Console.WriteLine($\"  ID: {d.DeviceID}\");\n                    Console.WriteLine($\"  key: {d.DeviceKey}\");\n                    Console.WriteLine();\n\n                    DEVMODE dm = default(DEVMODE);\n                    dm.DmSize = (short)Marshal.SizeOf<DEVMODE>();\n                    int modeNum = 0;\n                    while (EnumDisplaySettings(d.DeviceName, modeNum, ref dm) > 0)\n                    {\n                        MonitorInfoData.Monitors.Add(new MonitorInfoData.MonitorInfoDataWrapper()\n                        {\n                            DeviceName = d.DeviceName,\n                            DeviceString = d.DeviceString,\n                            DeviceID = d.DeviceID,\n                            DeviceKey = d.DeviceKey,\n                            PelsWidth = dm.DmPelsWidth,\n                            PelsHeight = dm.DmPelsHeight,\n                            DisplayFrequency = dm.DmDisplayFrequency,\n                        });\n                        Console.WriteLine($\"  mode {modeNum}: {dm.DmPelsWidth}x{dm.DmPelsHeight} @ {dm.DmDisplayFrequency}Hz\");\n                        modeNum++;\n                    }\n\n                    deviceIndex++;\n                    d.cb = Marshal.SizeOf(d); // Reset the size for the next device\n                }\n            }\n\n            public static void ChangeDisplayResolution(int PelsWidth, int PelsHeight)\n            {\n                Screen screen = Screen.PrimaryScreen!;\n                if (screen.Bounds.Width == PelsWidth && screen.Bounds.Height == PelsHeight)\n                {\n                    return;\n                }\n\n                DEVMODE devMode = default(DEVMODE);\n                devMode.DmDeviceName = new string(new char[32]);\n                devMode.DmFormName = new string(new char[32]);\n                devMode.DmSize = (short)Marshal.SizeOf<DEVMODE>();\n\n                int modeNum = 0;\n                while (EnumDisplaySettings(IntPtr.Zero, modeNum, ref devMode) > 0)\n                {\n                    Console.WriteLine($\"Mode {modeNum}: {devMode.DmPelsWidth}x{devMode.DmPelsHeight} @ {devMode.DmDisplayFrequency}Hz\");\n                    modeNum++;\n                }\n\n                devMode.DmPelsWidth = PelsWidth;\n                devMode.DmPelsHeight = PelsHeight;\n\n                int result = NativeMethods.ChangeDisplaySettings(ref devMode, NativeMethods.CDS_TEST);\n\n                if (result == DISP_CHANGE_SUCCESSFUL)\n                {\n                    result = ChangeDisplaySettings(ref devMode, CDS_UPDATEREGISTRY);\n                    if (result == DISP_CHANGE_SUCCESSFUL)\n                    {\n                        Console.WriteLine($\"Changing display resolution to {devMode.DmPelsWidth}x{devMode.DmPelsHeight}\");\n                    }\n                    else\n                    {\n                        Console.WriteLine($\"Failed to change display resolution. Error code: {result}\");\n                    }\n                }\n                else if (result == DISP_CHANGE_RESTART)\n                {\n                    Console.WriteLine($\"Changing display resolution to {devMode.DmPelsWidth}x{devMode.DmPelsHeight} requires a restart\");\n                }\n                else\n                {\n                    Console.WriteLine($\"Failed to change display resolution. Error code: {result}\");\n                }\n            }\n        }\n    }\n}\n"
      },
      {
        "instruction": "bool 반환 타입의 HasOne 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System.Collections.ObjectModel;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Reflection;\nusing System.Runtime.InteropServices;\nusing System.Xml.Linq;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing OpenQA.Selenium;\nusing OpenQA.Selenium.Appium;\nusing OpenQA.Selenium.Appium.Windows;\nusing Windows.Devices.Display.Core;\nusing Windows.Foundation.Metadata;\nusing static Microsoft.PowerToys.UITest.UITestBase.NativeMethods;\nusing static Microsoft.PowerToys.UITest.WindowHelper;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// Base class that should be inherited by all Test Classes.\n    /// </summary>\n    [TestClass]\n    public class UITestBase : IDisposable\n    {\n        public required TestContext TestContext { get; set; }\n\n        public required Session Session { get; set; }\n\n        public bool IsInPipeline { get; }\n\n        public static MonitorInfoData.ParamsWrapper MonitorInfoData { get; set; } = new MonitorInfoData.ParamsWrapper() { Monitors = new List<MonitorInfoData.MonitorInfoDataWrapper>() };\n\n        private readonly PowerToysModule scope;\n        private readonly WindowSize size;\n        private SessionHelper? sessionHelper;\n        private System.Threading.Timer? screenshotTimer;\n        private string? screenshotDirectory;\n\n        public UITestBase(PowerToysModule scope = PowerToysModule.PowerToysSettings, WindowSize size = WindowSize.UnSpecified)\n        {\n            this.IsInPipeline = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"platform\"));\n            Console.WriteLine($\"Running tests on platform: {Environment.GetEnvironmentVariable(\"platform\")}\");\n            if (IsInPipeline)\n            {\n                NativeMethods.ChangeDisplayResolution(1920, 1080);\n                NativeMethods.GetMonitorInfo();\n\n                // Escape Popups before starting\n                System.Windows.Forms.SendKeys.SendWait(\"{ESC}\");\n            }\n\n            this.scope = scope;\n            this.size = size;\n        }\n\n        /// <summary>\n        /// Initializes the test.\n        /// </summary>\n        [TestInitialize]\n        public void TestInit()\n        {\n            CloseOtherApplications();\n            if (IsInPipeline)\n            {\n                screenshotDirectory = Path.Combine(this.TestContext.TestResultsDirectory ?? string.Empty, \"UITestScreenshots_\" + Guid.NewGuid().ToString());\n                Directory.CreateDirectory(screenshotDirectory);\n\n                // Take screenshot every 1 second\n                screenshotTimer = new System.Threading.Timer(ScreenCapture.TimerCallback, screenshotDirectory, TimeSpan.Zero, TimeSpan.FromMilliseconds(1000));\n\n                // Escape Popups before starting\n                System.Windows.Forms.SendKeys.SendWait(\"{ESC}\");\n            }\n\n            this.sessionHelper = new SessionHelper(scope).Init();\n            this.Session = new Session(this.sessionHelper.GetRoot(), this.sessionHelper.GetDriver(), scope, size);\n\n            if (this.scope == PowerToysModule.PowerToysSettings)\n            {\n                // close Debug warning dialog if any\n                // Such debug warning dialog seems only appear in PowerToys Settings\n                if (this.FindAll(\"DEBUG\").Count > 0)\n                {\n                    this.Find(\"DEBUG\").Find<Button>(\"Close\").Click();\n                }\n            }\n        }\n\n        /// <summary>\n        /// Cleanups the test.\n        /// </summary>\n        [TestCleanup]\n        public void TestCleanup()\n        {\n            if (IsInPipeline)\n            {\n                screenshotTimer?.Change(Timeout.Infinite, Timeout.Infinite);\n                Dispose();\n                if (TestContext.CurrentTestOutcome is UnitTestOutcome.Failed\n                    or UnitTestOutcome.Error\n                    or UnitTestOutcome.Unknown)\n                {\n                    Task.Delay(1000).Wait();\n                    AddScreenShotsToTestResultsDirectory();\n                }\n            }\n\n            this.Session.Cleanup();\n            this.sessionHelper!.Cleanup();\n        }\n\n        public void Dispose()\n        {\n            screenshotTimer?.Dispose();\n            GC.SuppressFinalize(this);\n        }\n\n        /// <summary>\n        /// Finds an element by selector.\n        /// Shortcut for this.Session.Find<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected T Find<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Find<T>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(name, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected T Find<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Find<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected Element Find(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Find(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected Element Find(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Find(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Has only one Element or its derived class by selector.\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.FindAll<T>(by, timeoutMS, global).Count == 1;\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.HasOne<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<T>(name, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.HasOne<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.HasOne<Element>(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(by, timeoutMS, global).Count >= 1;\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Has<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<T>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Has<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Has<Element>(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the elements, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<T> FindAll<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the elements, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<T> FindAll<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<Element> FindAll(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.FindAll<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<Element> FindAll(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.FindAll<Element>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Scrolls the page\n        /// </summary>\n        /// <param name=\"scrollCount\">The number of scroll attempts.</param>\n        /// <param name=\"direction\">The direction to scroll.</param>\n        /// <param name=\"msPreAction\">Pre-action delay in milliseconds.</param>\n        /// <param name=\"msPostAction\">Post-action delay in milliseconds.</param>\n        public void Scroll(int scrollCount = 5, string direction = \"Up\", int msPreAction = 500, int msPostAction = 500)\n        {\n            MouseActionType mouseAction = direction == \"Up\" ? MouseActionType.ScrollUp : MouseActionType.ScrollDown;\n            for (int i = 0; i < scrollCount; i++)\n            {\n                Session.PerformMouseAction(mouseAction, msPreAction, msPostAction); // Ensure settings are visible\n            }\n        }\n\n        /// <summary>\n        /// Captures the last screenshot when the test fails.\n        /// </summary>\n        protected void CaptureLastScreenshot()\n        {\n            // Implement your screenshot capture logic here\n            // For example, save a screenshot to a file and return the file path\n            string screenshotPath = Path.Combine(this.TestContext.TestResultsDirectory ?? string.Empty, \"last_screenshot.png\");\n\n            this.Session.Root.GetScreenshot().SaveAsFile(screenshotPath, ScreenshotImageFormat.Png);\n\n            // Save screenshot to screenshotPath & upload to test attachment\n            this.TestContext.AddResultFile(screenshotPath);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public Color GetPixelColor(int x, int y)\n        {\n            return WindowHelper.GetPixelColor(x, y);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates as a string.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public string GetPixelColorString(int x, int y)\n        {\n            return WindowHelper.GetPixelColorString(x, y);\n        }\n\n        /// <summary>\n        /// Gets the size of the display.\n        /// </summary>\n        /// <returns>\n        /// A tuple containing the width and height of the display.\n        /// </returns\n        public Tuple<int, int> GetDisplaySize()\n        {\n            return WindowHelper.GetDisplaySize();\n        }\n\n        /// <summary>\n        /// Sends a combination of keys.\n        /// </summary>\n        /// <param name=\"keys\">The keys to send.</param>\n        public void SendKeys(params Key[] keys)\n        {\n            this.Session.SendKeys(keys);\n        }\n\n        /// <summary>\n        /// Sends a sequence of keys.\n        /// </summary>\n        /// <param name=\"keys\">An array of keys to send.</param>\n        public void SendKeySequence(params Key[] keys)\n        {\n            this.Session.SendKeySequence(keys);\n        }\n\n        /// <summary>\n        /// Gets the current position of the mouse cursor as a tuple.\n        /// </summary>\n        /// <returns>A tuple containing the X and Y coordinates of the cursor.</returns>\n        public Tuple<int, int> GetMousePosition()\n        {\n            return this.Session.GetMousePosition();\n        }\n\n        /// <summary>\n        /// Gets the screen center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public (int CenterX, int CenterY) GetScreenCenter()\n        {\n            return WindowHelper.GetScreenCenter();\n        }\n\n        public bool IsWindowOpen(string windowName)\n        {\n            return WindowHelper.IsWindowOpen(windowName);\n        }\n\n        /// <summary>\n        /// Moves the mouse cursor to the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The new x-coordinate of the cursor.</param>\n        /// <param name=\"y\">The new y-coordinate of the cursor.</param\n        public void MoveMouseTo(int x, int y)\n        {\n            this.Session.MoveMouseTo(x, y);\n        }\n\n        protected void AddScreenShotsToTestResultsDirectory()\n        {\n            if (screenshotDirectory != null)\n            {\n                foreach (string file in Directory.GetFiles(screenshotDirectory))\n                {\n                    this.TestContext.AddResultFile(file);\n                }\n            }\n        }\n\n        /// <summary>\n        /// Restart scope exe.\n        /// </summary>\n        public void RestartScopeExe()\n        {\n            this.sessionHelper!.RestartScopeExe();\n            this.Session = new Session(this.sessionHelper.GetRoot(), this.sessionHelper.GetDriver(), this.scope, this.size);\n            return;\n        }\n\n        /// <summary>\n        /// Restart scope exe.\n        /// </summary>\n        public void ExitScopeExe()\n        {\n            this.sessionHelper!.ExitScopeExe();\n            return;\n        }\n\n        private void CloseOtherApplications()\n        {\n            // Close other applications\n            var processNamesToClose = new List<string>\n            {\n                \"PowerToys\",\n                \"PowerToys.Settings\",\n                \"PowerToys.FancyZonesEditor\",\n            };\n            foreach (var processName in processNamesToClose)\n            {\n                foreach (var process in Process.GetProcessesByName(processName))\n                {\n                    process.Kill();\n                    process.WaitForExit();\n                }\n            }\n        }\n\n        public class NativeMethods\n        {\n            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]\n            public struct DISPLAY_DEVICE\n            {\n                public int cb;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DeviceName;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceString;\n                public int StateFlags;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceID;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceKey;\n            }\n\n            [DllImport(\"user32.dll\")]\n            private static extern int EnumDisplaySettings(IntPtr deviceName, int modeNum, ref DEVMODE devMode);\n\n            [DllImport(\"user32.dll\")]\n            private static extern int EnumDisplaySettings(string deviceName, int modeNum, ref DEVMODE devMode);\n\n            [DllImport(\"user32.dll\", CharSet = CharSet.Ansi)]\n            private static extern bool EnumDisplayDevices(IntPtr lpDevice, int iDevNum, ref DISPLAY_DEVICE lpDisplayDevice, int dwFlags);\n\n            [DllImport(\"user32.dll\")]\n            private static extern int ChangeDisplaySettings(ref DEVMODE devMode, int flags);\n\n            [DllImport(\"user32.dll\", CharSet = CharSet.Ansi)]\n            private static extern int ChangeDisplaySettingsEx(IntPtr lpszDeviceName, ref DEVMODE lpDevMode, IntPtr hwnd, uint dwflags, IntPtr lParam);\n\n            private const int DM_PELSWIDTH = 0x80000;\n            private const int DM_PELSHEIGHT = 0x100000;\n\n            public const int ENUM_CURRENT_SETTINGS = -1;\n            public const int CDS_TEST = 0x00000002;\n            public const int CDS_UPDATEREGISTRY = 0x01;\n            public const int DISP_CHANGE_SUCCESSFUL = 0;\n            public const int DISP_CHANGE_RESTART = 1;\n            public const int DISP_CHANGE_FAILED = -1;\n\n            [StructLayout(LayoutKind.Sequential)]\n            public struct DEVMODE\n            {\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DmDeviceName;\n                public short DmSpecVersion;\n                public short DmDriverVersion;\n                public short DmSize;\n                public short DmDriverExtra;\n                public int DmFields;\n                public int DmPositionX;\n                public int DmPositionY;\n                public int DmDisplayOrientation;\n                public int DmDisplayFixedOutput;\n                public short DmColor;\n                public short DmDuplex;\n                public short DmYResolution;\n                public short DmTTOption;\n                public short DmCollate;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DmFormName;\n                public short DmLogPixels;\n                public int DmBitsPerPel;\n                public int DmPelsWidth;\n                public int DmPelsHeight;\n                public int DmDisplayFlags;\n                public int DmDisplayFrequency;\n                public int DmICMMethod;\n                public int DmICMIntent;\n                public int DmMediaType;\n                public int DmDitherType;\n                public int DmReserved1;\n                public int DmReserved2;\n                public int DmPanningWidth;\n                public int DmPanningHeight;\n            }\n\n            public static void GetMonitorInfo()\n            {\n                int deviceIndex = 0;\n                DISPLAY_DEVICE d = default(DISPLAY_DEVICE);\n                d.cb = Marshal.SizeOf(d);\n\n                Console.WriteLine(\"monitor list :\");\n                while (EnumDisplayDevices(IntPtr.Zero, deviceIndex, ref d, 0))\n                {\n                    Console.WriteLine($\"monitor {deviceIndex + 1}:\");\n                    Console.WriteLine($\"  name: {d.DeviceName}\");\n                    Console.WriteLine($\"  string: {d.DeviceString}\");\n                    Console.WriteLine($\"  ID: {d.DeviceID}\");\n                    Console.WriteLine($\"  key: {d.DeviceKey}\");\n                    Console.WriteLine();\n\n                    DEVMODE dm = default(DEVMODE);\n                    dm.DmSize = (short)Marshal.SizeOf<DEVMODE>();\n                    int modeNum = 0;\n                    while (EnumDisplaySettings(d.DeviceName, modeNum, ref dm) > 0)\n                    {\n                        MonitorInfoData.Monitors.Add(new MonitorInfoData.MonitorInfoDataWrapper()\n                        {\n                            DeviceName = d.DeviceName,\n                            DeviceString = d.DeviceString,\n                            DeviceID = d.DeviceID,\n                            DeviceKey = d.DeviceKey,\n                            PelsWidth = dm.DmPelsWidth,\n                            PelsHeight = dm.DmPelsHeight,\n                            DisplayFrequency = dm.DmDisplayFrequency,\n                        });\n                        Console.WriteLine($\"  mode {modeNum}: {dm.DmPelsWidth}x{dm.DmPelsHeight} @ {dm.DmDisplayFrequency}Hz\");\n                        modeNum++;\n                    }\n\n                    deviceIndex++;\n                    d.cb = Marshal.SizeOf(d); // Reset the size for the next device\n                }\n            }\n\n            public static void ChangeDisplayResolution(int PelsWidth, int PelsHeight)\n            {\n                Screen screen = Screen.PrimaryScreen!;\n                if (screen.Bounds.Width == PelsWidth && screen.Bounds.Height == PelsHeight)\n                {\n                    return;\n                }\n\n                DEVMODE devMode = default(DEVMODE);\n                devMode.DmDeviceName = new string(new char[32]);\n                devMode.DmFormName = new string(new char[32]);\n                devMode.DmSize = (short)Marshal.SizeOf<DEVMODE>();\n\n                int modeNum = 0;\n                while (EnumDisplaySettings(IntPtr.Zero, modeNum, ref devMode) > 0)\n                {\n                    Console.WriteLine($\"Mode {modeNum}: {devMode.DmPelsWidth}x{devMode.DmPelsHeight} @ {devMode.DmDisplayFrequency}Hz\");\n                    modeNum++;\n                }\n\n                devMode.DmPelsWidth = PelsWidth;\n                devMode.DmPelsHeight = PelsHeight;\n\n                int result = NativeMethods.ChangeDisplaySettings(ref devMode, NativeMethods.CDS_TEST);\n\n                if (result == DISP_CHANGE_SUCCESSFUL)\n                {\n                    result = ChangeDisplaySettings(ref devMode, CDS_UPDATEREGISTRY);\n                    if (result == DISP_CHANGE_SUCCESSFUL)\n                    {\n                        Console.WriteLine($\"Changing display resolution to {devMode.DmPelsWidth}x{devMode.DmPelsHeight}\");\n                    }\n                    else\n                    {\n                        Console.WriteLine($\"Failed to change display resolution. Error code: {result}\");\n                    }\n                }\n                else if (result == DISP_CHANGE_RESTART)\n                {\n                    Console.WriteLine($\"Changing display resolution to {devMode.DmPelsWidth}x{devMode.DmPelsHeight} requires a restart\");\n                }\n                else\n                {\n                    Console.WriteLine($\"Failed to change display resolution. Error code: {result}\");\n                }\n            }\n        }\n    }\n}\n"
      },
      {
        "instruction": "Factory 패턴을 사용하는 C# 코드를 작성해주세요.",
        "context": "프로덕션 환경에서 사용 가능한 수준으로 작성해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System.Collections.ObjectModel;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Reflection;\nusing System.Runtime.InteropServices;\nusing System.Xml.Linq;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing OpenQA.Selenium;\nusing OpenQA.Selenium.Appium;\nusing OpenQA.Selenium.Appium.Windows;\nusing Windows.Devices.Display.Core;\nusing Windows.Foundation.Metadata;\nusing static Microsoft.PowerToys.UITest.UITestBase.NativeMethods;\nusing static Microsoft.PowerToys.UITest.WindowHelper;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    /// <summary>\n    /// Base class that should be inherited by all Test Classes.\n    /// </summary>\n    [TestClass]\n    public class UITestBase : IDisposable\n    {\n        public required TestContext TestContext { get; set; }\n\n        public required Session Session { get; set; }\n\n        public bool IsInPipeline { get; }\n\n        public static MonitorInfoData.ParamsWrapper MonitorInfoData { get; set; } = new MonitorInfoData.ParamsWrapper() { Monitors = new List<MonitorInfoData.MonitorInfoDataWrapper>() };\n\n        private readonly PowerToysModule scope;\n        private readonly WindowSize size;\n        private SessionHelper? sessionHelper;\n        private System.Threading.Timer? screenshotTimer;\n        private string? screenshotDirectory;\n\n        public UITestBase(PowerToysModule scope = PowerToysModule.PowerToysSettings, WindowSize size = WindowSize.UnSpecified)\n        {\n            this.IsInPipeline = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"platform\"));\n            Console.WriteLine($\"Running tests on platform: {Environment.GetEnvironmentVariable(\"platform\")}\");\n            if (IsInPipeline)\n            {\n                NativeMethods.ChangeDisplayResolution(1920, 1080);\n                NativeMethods.GetMonitorInfo();\n\n                // Escape Popups before starting\n                System.Windows.Forms.SendKeys.SendWait(\"{ESC}\");\n            }\n\n            this.scope = scope;\n            this.size = size;\n        }\n\n        /// <summary>\n        /// Initializes the test.\n        /// </summary>\n        [TestInitialize]\n        public void TestInit()\n        {\n            CloseOtherApplications();\n            if (IsInPipeline)\n            {\n                screenshotDirectory = Path.Combine(this.TestContext.TestResultsDirectory ?? string.Empty, \"UITestScreenshots_\" + Guid.NewGuid().ToString());\n                Directory.CreateDirectory(screenshotDirectory);\n\n                // Take screenshot every 1 second\n                screenshotTimer = new System.Threading.Timer(ScreenCapture.TimerCallback, screenshotDirectory, TimeSpan.Zero, TimeSpan.FromMilliseconds(1000));\n\n                // Escape Popups before starting\n                System.Windows.Forms.SendKeys.SendWait(\"{ESC}\");\n            }\n\n            this.sessionHelper = new SessionHelper(scope).Init();\n            this.Session = new Session(this.sessionHelper.GetRoot(), this.sessionHelper.GetDriver(), scope, size);\n\n            if (this.scope == PowerToysModule.PowerToysSettings)\n            {\n                // close Debug warning dialog if any\n                // Such debug warning dialog seems only appear in PowerToys Settings\n                if (this.FindAll(\"DEBUG\").Count > 0)\n                {\n                    this.Find(\"DEBUG\").Find<Button>(\"Close\").Click();\n                }\n            }\n        }\n\n        /// <summary>\n        /// Cleanups the test.\n        /// </summary>\n        [TestCleanup]\n        public void TestCleanup()\n        {\n            if (IsInPipeline)\n            {\n                screenshotTimer?.Change(Timeout.Infinite, Timeout.Infinite);\n                Dispose();\n                if (TestContext.CurrentTestOutcome is UnitTestOutcome.Failed\n                    or UnitTestOutcome.Error\n                    or UnitTestOutcome.Unknown)\n                {\n                    Task.Delay(1000).Wait();\n                    AddScreenShotsToTestResultsDirectory();\n                }\n            }\n\n            this.Session.Cleanup();\n            this.sessionHelper!.Cleanup();\n        }\n\n        public void Dispose()\n        {\n            screenshotTimer?.Dispose();\n            GC.SuppressFinalize(this);\n        }\n\n        /// <summary>\n        /// Finds an element by selector.\n        /// Shortcut for this.Session.Find<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected T Find<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Find<T>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(name, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected T Find<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Find<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected Element Find(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Find(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Find<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>The found element.</returns>\n        protected Element Find(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Find(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Has only one Element or its derived class by selector.\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.FindAll<T>(by, timeoutMS, global).Count == 1;\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.HasOne<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<T>(name, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.HasOne<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.HasOne<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if only has one element, otherwise false.</returns>\n        public bool HasOne(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.HasOne<Element>(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(by, timeoutMS, global).Count >= 1;\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Has<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<T>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the element, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.Has<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Shortcut for this.Session.Has<Element>(name, timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the element.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>True if  has one or more element, otherwise false.</returns>\n        public bool Has(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.Has<Element>(name, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<T>(by, timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the elements, should be Element or its derived class.</typeparam>\n        /// <param name=\"by\">The selector to find the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<T> FindAll<T>(By by, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <typeparam name=\"T\">The class of the elements, should be Element or its derived class.</typeparam>\n        /// <param name=\"name\">The name of the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<T> FindAll<T>(string name, int timeoutMS = 5000, bool global = false)\n            where T : Element, new()\n        {\n            return this.Session.FindAll<T>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(by, timeoutMS)\n        /// </summary>\n        /// <param name=\"by\">The selector to find the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<Element> FindAll(By by, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.FindAll<Element>(by, timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Finds all elements by selector.\n        /// Shortcut for this.Session.FindAll<Element>(By.Name(name), timeoutMS)\n        /// </summary>\n        /// <param name=\"name\">The name of the elements.</param>\n        /// <param name=\"timeoutMS\">The timeout in milliseconds (default is 5000).</param>\n        /// <returns>A read-only collection of the found elements.</returns>\n        protected ReadOnlyCollection<Element> FindAll(string name, int timeoutMS = 5000, bool global = false)\n        {\n            return this.Session.FindAll<Element>(By.Name(name), timeoutMS, global);\n        }\n\n        /// <summary>\n        /// Scrolls the page\n        /// </summary>\n        /// <param name=\"scrollCount\">The number of scroll attempts.</param>\n        /// <param name=\"direction\">The direction to scroll.</param>\n        /// <param name=\"msPreAction\">Pre-action delay in milliseconds.</param>\n        /// <param name=\"msPostAction\">Post-action delay in milliseconds.</param>\n        public void Scroll(int scrollCount = 5, string direction = \"Up\", int msPreAction = 500, int msPostAction = 500)\n        {\n            MouseActionType mouseAction = direction == \"Up\" ? MouseActionType.ScrollUp : MouseActionType.ScrollDown;\n            for (int i = 0; i < scrollCount; i++)\n            {\n                Session.PerformMouseAction(mouseAction, msPreAction, msPostAction); // Ensure settings are visible\n            }\n        }\n\n        /// <summary>\n        /// Captures the last screenshot when the test fails.\n        /// </summary>\n        protected void CaptureLastScreenshot()\n        {\n            // Implement your screenshot capture logic here\n            // For example, save a screenshot to a file and return the file path\n            string screenshotPath = Path.Combine(this.TestContext.TestResultsDirectory ?? string.Empty, \"last_screenshot.png\");\n\n            this.Session.Root.GetScreenshot().SaveAsFile(screenshotPath, ScreenshotImageFormat.Png);\n\n            // Save screenshot to screenshotPath & upload to test attachment\n            this.TestContext.AddResultFile(screenshotPath);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public Color GetPixelColor(int x, int y)\n        {\n            return WindowHelper.GetPixelColor(x, y);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates as a string.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public string GetPixelColorString(int x, int y)\n        {\n            return WindowHelper.GetPixelColorString(x, y);\n        }\n\n        /// <summary>\n        /// Gets the size of the display.\n        /// </summary>\n        /// <returns>\n        /// A tuple containing the width and height of the display.\n        /// </returns\n        public Tuple<int, int> GetDisplaySize()\n        {\n            return WindowHelper.GetDisplaySize();\n        }\n\n        /// <summary>\n        /// Sends a combination of keys.\n        /// </summary>\n        /// <param name=\"keys\">The keys to send.</param>\n        public void SendKeys(params Key[] keys)\n        {\n            this.Session.SendKeys(keys);\n        }\n\n        /// <summary>\n        /// Sends a sequence of keys.\n        /// </summary>\n        /// <param name=\"keys\">An array of keys to send.</param>\n        public void SendKeySequence(params Key[] keys)\n        {\n            this.Session.SendKeySequence(keys);\n        }\n\n        /// <summary>\n        /// Gets the current position of the mouse cursor as a tuple.\n        /// </summary>\n        /// <returns>A tuple containing the X and Y coordinates of the cursor.</returns>\n        public Tuple<int, int> GetMousePosition()\n        {\n            return this.Session.GetMousePosition();\n        }\n\n        /// <summary>\n        /// Gets the screen center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public (int CenterX, int CenterY) GetScreenCenter()\n        {\n            return WindowHelper.GetScreenCenter();\n        }\n\n        public bool IsWindowOpen(string windowName)\n        {\n            return WindowHelper.IsWindowOpen(windowName);\n        }\n\n        /// <summary>\n        /// Moves the mouse cursor to the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The new x-coordinate of the cursor.</param>\n        /// <param name=\"y\">The new y-coordinate of the cursor.</param\n        public void MoveMouseTo(int x, int y)\n        {\n            this.Session.MoveMouseTo(x, y);\n        }\n\n        protected void AddScreenShotsToTestResultsDirectory()\n        {\n            if (screenshotDirectory != null)\n            {\n                foreach (string file in Directory.GetFiles(screenshotDirectory))\n                {\n                    this.TestContext.AddResultFile(file);\n                }\n            }\n        }\n\n        /// <summary>\n        /// Restart scope exe.\n        /// </summary>\n        public void RestartScopeExe()\n        {\n            this.sessionHelper!.RestartScopeExe();\n            this.Session = new Session(this.sessionHelper.GetRoot(), this.sessionHelper.GetDriver(), this.scope, this.size);\n            return;\n        }\n\n        /// <summary>\n        /// Restart scope exe.\n        /// </summary>\n        public void ExitScopeExe()\n        {\n            this.sessionHelper!.ExitScopeExe();\n            return;\n        }\n\n        private void CloseOtherApplications()\n        {\n            // Close other applications\n            var processNamesToClose = new List<string>\n            {\n                \"PowerToys\",\n                \"PowerToys.Settings\",\n                \"PowerToys.FancyZonesEditor\",\n            };\n            foreach (var processName in processNamesToClose)\n            {\n                foreach (var process in Process.GetProcessesByName(processName))\n                {\n                    process.Kill();\n                    process.WaitForExit();\n                }\n            }\n        }\n\n        public class NativeMethods\n        {\n            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]\n            public struct DISPLAY_DEVICE\n            {\n                public int cb;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DeviceName;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceString;\n                public int StateFlags;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceID;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]\n                public string DeviceKey;\n            }\n\n            [DllImport(\"user32.dll\")]\n            private static extern int EnumDisplaySettings(IntPtr deviceName, int modeNum, ref DEVMODE devMode);\n\n            [DllImport(\"user32.dll\")]\n            private static extern int EnumDisplaySettings(string deviceName, int modeNum, ref DEVMODE devMode);\n\n            [DllImport(\"user32.dll\", CharSet = CharSet.Ansi)]\n            private static extern bool EnumDisplayDevices(IntPtr lpDevice, int iDevNum, ref DISPLAY_DEVICE lpDisplayDevice, int dwFlags);\n\n            [DllImport(\"user32.dll\")]\n            private static extern int ChangeDisplaySettings(ref DEVMODE devMode, int flags);\n\n            [DllImport(\"user32.dll\", CharSet = CharSet.Ansi)]\n            private static extern int ChangeDisplaySettingsEx(IntPtr lpszDeviceName, ref DEVMODE lpDevMode, IntPtr hwnd, uint dwflags, IntPtr lParam);\n\n            private const int DM_PELSWIDTH = 0x80000;\n            private const int DM_PELSHEIGHT = 0x100000;\n\n            public const int ENUM_CURRENT_SETTINGS = -1;\n            public const int CDS_TEST = 0x00000002;\n            public const int CDS_UPDATEREGISTRY = 0x01;\n            public const int DISP_CHANGE_SUCCESSFUL = 0;\n            public const int DISP_CHANGE_RESTART = 1;\n            public const int DISP_CHANGE_FAILED = -1;\n\n            [StructLayout(LayoutKind.Sequential)]\n            public struct DEVMODE\n            {\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DmDeviceName;\n                public short DmSpecVersion;\n                public short DmDriverVersion;\n                public short DmSize;\n                public short DmDriverExtra;\n                public int DmFields;\n                public int DmPositionX;\n                public int DmPositionY;\n                public int DmDisplayOrientation;\n                public int DmDisplayFixedOutput;\n                public short DmColor;\n                public short DmDuplex;\n                public short DmYResolution;\n                public short DmTTOption;\n                public short DmCollate;\n                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]\n                public string DmFormName;\n                public short DmLogPixels;\n                public int DmBitsPerPel;\n                public int DmPelsWidth;\n                public int DmPelsHeight;\n                public int DmDisplayFlags;\n                public int DmDisplayFrequency;\n                public int DmICMMethod;\n                public int DmICMIntent;\n                public int DmMediaType;\n                public int DmDitherType;\n                public int DmReserved1;\n                public int DmReserved2;\n                public int DmPanningWidth;\n                public int DmPanningHeight;\n            }\n\n            public static void GetMonitorInfo()\n            {\n                int deviceIndex = 0;\n                DISPLAY_DEVICE d = default(DISPLAY_DEVICE);\n                d.cb = Marshal.SizeOf(d);\n\n                Console.WriteLine(\"monitor list :\");\n                while (EnumDisplayDevices(IntPtr.Zero, deviceIndex, ref d, 0))\n                {\n                    Console.WriteLine($\"monitor {deviceIndex + 1}:\");\n                    Console.WriteLine($\"  name: {d.DeviceName}\");\n                    Console.WriteLine($\"  string: {d.DeviceString}\");\n                    Console.WriteLine($\"  ID: {d.DeviceID}\");\n                    Console.WriteLine($\"  key: {d.DeviceKey}\");\n                    Console.WriteLine();\n\n                    DEVMODE dm = default(DEVMODE);\n                    dm.DmSize = (short)Marshal.SizeOf<DEVMODE>();\n                    int modeNum = 0;\n                    while (EnumDisplaySettings(d.DeviceName, modeNum, ref dm) > 0)\n                    {\n                        MonitorInfoData.Monitors.Add(new MonitorInfoData.MonitorInfoDataWrapper()\n                        {\n                            DeviceName = d.DeviceName,\n                            DeviceString = d.DeviceString,\n                            DeviceID = d.DeviceID,\n                            DeviceKey = d.DeviceKey,\n                            PelsWidth = dm.DmPelsWidth,\n                            PelsHeight = dm.DmPelsHeight,\n                            DisplayFrequency = dm.DmDisplayFrequency,\n                        });\n                        Console.WriteLine($\"  mode {modeNum}: {dm.DmPelsWidth}x{dm.DmPelsHeight} @ {dm.DmDisplayFrequency}Hz\");\n                        modeNum++;\n                    }\n\n                    deviceIndex++;\n                    d.cb = Marshal.SizeOf(d); // Reset the size for the next device\n                }\n            }\n\n            public static void ChangeDisplayResolution(int PelsWidth, int PelsHeight)\n            {\n                Screen screen = Screen.PrimaryScreen!;\n                if (screen.Bounds.Width == PelsWidth && screen.Bounds.Height == PelsHeight)\n                {\n                    return;\n                }\n\n                DEVMODE devMode = default(DEVMODE);\n                devMode.DmDeviceName = new string(new char[32]);\n                devMode.DmFormName = new string(new char[32]);\n                devMode.DmSize = (short)Marshal.SizeOf<DEVMODE>();\n\n                int modeNum = 0;\n                while (EnumDisplaySettings(IntPtr.Zero, modeNum, ref devMode) > 0)\n                {\n                    Console.WriteLine($\"Mode {modeNum}: {devMode.DmPelsWidth}x{devMode.DmPelsHeight} @ {devMode.DmDisplayFrequency}Hz\");\n                    modeNum++;\n                }\n\n                devMode.DmPelsWidth = PelsWidth;\n                devMode.DmPelsHeight = PelsHeight;\n\n                int result = NativeMethods.ChangeDisplaySettings(ref devMode, NativeMethods.CDS_TEST);\n\n                if (result == DISP_CHANGE_SUCCESSFUL)\n                {\n                    result = ChangeDisplaySettings(ref devMode, CDS_UPDATEREGISTRY);\n                    if (result == DISP_CHANGE_SUCCESSFUL)\n                    {\n                        Console.WriteLine($\"Changing display resolution to {devMode.DmPelsWidth}x{devMode.DmPelsHeight}\");\n                    }\n                    else\n                    {\n                        Console.WriteLine($\"Failed to change display resolution. Error code: {result}\");\n                    }\n                }\n                else if (result == DISP_CHANGE_RESTART)\n                {\n                    Console.WriteLine($\"Changing display resolution to {devMode.DmPelsWidth}x{devMode.DmPelsHeight} requires a restart\");\n                }\n                else\n                {\n                    Console.WriteLine($\"Failed to change display resolution. Error code: {result}\");\n                }\n            }\n        }\n    }\n}\n"
      }
    ]
  },
  {
    "id": "54fb7570245799081662960564ba38b3",
    "source": "github",
    "file_path": "src/common/UITestAutomation/WindowHelper.cs",
    "repository": "",
    "code": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    internal static class WindowHelper\n    {\n        internal const string AdministratorPrefix = \"Administrator: \";\n\n        /// <summary>\n        /// Sets the main window size.\n        /// </summary>\n        /// <param name=\"size\">WindowSize enum</param>\n        public static void SetWindowSize(IntPtr windowHandler, WindowSize size)\n        {\n            if (size == WindowSize.UnSpecified)\n            {\n                return;\n            }\n\n            int width = 0, height = 0;\n\n            switch (size)\n            {\n                case WindowSize.Small:\n                    width = 640;\n                    height = 480;\n                    break;\n                case WindowSize.Small_Vertical:\n                    width = 480;\n                    height = 640;\n                    break;\n                case WindowSize.Medium:\n                    width = 1024;\n                    height = 768;\n                    break;\n                case WindowSize.Medium_Vertical:\n                    width = 768;\n                    height = 1024;\n                    break;\n                case WindowSize.Large:\n                    width = 1920;\n                    height = 1080;\n                    break;\n                case WindowSize.Large_Vertical:\n                    width = 1080;\n                    height = 1920;\n                    break;\n            }\n\n            if (width > 0 && height > 0)\n            {\n                WindowHelper.SetMainWindowSize(windowHandler, width, height);\n            }\n        }\n\n        /// <summary>\n        /// Gets the main window center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public static (int CenterX, int CenterY) GetWindowCenter(IntPtr windowHandler)\n        {\n            if (windowHandler == IntPtr.Zero)\n            {\n                return (0, 0);\n            }\n            else\n            {\n                var rect = ApiHelper.GetWindowCenter(windowHandler);\n                return (rect.CenterX, rect.CenterY);\n            }\n        }\n\n        /// <summary>\n        /// Gets the main window center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public static (int Left, int Top, int Right, int Bottom) GetWindowRect(IntPtr windowHandler)\n        {\n            if (windowHandler == IntPtr.Zero)\n            {\n                return (0, 0, 0, 0);\n            }\n            else\n            {\n                var rect = ApiHelper.GetWindowRect(windowHandler);\n                return (rect.Left, rect.Top, rect.Right, rect.Bottom);\n            }\n        }\n\n        /// <summary>\n        /// Gets the screen center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public static (int CenterX, int CenterY) GetScreenCenter()\n        {\n            return ApiHelper.GetScreenCenter();\n        }\n\n        /// <summary>\n        /// Sets the main window size based on Width and Height.\n        /// </summary>\n        /// <param name=\"width\">the width in pixel</param>\n        /// <param name=\"height\">the height in pixel</param>\n        public static void SetMainWindowSize(IntPtr windowHandler, int width, int height)\n        {\n            if (windowHandler == IntPtr.Zero\n                || width <= 0\n                || height <= 0)\n            {\n                return;\n            }\n\n            ApiHelper.SetWindowPos(windowHandler, IntPtr.Zero, 0, 0, width, height, ApiHelper.SetWindowPosNoZorder | ApiHelper.SetWindowPosShowWindow);\n\n            // Wait for 1000ms after resize\n            Task.Delay(1000).Wait();\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public static Color GetPixelColor(int x, int y)\n        {\n            IntPtr hdc = ApiHelper.GetDC(IntPtr.Zero);\n            uint pixel = ApiHelper.GetPixel(hdc, x, y);\n            _ = ApiHelper.ReleaseDC(IntPtr.Zero, hdc);\n\n            int r = (int)(pixel & 0x000000FF);\n            int g = (int)((pixel & 0x0000FF00) >> 8);\n            int b = (int)((pixel & 0x00FF0000) >> 16);\n\n            return Color.FromArgb(r, g, b);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates as a string.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public static string GetPixelColorString(int x, int y)\n        {\n            Color color = WindowHelper.GetPixelColor(x, y);\n            return $\"#{color.R:X2}{color.G:X2}{color.B:X2}\";\n        }\n\n        /// <summary>\n        /// Gets the size of the display.\n        /// </summary>\n        /// <returns>\n        /// A tuple containing the width and height of the display.\n        /// </returns\n        public static Tuple<int, int> GetDisplaySize()\n        {\n            IntPtr hdc = ApiHelper.GetDC(IntPtr.Zero);\n            int screenWidth = ApiHelper.GetDeviceCaps(hdc, ApiHelper.DESKTOPHORZRES);\n            int screenHeight = ApiHelper.GetDeviceCaps(hdc, ApiHelper.DESKTOPVERTRES);\n            _ = ApiHelper.ReleaseDC(IntPtr.Zero, hdc);\n\n            return Tuple.Create(screenWidth, screenHeight);\n        }\n\n        public static bool IsWindowOpen(string windowName)\n        {\n            var matchingWindows = ApiHelper.FindDesktopWindowHandler([windowName, AdministratorPrefix + windowName]);\n            return matchingWindows.Count > 0;\n        }\n\n        internal static class ApiHelper\n        {\n            [DllImport(\"user32.dll\")]\n            public static extern bool SetForegroundWindow(IntPtr hWnd);\n\n            public const uint SetWindowPosNoMove = 0x0002;\n            public const uint SetWindowPosNoZorder = 0x0004;\n            public const uint SetWindowPosShowWindow = 0x0040;\n\n            [DllImport(\"user32.dll\", SetLastError = true)]\n            public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int x, int y, int cx, int cy, uint uFlags);\n\n            // Delegate for the EnumWindows callback function\n            private delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);\n\n            // P/Invoke declaration for EnumWindows\n            [DllImport(\"user32.dll\")]\n            [return: MarshalAs(UnmanagedType.Bool)]\n            private static extern bool EnumWindows(EnumWindowsProc lpEnumFunc, IntPtr lParam);\n\n            // P/Invoke declaration for GetWindowTextLength\n            [DllImport(\"user32.dll\", SetLastError = true, CharSet = CharSet.Auto)]\n            private static extern int GetWindowTextLength(IntPtr hWnd);\n\n            // P/Invoke declaration for GetWindowText\n            [DllImport(\"user32.dll\", SetLastError = true, CharSet = CharSet.Auto)]\n            private static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);\n\n            [DllImport(\"user32.dll\")]\n            public static extern IntPtr GetDC(IntPtr hWnd);\n\n            [DllImport(\"gdi32.dll\")]\n            public static extern uint GetPixel(IntPtr hdc, int x, int y);\n\n            [DllImport(\"gdi32.dll\")]\n            public static extern int GetDeviceCaps(IntPtr hdc, int nIndex);\n\n            public const int DESKTOPHORZRES = 118;\n            public const int DESKTOPVERTRES = 117;\n\n            [DllImport(\"user32.dll\")]\n            public static extern int ReleaseDC(IntPtr hWnd, IntPtr hDC);\n\n            // Define the Win32 RECT structure\n            [StructLayout(LayoutKind.Sequential)]\n            public struct RECT\n            {\n                public int Left;    // X coordinate of the left edge of the window\n                public int Top;     // Y coordinate of the top edge of the window\n                public int Right;   // X coordinate of the right edge of the window\n                public int Bottom;  // Y coordinate of the bottom edge of the window\n            }\n\n            // Import GetWindowRect API to retrieve window's screen coordinates\n            [DllImport(\"user32.dll\")]\n            public static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);\n\n            public static List<(IntPtr HWnd, string Title)> FindDesktopWindowHandler(string[] matchingWindowsTitles)\n            {\n                var windows = new List<(IntPtr HWnd, string Title)>();\n\n                _ = EnumWindows(\n                    (hWnd, lParam) =>\n                    {\n                        int length = GetWindowTextLength(hWnd);\n                        if (length > 0)\n                        {\n                            var builder = new StringBuilder(length + 1);\n                            _ = GetWindowText(hWnd, builder, builder.Capacity);\n\n                            var title = builder.ToString();\n                            if (matchingWindowsTitles.Contains(title))\n                            {\n                                windows.Add((hWnd, title));\n                            }\n                        }\n\n                        return true; // Continue enumeration\n                    },\n                    IntPtr.Zero);\n\n                return windows;\n            }\n\n            /// <summary>\n            /// Get the center point coordinates of a specified window (in screen coordinates)\n            /// </summary>\n            /// <param name=\"hWnd\">The window handle</param>\n            /// <returns>The center point (x, y)</returns>\n            public static (int CenterX, int CenterY) GetWindowCenter(IntPtr hWnd)\n            {\n                if (hWnd == IntPtr.Zero)\n                {\n                    throw new ArgumentException(\"Invalid window handle\");\n                }\n\n                if (GetWindowRect(hWnd, out RECT rect))\n                {\n                    int width = rect.Right - rect.Left;\n                    int height = rect.Bottom - rect.Top;\n\n                    int centerX = rect.Left + (width / 2);\n                    int centerY = rect.Top + (height / 2);\n\n                    return (centerX, centerY);\n                }\n                else\n                {\n                    throw new InvalidOperationException(\"Failed to retrieve window coordinates\");\n                }\n            }\n\n            public static (int Left, int Top, int Right, int Bottom) GetWindowRect(IntPtr hWnd)\n            {\n                if (hWnd == IntPtr.Zero)\n                {\n                    throw new ArgumentException(\"Invalid window handle\");\n                }\n\n                if (GetWindowRect(hWnd, out RECT rect))\n                {\n                    return (rect.Left, rect.Top, rect.Right, rect.Bottom);\n                }\n                else\n                {\n                    throw new InvalidOperationException(\"Failed to retrieve window coordinates\");\n                }\n            }\n\n            [DllImport(\"user32.dll\")]\n            public static extern int GetSystemMetrics(int nIndex);\n\n            public enum SystemMetric\n            {\n                ScreenWidth = 0,            // Width of the primary screen in pixels (SM_CXSCREEN)\n                ScreenHeight = 1,           // Height of the primary screen in pixels (SM_CYSCREEN)\n                VirtualScreenWidth = 78,    // Width of the virtual screen that includes all monitors (SM_CXVIRTUALSCREEN)\n                VirtualScreenHeight = 79,   // Height of the virtual screen that includes all monitors (SM_CYVIRTUALSCREEN)\n                MonitorCount = 80,          // Number of display monitors (SM_CMONITORS, available on Windows XP+)\n            }\n\n            public static (int CenterX, int CenterY) GetScreenCenter()\n            {\n                int width = GetSystemMetrics((int)SystemMetric.ScreenWidth);\n                int height = GetSystemMetrics((int)SystemMetric.ScreenHeight);\n\n                return (width / 2, height / 2);\n            }\n        }\n    }\n}\n",
    "patterns": [
      "Factory",
      "Service",
      "Uses Generics",
      "Uses Lambda Expressions",
      "Uses Pattern Matching",
      "Uses Tuples",
      "Uses Expression Bodies"
    ],
    "timestamp": "2025-06-24T22:15:49.952575",
    "quality_score": 0.8000000000000002,
    "training_prompts": [
      {
        "instruction": "void 반환 타입의 SetWindowSize 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    internal static class WindowHelper\n    {\n        internal const string AdministratorPrefix = \"Administrator: \";\n\n        /// <summary>\n        /// Sets the main window size.\n        /// </summary>\n        /// <param name=\"size\">WindowSize enum</param>\n        public static void SetWindowSize(IntPtr windowHandler, WindowSize size)\n        {\n            if (size == WindowSize.UnSpecified)\n            {\n                return;\n            }\n\n            int width = 0, height = 0;\n\n            switch (size)\n            {\n                case WindowSize.Small:\n                    width = 640;\n                    height = 480;\n                    break;\n                case WindowSize.Small_Vertical:\n                    width = 480;\n                    height = 640;\n                    break;\n                case WindowSize.Medium:\n                    width = 1024;\n                    height = 768;\n                    break;\n                case WindowSize.Medium_Vertical:\n                    width = 768;\n                    height = 1024;\n                    break;\n                case WindowSize.Large:\n                    width = 1920;\n                    height = 1080;\n                    break;\n                case WindowSize.Large_Vertical:\n                    width = 1080;\n                    height = 1920;\n                    break;\n            }\n\n            if (width > 0 && height > 0)\n            {\n                WindowHelper.SetMainWindowSize(windowHandler, width, height);\n            }\n        }\n\n        /// <summary>\n        /// Gets the main window center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public static (int CenterX, int CenterY) GetWindowCenter(IntPtr windowHandler)\n        {\n            if (windowHandler == IntPtr.Zero)\n            {\n                return (0, 0);\n            }\n            else\n            {\n                var rect = ApiHelper.GetWindowCenter(windowHandler);\n                return (rect.CenterX, rect.CenterY);\n            }\n        }\n\n        /// <summary>\n        /// Gets the main window center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public static (int Left, int Top, int Right, int Bottom) GetWindowRect(IntPtr windowHandler)\n        {\n            if (windowHandler == IntPtr.Zero)\n            {\n                return (0, 0, 0, 0);\n            }\n            else\n            {\n                var rect = ApiHelper.GetWindowRect(windowHandler);\n                return (rect.Left, rect.Top, rect.Right, rect.Bottom);\n            }\n        }\n\n        /// <summary>\n        /// Gets the screen center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public static (int CenterX, int CenterY) GetScreenCenter()\n        {\n            return ApiHelper.GetScreenCenter();\n        }\n\n        /// <summary>\n        /// Sets the main window size based on Width and Height.\n        /// </summary>\n        /// <param name=\"width\">the width in pixel</param>\n        /// <param name=\"height\">the height in pixel</param>\n        public static void SetMainWindowSize(IntPtr windowHandler, int width, int height)\n        {\n            if (windowHandler == IntPtr.Zero\n                || width <= 0\n                || height <= 0)\n            {\n                return;\n            }\n\n            ApiHelper.SetWindowPos(windowHandler, IntPtr.Zero, 0, 0, width, height, ApiHelper.SetWindowPosNoZorder | ApiHelper.SetWindowPosShowWindow);\n\n            // Wait for 1000ms after resize\n            Task.Delay(1000).Wait();\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public static Color GetPixelColor(int x, int y)\n        {\n            IntPtr hdc = ApiHelper.GetDC(IntPtr.Zero);\n            uint pixel = ApiHelper.GetPixel(hdc, x, y);\n            _ = ApiHelper.ReleaseDC(IntPtr.Zero, hdc);\n\n            int r = (int)(pixel & 0x000000FF);\n            int g = (int)((pixel & 0x0000FF00) >> 8);\n            int b = (int)((pixel & 0x00FF0000) >> 16);\n\n            return Color.FromArgb(r, g, b);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates as a string.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public static string GetPixelColorString(int x, int y)\n        {\n            Color color = WindowHelper.GetPixelColor(x, y);\n            return $\"#{color.R:X2}{color.G:X2}{color.B:X2}\";\n        }\n\n        /// <summary>\n        /// Gets the size of the display.\n        /// </summary>\n        /// <returns>\n        /// A tuple containing the width and height of the display.\n        /// </returns\n        public static Tuple<int, int> GetDisplaySize()\n        {\n            IntPtr hdc = ApiHelper.GetDC(IntPtr.Zero);\n            int screenWidth = ApiHelper.GetDeviceCaps(hdc, ApiHelper.DESKTOPHORZRES);\n            int screenHeight = ApiHelper.GetDeviceCaps(hdc, ApiHelper.DESKTOPVERTRES);\n            _ = ApiHelper.ReleaseDC(IntPtr.Zero, hdc);\n\n            return Tuple.Create(screenWidth, screenHeight);\n        }\n\n        public static bool IsWindowOpen(string windowName)\n        {\n            var matchingWindows = ApiHelper.FindDesktopWindowHandler([windowName, AdministratorPrefix + windowName]);\n            return matchingWindows.Count > 0;\n        }\n\n        internal static class ApiHelper\n        {\n            [DllImport(\"user32.dll\")]\n            public static extern bool SetForegroundWindow(IntPtr hWnd);\n\n            public const uint SetWindowPosNoMove = 0x0002;\n            public const uint SetWindowPosNoZorder = 0x0004;\n            public const uint SetWindowPosShowWindow = 0x0040;\n\n            [DllImport(\"user32.dll\", SetLastError = true)]\n            public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int x, int y, int cx, int cy, uint uFlags);\n\n            // Delegate for the EnumWindows callback function\n            private delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);\n\n            // P/Invoke declaration for EnumWindows\n            [DllImport(\"user32.dll\")]\n            [return: MarshalAs(UnmanagedType.Bool)]\n            private static extern bool EnumWindows(EnumWindowsProc lpEnumFunc, IntPtr lParam);\n\n            // P/Invoke declaration for GetWindowTextLength\n            [DllImport(\"user32.dll\", SetLastError = true, CharSet = CharSet.Auto)]\n            private static extern int GetWindowTextLength(IntPtr hWnd);\n\n            // P/Invoke declaration for GetWindowText\n            [DllImport(\"user32.dll\", SetLastError = true, CharSet = CharSet.Auto)]\n            private static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);\n\n            [DllImport(\"user32.dll\")]\n            public static extern IntPtr GetDC(IntPtr hWnd);\n\n            [DllImport(\"gdi32.dll\")]\n            public static extern uint GetPixel(IntPtr hdc, int x, int y);\n\n            [DllImport(\"gdi32.dll\")]\n            public static extern int GetDeviceCaps(IntPtr hdc, int nIndex);\n\n            public const int DESKTOPHORZRES = 118;\n            public const int DESKTOPVERTRES = 117;\n\n            [DllImport(\"user32.dll\")]\n            public static extern int ReleaseDC(IntPtr hWnd, IntPtr hDC);\n\n            // Define the Win32 RECT structure\n            [StructLayout(LayoutKind.Sequential)]\n            public struct RECT\n            {\n                public int Left;    // X coordinate of the left edge of the window\n                public int Top;     // Y coordinate of the top edge of the window\n                public int Right;   // X coordinate of the right edge of the window\n                public int Bottom;  // Y coordinate of the bottom edge of the window\n            }\n\n            // Import GetWindowRect API to retrieve window's screen coordinates\n            [DllImport(\"user32.dll\")]\n            public static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);\n\n            public static List<(IntPtr HWnd, string Title)> FindDesktopWindowHandler(string[] matchingWindowsTitles)\n            {\n                var windows = new List<(IntPtr HWnd, string Title)>();\n\n                _ = EnumWindows(\n                    (hWnd, lParam) =>\n                    {\n                        int length = GetWindowTextLength(hWnd);\n                        if (length > 0)\n                        {\n                            var builder = new StringBuilder(length + 1);\n                            _ = GetWindowText(hWnd, builder, builder.Capacity);\n\n                            var title = builder.ToString();\n                            if (matchingWindowsTitles.Contains(title))\n                            {\n                                windows.Add((hWnd, title));\n                            }\n                        }\n\n                        return true; // Continue enumeration\n                    },\n                    IntPtr.Zero);\n\n                return windows;\n            }\n\n            /// <summary>\n            /// Get the center point coordinates of a specified window (in screen coordinates)\n            /// </summary>\n            /// <param name=\"hWnd\">The window handle</param>\n            /// <returns>The center point (x, y)</returns>\n            public static (int CenterX, int CenterY) GetWindowCenter(IntPtr hWnd)\n            {\n                if (hWnd == IntPtr.Zero)\n                {\n                    throw new ArgumentException(\"Invalid window handle\");\n                }\n\n                if (GetWindowRect(hWnd, out RECT rect))\n                {\n                    int width = rect.Right - rect.Left;\n                    int height = rect.Bottom - rect.Top;\n\n                    int centerX = rect.Left + (width / 2);\n                    int centerY = rect.Top + (height / 2);\n\n                    return (centerX, centerY);\n                }\n                else\n                {\n                    throw new InvalidOperationException(\"Failed to retrieve window coordinates\");\n                }\n            }\n\n            public static (int Left, int Top, int Right, int Bottom) GetWindowRect(IntPtr hWnd)\n            {\n                if (hWnd == IntPtr.Zero)\n                {\n                    throw new ArgumentException(\"Invalid window handle\");\n                }\n\n                if (GetWindowRect(hWnd, out RECT rect))\n                {\n                    return (rect.Left, rect.Top, rect.Right, rect.Bottom);\n                }\n                else\n                {\n                    throw new InvalidOperationException(\"Failed to retrieve window coordinates\");\n                }\n            }\n\n            [DllImport(\"user32.dll\")]\n            public static extern int GetSystemMetrics(int nIndex);\n\n            public enum SystemMetric\n            {\n                ScreenWidth = 0,            // Width of the primary screen in pixels (SM_CXSCREEN)\n                ScreenHeight = 1,           // Height of the primary screen in pixels (SM_CYSCREEN)\n                VirtualScreenWidth = 78,    // Width of the virtual screen that includes all monitors (SM_CXVIRTUALSCREEN)\n                VirtualScreenHeight = 79,   // Height of the virtual screen that includes all monitors (SM_CYVIRTUALSCREEN)\n                MonitorCount = 80,          // Number of display monitors (SM_CMONITORS, available on Windows XP+)\n            }\n\n            public static (int CenterX, int CenterY) GetScreenCenter()\n            {\n                int width = GetSystemMetrics((int)SystemMetric.ScreenWidth);\n                int height = GetSystemMetrics((int)SystemMetric.ScreenHeight);\n\n                return (width / 2, height / 2);\n            }\n        }\n    }\n}\n"
      },
      {
        "instruction": "void 반환 타입의 SetMainWindowSize 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    internal static class WindowHelper\n    {\n        internal const string AdministratorPrefix = \"Administrator: \";\n\n        /// <summary>\n        /// Sets the main window size.\n        /// </summary>\n        /// <param name=\"size\">WindowSize enum</param>\n        public static void SetWindowSize(IntPtr windowHandler, WindowSize size)\n        {\n            if (size == WindowSize.UnSpecified)\n            {\n                return;\n            }\n\n            int width = 0, height = 0;\n\n            switch (size)\n            {\n                case WindowSize.Small:\n                    width = 640;\n                    height = 480;\n                    break;\n                case WindowSize.Small_Vertical:\n                    width = 480;\n                    height = 640;\n                    break;\n                case WindowSize.Medium:\n                    width = 1024;\n                    height = 768;\n                    break;\n                case WindowSize.Medium_Vertical:\n                    width = 768;\n                    height = 1024;\n                    break;\n                case WindowSize.Large:\n                    width = 1920;\n                    height = 1080;\n                    break;\n                case WindowSize.Large_Vertical:\n                    width = 1080;\n                    height = 1920;\n                    break;\n            }\n\n            if (width > 0 && height > 0)\n            {\n                WindowHelper.SetMainWindowSize(windowHandler, width, height);\n            }\n        }\n\n        /// <summary>\n        /// Gets the main window center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public static (int CenterX, int CenterY) GetWindowCenter(IntPtr windowHandler)\n        {\n            if (windowHandler == IntPtr.Zero)\n            {\n                return (0, 0);\n            }\n            else\n            {\n                var rect = ApiHelper.GetWindowCenter(windowHandler);\n                return (rect.CenterX, rect.CenterY);\n            }\n        }\n\n        /// <summary>\n        /// Gets the main window center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public static (int Left, int Top, int Right, int Bottom) GetWindowRect(IntPtr windowHandler)\n        {\n            if (windowHandler == IntPtr.Zero)\n            {\n                return (0, 0, 0, 0);\n            }\n            else\n            {\n                var rect = ApiHelper.GetWindowRect(windowHandler);\n                return (rect.Left, rect.Top, rect.Right, rect.Bottom);\n            }\n        }\n\n        /// <summary>\n        /// Gets the screen center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public static (int CenterX, int CenterY) GetScreenCenter()\n        {\n            return ApiHelper.GetScreenCenter();\n        }\n\n        /// <summary>\n        /// Sets the main window size based on Width and Height.\n        /// </summary>\n        /// <param name=\"width\">the width in pixel</param>\n        /// <param name=\"height\">the height in pixel</param>\n        public static void SetMainWindowSize(IntPtr windowHandler, int width, int height)\n        {\n            if (windowHandler == IntPtr.Zero\n                || width <= 0\n                || height <= 0)\n            {\n                return;\n            }\n\n            ApiHelper.SetWindowPos(windowHandler, IntPtr.Zero, 0, 0, width, height, ApiHelper.SetWindowPosNoZorder | ApiHelper.SetWindowPosShowWindow);\n\n            // Wait for 1000ms after resize\n            Task.Delay(1000).Wait();\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public static Color GetPixelColor(int x, int y)\n        {\n            IntPtr hdc = ApiHelper.GetDC(IntPtr.Zero);\n            uint pixel = ApiHelper.GetPixel(hdc, x, y);\n            _ = ApiHelper.ReleaseDC(IntPtr.Zero, hdc);\n\n            int r = (int)(pixel & 0x000000FF);\n            int g = (int)((pixel & 0x0000FF00) >> 8);\n            int b = (int)((pixel & 0x00FF0000) >> 16);\n\n            return Color.FromArgb(r, g, b);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates as a string.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public static string GetPixelColorString(int x, int y)\n        {\n            Color color = WindowHelper.GetPixelColor(x, y);\n            return $\"#{color.R:X2}{color.G:X2}{color.B:X2}\";\n        }\n\n        /// <summary>\n        /// Gets the size of the display.\n        /// </summary>\n        /// <returns>\n        /// A tuple containing the width and height of the display.\n        /// </returns\n        public static Tuple<int, int> GetDisplaySize()\n        {\n            IntPtr hdc = ApiHelper.GetDC(IntPtr.Zero);\n            int screenWidth = ApiHelper.GetDeviceCaps(hdc, ApiHelper.DESKTOPHORZRES);\n            int screenHeight = ApiHelper.GetDeviceCaps(hdc, ApiHelper.DESKTOPVERTRES);\n            _ = ApiHelper.ReleaseDC(IntPtr.Zero, hdc);\n\n            return Tuple.Create(screenWidth, screenHeight);\n        }\n\n        public static bool IsWindowOpen(string windowName)\n        {\n            var matchingWindows = ApiHelper.FindDesktopWindowHandler([windowName, AdministratorPrefix + windowName]);\n            return matchingWindows.Count > 0;\n        }\n\n        internal static class ApiHelper\n        {\n            [DllImport(\"user32.dll\")]\n            public static extern bool SetForegroundWindow(IntPtr hWnd);\n\n            public const uint SetWindowPosNoMove = 0x0002;\n            public const uint SetWindowPosNoZorder = 0x0004;\n            public const uint SetWindowPosShowWindow = 0x0040;\n\n            [DllImport(\"user32.dll\", SetLastError = true)]\n            public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int x, int y, int cx, int cy, uint uFlags);\n\n            // Delegate for the EnumWindows callback function\n            private delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);\n\n            // P/Invoke declaration for EnumWindows\n            [DllImport(\"user32.dll\")]\n            [return: MarshalAs(UnmanagedType.Bool)]\n            private static extern bool EnumWindows(EnumWindowsProc lpEnumFunc, IntPtr lParam);\n\n            // P/Invoke declaration for GetWindowTextLength\n            [DllImport(\"user32.dll\", SetLastError = true, CharSet = CharSet.Auto)]\n            private static extern int GetWindowTextLength(IntPtr hWnd);\n\n            // P/Invoke declaration for GetWindowText\n            [DllImport(\"user32.dll\", SetLastError = true, CharSet = CharSet.Auto)]\n            private static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);\n\n            [DllImport(\"user32.dll\")]\n            public static extern IntPtr GetDC(IntPtr hWnd);\n\n            [DllImport(\"gdi32.dll\")]\n            public static extern uint GetPixel(IntPtr hdc, int x, int y);\n\n            [DllImport(\"gdi32.dll\")]\n            public static extern int GetDeviceCaps(IntPtr hdc, int nIndex);\n\n            public const int DESKTOPHORZRES = 118;\n            public const int DESKTOPVERTRES = 117;\n\n            [DllImport(\"user32.dll\")]\n            public static extern int ReleaseDC(IntPtr hWnd, IntPtr hDC);\n\n            // Define the Win32 RECT structure\n            [StructLayout(LayoutKind.Sequential)]\n            public struct RECT\n            {\n                public int Left;    // X coordinate of the left edge of the window\n                public int Top;     // Y coordinate of the top edge of the window\n                public int Right;   // X coordinate of the right edge of the window\n                public int Bottom;  // Y coordinate of the bottom edge of the window\n            }\n\n            // Import GetWindowRect API to retrieve window's screen coordinates\n            [DllImport(\"user32.dll\")]\n            public static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);\n\n            public static List<(IntPtr HWnd, string Title)> FindDesktopWindowHandler(string[] matchingWindowsTitles)\n            {\n                var windows = new List<(IntPtr HWnd, string Title)>();\n\n                _ = EnumWindows(\n                    (hWnd, lParam) =>\n                    {\n                        int length = GetWindowTextLength(hWnd);\n                        if (length > 0)\n                        {\n                            var builder = new StringBuilder(length + 1);\n                            _ = GetWindowText(hWnd, builder, builder.Capacity);\n\n                            var title = builder.ToString();\n                            if (matchingWindowsTitles.Contains(title))\n                            {\n                                windows.Add((hWnd, title));\n                            }\n                        }\n\n                        return true; // Continue enumeration\n                    },\n                    IntPtr.Zero);\n\n                return windows;\n            }\n\n            /// <summary>\n            /// Get the center point coordinates of a specified window (in screen coordinates)\n            /// </summary>\n            /// <param name=\"hWnd\">The window handle</param>\n            /// <returns>The center point (x, y)</returns>\n            public static (int CenterX, int CenterY) GetWindowCenter(IntPtr hWnd)\n            {\n                if (hWnd == IntPtr.Zero)\n                {\n                    throw new ArgumentException(\"Invalid window handle\");\n                }\n\n                if (GetWindowRect(hWnd, out RECT rect))\n                {\n                    int width = rect.Right - rect.Left;\n                    int height = rect.Bottom - rect.Top;\n\n                    int centerX = rect.Left + (width / 2);\n                    int centerY = rect.Top + (height / 2);\n\n                    return (centerX, centerY);\n                }\n                else\n                {\n                    throw new InvalidOperationException(\"Failed to retrieve window coordinates\");\n                }\n            }\n\n            public static (int Left, int Top, int Right, int Bottom) GetWindowRect(IntPtr hWnd)\n            {\n                if (hWnd == IntPtr.Zero)\n                {\n                    throw new ArgumentException(\"Invalid window handle\");\n                }\n\n                if (GetWindowRect(hWnd, out RECT rect))\n                {\n                    return (rect.Left, rect.Top, rect.Right, rect.Bottom);\n                }\n                else\n                {\n                    throw new InvalidOperationException(\"Failed to retrieve window coordinates\");\n                }\n            }\n\n            [DllImport(\"user32.dll\")]\n            public static extern int GetSystemMetrics(int nIndex);\n\n            public enum SystemMetric\n            {\n                ScreenWidth = 0,            // Width of the primary screen in pixels (SM_CXSCREEN)\n                ScreenHeight = 1,           // Height of the primary screen in pixels (SM_CYSCREEN)\n                VirtualScreenWidth = 78,    // Width of the virtual screen that includes all monitors (SM_CXVIRTUALSCREEN)\n                VirtualScreenHeight = 79,   // Height of the virtual screen that includes all monitors (SM_CYVIRTUALSCREEN)\n                MonitorCount = 80,          // Number of display monitors (SM_CMONITORS, available on Windows XP+)\n            }\n\n            public static (int CenterX, int CenterY) GetScreenCenter()\n            {\n                int width = GetSystemMetrics((int)SystemMetric.ScreenWidth);\n                int height = GetSystemMetrics((int)SystemMetric.ScreenHeight);\n\n                return (width / 2, height / 2);\n            }\n        }\n    }\n}\n"
      },
      {
        "instruction": "Color 반환 타입의 GetPixelColor 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    internal static class WindowHelper\n    {\n        internal const string AdministratorPrefix = \"Administrator: \";\n\n        /// <summary>\n        /// Sets the main window size.\n        /// </summary>\n        /// <param name=\"size\">WindowSize enum</param>\n        public static void SetWindowSize(IntPtr windowHandler, WindowSize size)\n        {\n            if (size == WindowSize.UnSpecified)\n            {\n                return;\n            }\n\n            int width = 0, height = 0;\n\n            switch (size)\n            {\n                case WindowSize.Small:\n                    width = 640;\n                    height = 480;\n                    break;\n                case WindowSize.Small_Vertical:\n                    width = 480;\n                    height = 640;\n                    break;\n                case WindowSize.Medium:\n                    width = 1024;\n                    height = 768;\n                    break;\n                case WindowSize.Medium_Vertical:\n                    width = 768;\n                    height = 1024;\n                    break;\n                case WindowSize.Large:\n                    width = 1920;\n                    height = 1080;\n                    break;\n                case WindowSize.Large_Vertical:\n                    width = 1080;\n                    height = 1920;\n                    break;\n            }\n\n            if (width > 0 && height > 0)\n            {\n                WindowHelper.SetMainWindowSize(windowHandler, width, height);\n            }\n        }\n\n        /// <summary>\n        /// Gets the main window center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public static (int CenterX, int CenterY) GetWindowCenter(IntPtr windowHandler)\n        {\n            if (windowHandler == IntPtr.Zero)\n            {\n                return (0, 0);\n            }\n            else\n            {\n                var rect = ApiHelper.GetWindowCenter(windowHandler);\n                return (rect.CenterX, rect.CenterY);\n            }\n        }\n\n        /// <summary>\n        /// Gets the main window center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public static (int Left, int Top, int Right, int Bottom) GetWindowRect(IntPtr windowHandler)\n        {\n            if (windowHandler == IntPtr.Zero)\n            {\n                return (0, 0, 0, 0);\n            }\n            else\n            {\n                var rect = ApiHelper.GetWindowRect(windowHandler);\n                return (rect.Left, rect.Top, rect.Right, rect.Bottom);\n            }\n        }\n\n        /// <summary>\n        /// Gets the screen center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public static (int CenterX, int CenterY) GetScreenCenter()\n        {\n            return ApiHelper.GetScreenCenter();\n        }\n\n        /// <summary>\n        /// Sets the main window size based on Width and Height.\n        /// </summary>\n        /// <param name=\"width\">the width in pixel</param>\n        /// <param name=\"height\">the height in pixel</param>\n        public static void SetMainWindowSize(IntPtr windowHandler, int width, int height)\n        {\n            if (windowHandler == IntPtr.Zero\n                || width <= 0\n                || height <= 0)\n            {\n                return;\n            }\n\n            ApiHelper.SetWindowPos(windowHandler, IntPtr.Zero, 0, 0, width, height, ApiHelper.SetWindowPosNoZorder | ApiHelper.SetWindowPosShowWindow);\n\n            // Wait for 1000ms after resize\n            Task.Delay(1000).Wait();\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public static Color GetPixelColor(int x, int y)\n        {\n            IntPtr hdc = ApiHelper.GetDC(IntPtr.Zero);\n            uint pixel = ApiHelper.GetPixel(hdc, x, y);\n            _ = ApiHelper.ReleaseDC(IntPtr.Zero, hdc);\n\n            int r = (int)(pixel & 0x000000FF);\n            int g = (int)((pixel & 0x0000FF00) >> 8);\n            int b = (int)((pixel & 0x00FF0000) >> 16);\n\n            return Color.FromArgb(r, g, b);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates as a string.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public static string GetPixelColorString(int x, int y)\n        {\n            Color color = WindowHelper.GetPixelColor(x, y);\n            return $\"#{color.R:X2}{color.G:X2}{color.B:X2}\";\n        }\n\n        /// <summary>\n        /// Gets the size of the display.\n        /// </summary>\n        /// <returns>\n        /// A tuple containing the width and height of the display.\n        /// </returns\n        public static Tuple<int, int> GetDisplaySize()\n        {\n            IntPtr hdc = ApiHelper.GetDC(IntPtr.Zero);\n            int screenWidth = ApiHelper.GetDeviceCaps(hdc, ApiHelper.DESKTOPHORZRES);\n            int screenHeight = ApiHelper.GetDeviceCaps(hdc, ApiHelper.DESKTOPVERTRES);\n            _ = ApiHelper.ReleaseDC(IntPtr.Zero, hdc);\n\n            return Tuple.Create(screenWidth, screenHeight);\n        }\n\n        public static bool IsWindowOpen(string windowName)\n        {\n            var matchingWindows = ApiHelper.FindDesktopWindowHandler([windowName, AdministratorPrefix + windowName]);\n            return matchingWindows.Count > 0;\n        }\n\n        internal static class ApiHelper\n        {\n            [DllImport(\"user32.dll\")]\n            public static extern bool SetForegroundWindow(IntPtr hWnd);\n\n            public const uint SetWindowPosNoMove = 0x0002;\n            public const uint SetWindowPosNoZorder = 0x0004;\n            public const uint SetWindowPosShowWindow = 0x0040;\n\n            [DllImport(\"user32.dll\", SetLastError = true)]\n            public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int x, int y, int cx, int cy, uint uFlags);\n\n            // Delegate for the EnumWindows callback function\n            private delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);\n\n            // P/Invoke declaration for EnumWindows\n            [DllImport(\"user32.dll\")]\n            [return: MarshalAs(UnmanagedType.Bool)]\n            private static extern bool EnumWindows(EnumWindowsProc lpEnumFunc, IntPtr lParam);\n\n            // P/Invoke declaration for GetWindowTextLength\n            [DllImport(\"user32.dll\", SetLastError = true, CharSet = CharSet.Auto)]\n            private static extern int GetWindowTextLength(IntPtr hWnd);\n\n            // P/Invoke declaration for GetWindowText\n            [DllImport(\"user32.dll\", SetLastError = true, CharSet = CharSet.Auto)]\n            private static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);\n\n            [DllImport(\"user32.dll\")]\n            public static extern IntPtr GetDC(IntPtr hWnd);\n\n            [DllImport(\"gdi32.dll\")]\n            public static extern uint GetPixel(IntPtr hdc, int x, int y);\n\n            [DllImport(\"gdi32.dll\")]\n            public static extern int GetDeviceCaps(IntPtr hdc, int nIndex);\n\n            public const int DESKTOPHORZRES = 118;\n            public const int DESKTOPVERTRES = 117;\n\n            [DllImport(\"user32.dll\")]\n            public static extern int ReleaseDC(IntPtr hWnd, IntPtr hDC);\n\n            // Define the Win32 RECT structure\n            [StructLayout(LayoutKind.Sequential)]\n            public struct RECT\n            {\n                public int Left;    // X coordinate of the left edge of the window\n                public int Top;     // Y coordinate of the top edge of the window\n                public int Right;   // X coordinate of the right edge of the window\n                public int Bottom;  // Y coordinate of the bottom edge of the window\n            }\n\n            // Import GetWindowRect API to retrieve window's screen coordinates\n            [DllImport(\"user32.dll\")]\n            public static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);\n\n            public static List<(IntPtr HWnd, string Title)> FindDesktopWindowHandler(string[] matchingWindowsTitles)\n            {\n                var windows = new List<(IntPtr HWnd, string Title)>();\n\n                _ = EnumWindows(\n                    (hWnd, lParam) =>\n                    {\n                        int length = GetWindowTextLength(hWnd);\n                        if (length > 0)\n                        {\n                            var builder = new StringBuilder(length + 1);\n                            _ = GetWindowText(hWnd, builder, builder.Capacity);\n\n                            var title = builder.ToString();\n                            if (matchingWindowsTitles.Contains(title))\n                            {\n                                windows.Add((hWnd, title));\n                            }\n                        }\n\n                        return true; // Continue enumeration\n                    },\n                    IntPtr.Zero);\n\n                return windows;\n            }\n\n            /// <summary>\n            /// Get the center point coordinates of a specified window (in screen coordinates)\n            /// </summary>\n            /// <param name=\"hWnd\">The window handle</param>\n            /// <returns>The center point (x, y)</returns>\n            public static (int CenterX, int CenterY) GetWindowCenter(IntPtr hWnd)\n            {\n                if (hWnd == IntPtr.Zero)\n                {\n                    throw new ArgumentException(\"Invalid window handle\");\n                }\n\n                if (GetWindowRect(hWnd, out RECT rect))\n                {\n                    int width = rect.Right - rect.Left;\n                    int height = rect.Bottom - rect.Top;\n\n                    int centerX = rect.Left + (width / 2);\n                    int centerY = rect.Top + (height / 2);\n\n                    return (centerX, centerY);\n                }\n                else\n                {\n                    throw new InvalidOperationException(\"Failed to retrieve window coordinates\");\n                }\n            }\n\n            public static (int Left, int Top, int Right, int Bottom) GetWindowRect(IntPtr hWnd)\n            {\n                if (hWnd == IntPtr.Zero)\n                {\n                    throw new ArgumentException(\"Invalid window handle\");\n                }\n\n                if (GetWindowRect(hWnd, out RECT rect))\n                {\n                    return (rect.Left, rect.Top, rect.Right, rect.Bottom);\n                }\n                else\n                {\n                    throw new InvalidOperationException(\"Failed to retrieve window coordinates\");\n                }\n            }\n\n            [DllImport(\"user32.dll\")]\n            public static extern int GetSystemMetrics(int nIndex);\n\n            public enum SystemMetric\n            {\n                ScreenWidth = 0,            // Width of the primary screen in pixels (SM_CXSCREEN)\n                ScreenHeight = 1,           // Height of the primary screen in pixels (SM_CYSCREEN)\n                VirtualScreenWidth = 78,    // Width of the virtual screen that includes all monitors (SM_CXVIRTUALSCREEN)\n                VirtualScreenHeight = 79,   // Height of the virtual screen that includes all monitors (SM_CYVIRTUALSCREEN)\n                MonitorCount = 80,          // Number of display monitors (SM_CMONITORS, available on Windows XP+)\n            }\n\n            public static (int CenterX, int CenterY) GetScreenCenter()\n            {\n                int width = GetSystemMetrics((int)SystemMetric.ScreenWidth);\n                int height = GetSystemMetrics((int)SystemMetric.ScreenHeight);\n\n                return (width / 2, height / 2);\n            }\n        }\n    }\n}\n"
      },
      {
        "instruction": "string 반환 타입의 GetPixelColorString 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    internal static class WindowHelper\n    {\n        internal const string AdministratorPrefix = \"Administrator: \";\n\n        /// <summary>\n        /// Sets the main window size.\n        /// </summary>\n        /// <param name=\"size\">WindowSize enum</param>\n        public static void SetWindowSize(IntPtr windowHandler, WindowSize size)\n        {\n            if (size == WindowSize.UnSpecified)\n            {\n                return;\n            }\n\n            int width = 0, height = 0;\n\n            switch (size)\n            {\n                case WindowSize.Small:\n                    width = 640;\n                    height = 480;\n                    break;\n                case WindowSize.Small_Vertical:\n                    width = 480;\n                    height = 640;\n                    break;\n                case WindowSize.Medium:\n                    width = 1024;\n                    height = 768;\n                    break;\n                case WindowSize.Medium_Vertical:\n                    width = 768;\n                    height = 1024;\n                    break;\n                case WindowSize.Large:\n                    width = 1920;\n                    height = 1080;\n                    break;\n                case WindowSize.Large_Vertical:\n                    width = 1080;\n                    height = 1920;\n                    break;\n            }\n\n            if (width > 0 && height > 0)\n            {\n                WindowHelper.SetMainWindowSize(windowHandler, width, height);\n            }\n        }\n\n        /// <summary>\n        /// Gets the main window center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public static (int CenterX, int CenterY) GetWindowCenter(IntPtr windowHandler)\n        {\n            if (windowHandler == IntPtr.Zero)\n            {\n                return (0, 0);\n            }\n            else\n            {\n                var rect = ApiHelper.GetWindowCenter(windowHandler);\n                return (rect.CenterX, rect.CenterY);\n            }\n        }\n\n        /// <summary>\n        /// Gets the main window center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public static (int Left, int Top, int Right, int Bottom) GetWindowRect(IntPtr windowHandler)\n        {\n            if (windowHandler == IntPtr.Zero)\n            {\n                return (0, 0, 0, 0);\n            }\n            else\n            {\n                var rect = ApiHelper.GetWindowRect(windowHandler);\n                return (rect.Left, rect.Top, rect.Right, rect.Bottom);\n            }\n        }\n\n        /// <summary>\n        /// Gets the screen center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public static (int CenterX, int CenterY) GetScreenCenter()\n        {\n            return ApiHelper.GetScreenCenter();\n        }\n\n        /// <summary>\n        /// Sets the main window size based on Width and Height.\n        /// </summary>\n        /// <param name=\"width\">the width in pixel</param>\n        /// <param name=\"height\">the height in pixel</param>\n        public static void SetMainWindowSize(IntPtr windowHandler, int width, int height)\n        {\n            if (windowHandler == IntPtr.Zero\n                || width <= 0\n                || height <= 0)\n            {\n                return;\n            }\n\n            ApiHelper.SetWindowPos(windowHandler, IntPtr.Zero, 0, 0, width, height, ApiHelper.SetWindowPosNoZorder | ApiHelper.SetWindowPosShowWindow);\n\n            // Wait for 1000ms after resize\n            Task.Delay(1000).Wait();\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public static Color GetPixelColor(int x, int y)\n        {\n            IntPtr hdc = ApiHelper.GetDC(IntPtr.Zero);\n            uint pixel = ApiHelper.GetPixel(hdc, x, y);\n            _ = ApiHelper.ReleaseDC(IntPtr.Zero, hdc);\n\n            int r = (int)(pixel & 0x000000FF);\n            int g = (int)((pixel & 0x0000FF00) >> 8);\n            int b = (int)((pixel & 0x00FF0000) >> 16);\n\n            return Color.FromArgb(r, g, b);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates as a string.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public static string GetPixelColorString(int x, int y)\n        {\n            Color color = WindowHelper.GetPixelColor(x, y);\n            return $\"#{color.R:X2}{color.G:X2}{color.B:X2}\";\n        }\n\n        /// <summary>\n        /// Gets the size of the display.\n        /// </summary>\n        /// <returns>\n        /// A tuple containing the width and height of the display.\n        /// </returns\n        public static Tuple<int, int> GetDisplaySize()\n        {\n            IntPtr hdc = ApiHelper.GetDC(IntPtr.Zero);\n            int screenWidth = ApiHelper.GetDeviceCaps(hdc, ApiHelper.DESKTOPHORZRES);\n            int screenHeight = ApiHelper.GetDeviceCaps(hdc, ApiHelper.DESKTOPVERTRES);\n            _ = ApiHelper.ReleaseDC(IntPtr.Zero, hdc);\n\n            return Tuple.Create(screenWidth, screenHeight);\n        }\n\n        public static bool IsWindowOpen(string windowName)\n        {\n            var matchingWindows = ApiHelper.FindDesktopWindowHandler([windowName, AdministratorPrefix + windowName]);\n            return matchingWindows.Count > 0;\n        }\n\n        internal static class ApiHelper\n        {\n            [DllImport(\"user32.dll\")]\n            public static extern bool SetForegroundWindow(IntPtr hWnd);\n\n            public const uint SetWindowPosNoMove = 0x0002;\n            public const uint SetWindowPosNoZorder = 0x0004;\n            public const uint SetWindowPosShowWindow = 0x0040;\n\n            [DllImport(\"user32.dll\", SetLastError = true)]\n            public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int x, int y, int cx, int cy, uint uFlags);\n\n            // Delegate for the EnumWindows callback function\n            private delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);\n\n            // P/Invoke declaration for EnumWindows\n            [DllImport(\"user32.dll\")]\n            [return: MarshalAs(UnmanagedType.Bool)]\n            private static extern bool EnumWindows(EnumWindowsProc lpEnumFunc, IntPtr lParam);\n\n            // P/Invoke declaration for GetWindowTextLength\n            [DllImport(\"user32.dll\", SetLastError = true, CharSet = CharSet.Auto)]\n            private static extern int GetWindowTextLength(IntPtr hWnd);\n\n            // P/Invoke declaration for GetWindowText\n            [DllImport(\"user32.dll\", SetLastError = true, CharSet = CharSet.Auto)]\n            private static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);\n\n            [DllImport(\"user32.dll\")]\n            public static extern IntPtr GetDC(IntPtr hWnd);\n\n            [DllImport(\"gdi32.dll\")]\n            public static extern uint GetPixel(IntPtr hdc, int x, int y);\n\n            [DllImport(\"gdi32.dll\")]\n            public static extern int GetDeviceCaps(IntPtr hdc, int nIndex);\n\n            public const int DESKTOPHORZRES = 118;\n            public const int DESKTOPVERTRES = 117;\n\n            [DllImport(\"user32.dll\")]\n            public static extern int ReleaseDC(IntPtr hWnd, IntPtr hDC);\n\n            // Define the Win32 RECT structure\n            [StructLayout(LayoutKind.Sequential)]\n            public struct RECT\n            {\n                public int Left;    // X coordinate of the left edge of the window\n                public int Top;     // Y coordinate of the top edge of the window\n                public int Right;   // X coordinate of the right edge of the window\n                public int Bottom;  // Y coordinate of the bottom edge of the window\n            }\n\n            // Import GetWindowRect API to retrieve window's screen coordinates\n            [DllImport(\"user32.dll\")]\n            public static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);\n\n            public static List<(IntPtr HWnd, string Title)> FindDesktopWindowHandler(string[] matchingWindowsTitles)\n            {\n                var windows = new List<(IntPtr HWnd, string Title)>();\n\n                _ = EnumWindows(\n                    (hWnd, lParam) =>\n                    {\n                        int length = GetWindowTextLength(hWnd);\n                        if (length > 0)\n                        {\n                            var builder = new StringBuilder(length + 1);\n                            _ = GetWindowText(hWnd, builder, builder.Capacity);\n\n                            var title = builder.ToString();\n                            if (matchingWindowsTitles.Contains(title))\n                            {\n                                windows.Add((hWnd, title));\n                            }\n                        }\n\n                        return true; // Continue enumeration\n                    },\n                    IntPtr.Zero);\n\n                return windows;\n            }\n\n            /// <summary>\n            /// Get the center point coordinates of a specified window (in screen coordinates)\n            /// </summary>\n            /// <param name=\"hWnd\">The window handle</param>\n            /// <returns>The center point (x, y)</returns>\n            public static (int CenterX, int CenterY) GetWindowCenter(IntPtr hWnd)\n            {\n                if (hWnd == IntPtr.Zero)\n                {\n                    throw new ArgumentException(\"Invalid window handle\");\n                }\n\n                if (GetWindowRect(hWnd, out RECT rect))\n                {\n                    int width = rect.Right - rect.Left;\n                    int height = rect.Bottom - rect.Top;\n\n                    int centerX = rect.Left + (width / 2);\n                    int centerY = rect.Top + (height / 2);\n\n                    return (centerX, centerY);\n                }\n                else\n                {\n                    throw new InvalidOperationException(\"Failed to retrieve window coordinates\");\n                }\n            }\n\n            public static (int Left, int Top, int Right, int Bottom) GetWindowRect(IntPtr hWnd)\n            {\n                if (hWnd == IntPtr.Zero)\n                {\n                    throw new ArgumentException(\"Invalid window handle\");\n                }\n\n                if (GetWindowRect(hWnd, out RECT rect))\n                {\n                    return (rect.Left, rect.Top, rect.Right, rect.Bottom);\n                }\n                else\n                {\n                    throw new InvalidOperationException(\"Failed to retrieve window coordinates\");\n                }\n            }\n\n            [DllImport(\"user32.dll\")]\n            public static extern int GetSystemMetrics(int nIndex);\n\n            public enum SystemMetric\n            {\n                ScreenWidth = 0,            // Width of the primary screen in pixels (SM_CXSCREEN)\n                ScreenHeight = 1,           // Height of the primary screen in pixels (SM_CYSCREEN)\n                VirtualScreenWidth = 78,    // Width of the virtual screen that includes all monitors (SM_CXVIRTUALSCREEN)\n                VirtualScreenHeight = 79,   // Height of the virtual screen that includes all monitors (SM_CYVIRTUALSCREEN)\n                MonitorCount = 80,          // Number of display monitors (SM_CMONITORS, available on Windows XP+)\n            }\n\n            public static (int CenterX, int CenterY) GetScreenCenter()\n            {\n                int width = GetSystemMetrics((int)SystemMetric.ScreenWidth);\n                int height = GetSystemMetrics((int)SystemMetric.ScreenHeight);\n\n                return (width / 2, height / 2);\n            }\n        }\n    }\n}\n"
      },
      {
        "instruction": "bool 반환 타입의 IsWindowOpen 메서드를 구현해주세요.",
        "context": "엔터프라이즈 수준의 에러 처리와 로깅을 포함해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    internal static class WindowHelper\n    {\n        internal const string AdministratorPrefix = \"Administrator: \";\n\n        /// <summary>\n        /// Sets the main window size.\n        /// </summary>\n        /// <param name=\"size\">WindowSize enum</param>\n        public static void SetWindowSize(IntPtr windowHandler, WindowSize size)\n        {\n            if (size == WindowSize.UnSpecified)\n            {\n                return;\n            }\n\n            int width = 0, height = 0;\n\n            switch (size)\n            {\n                case WindowSize.Small:\n                    width = 640;\n                    height = 480;\n                    break;\n                case WindowSize.Small_Vertical:\n                    width = 480;\n                    height = 640;\n                    break;\n                case WindowSize.Medium:\n                    width = 1024;\n                    height = 768;\n                    break;\n                case WindowSize.Medium_Vertical:\n                    width = 768;\n                    height = 1024;\n                    break;\n                case WindowSize.Large:\n                    width = 1920;\n                    height = 1080;\n                    break;\n                case WindowSize.Large_Vertical:\n                    width = 1080;\n                    height = 1920;\n                    break;\n            }\n\n            if (width > 0 && height > 0)\n            {\n                WindowHelper.SetMainWindowSize(windowHandler, width, height);\n            }\n        }\n\n        /// <summary>\n        /// Gets the main window center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public static (int CenterX, int CenterY) GetWindowCenter(IntPtr windowHandler)\n        {\n            if (windowHandler == IntPtr.Zero)\n            {\n                return (0, 0);\n            }\n            else\n            {\n                var rect = ApiHelper.GetWindowCenter(windowHandler);\n                return (rect.CenterX, rect.CenterY);\n            }\n        }\n\n        /// <summary>\n        /// Gets the main window center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public static (int Left, int Top, int Right, int Bottom) GetWindowRect(IntPtr windowHandler)\n        {\n            if (windowHandler == IntPtr.Zero)\n            {\n                return (0, 0, 0, 0);\n            }\n            else\n            {\n                var rect = ApiHelper.GetWindowRect(windowHandler);\n                return (rect.Left, rect.Top, rect.Right, rect.Bottom);\n            }\n        }\n\n        /// <summary>\n        /// Gets the screen center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public static (int CenterX, int CenterY) GetScreenCenter()\n        {\n            return ApiHelper.GetScreenCenter();\n        }\n\n        /// <summary>\n        /// Sets the main window size based on Width and Height.\n        /// </summary>\n        /// <param name=\"width\">the width in pixel</param>\n        /// <param name=\"height\">the height in pixel</param>\n        public static void SetMainWindowSize(IntPtr windowHandler, int width, int height)\n        {\n            if (windowHandler == IntPtr.Zero\n                || width <= 0\n                || height <= 0)\n            {\n                return;\n            }\n\n            ApiHelper.SetWindowPos(windowHandler, IntPtr.Zero, 0, 0, width, height, ApiHelper.SetWindowPosNoZorder | ApiHelper.SetWindowPosShowWindow);\n\n            // Wait for 1000ms after resize\n            Task.Delay(1000).Wait();\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public static Color GetPixelColor(int x, int y)\n        {\n            IntPtr hdc = ApiHelper.GetDC(IntPtr.Zero);\n            uint pixel = ApiHelper.GetPixel(hdc, x, y);\n            _ = ApiHelper.ReleaseDC(IntPtr.Zero, hdc);\n\n            int r = (int)(pixel & 0x000000FF);\n            int g = (int)((pixel & 0x0000FF00) >> 8);\n            int b = (int)((pixel & 0x00FF0000) >> 16);\n\n            return Color.FromArgb(r, g, b);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates as a string.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public static string GetPixelColorString(int x, int y)\n        {\n            Color color = WindowHelper.GetPixelColor(x, y);\n            return $\"#{color.R:X2}{color.G:X2}{color.B:X2}\";\n        }\n\n        /// <summary>\n        /// Gets the size of the display.\n        /// </summary>\n        /// <returns>\n        /// A tuple containing the width and height of the display.\n        /// </returns\n        public static Tuple<int, int> GetDisplaySize()\n        {\n            IntPtr hdc = ApiHelper.GetDC(IntPtr.Zero);\n            int screenWidth = ApiHelper.GetDeviceCaps(hdc, ApiHelper.DESKTOPHORZRES);\n            int screenHeight = ApiHelper.GetDeviceCaps(hdc, ApiHelper.DESKTOPVERTRES);\n            _ = ApiHelper.ReleaseDC(IntPtr.Zero, hdc);\n\n            return Tuple.Create(screenWidth, screenHeight);\n        }\n\n        public static bool IsWindowOpen(string windowName)\n        {\n            var matchingWindows = ApiHelper.FindDesktopWindowHandler([windowName, AdministratorPrefix + windowName]);\n            return matchingWindows.Count > 0;\n        }\n\n        internal static class ApiHelper\n        {\n            [DllImport(\"user32.dll\")]\n            public static extern bool SetForegroundWindow(IntPtr hWnd);\n\n            public const uint SetWindowPosNoMove = 0x0002;\n            public const uint SetWindowPosNoZorder = 0x0004;\n            public const uint SetWindowPosShowWindow = 0x0040;\n\n            [DllImport(\"user32.dll\", SetLastError = true)]\n            public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int x, int y, int cx, int cy, uint uFlags);\n\n            // Delegate for the EnumWindows callback function\n            private delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);\n\n            // P/Invoke declaration for EnumWindows\n            [DllImport(\"user32.dll\")]\n            [return: MarshalAs(UnmanagedType.Bool)]\n            private static extern bool EnumWindows(EnumWindowsProc lpEnumFunc, IntPtr lParam);\n\n            // P/Invoke declaration for GetWindowTextLength\n            [DllImport(\"user32.dll\", SetLastError = true, CharSet = CharSet.Auto)]\n            private static extern int GetWindowTextLength(IntPtr hWnd);\n\n            // P/Invoke declaration for GetWindowText\n            [DllImport(\"user32.dll\", SetLastError = true, CharSet = CharSet.Auto)]\n            private static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);\n\n            [DllImport(\"user32.dll\")]\n            public static extern IntPtr GetDC(IntPtr hWnd);\n\n            [DllImport(\"gdi32.dll\")]\n            public static extern uint GetPixel(IntPtr hdc, int x, int y);\n\n            [DllImport(\"gdi32.dll\")]\n            public static extern int GetDeviceCaps(IntPtr hdc, int nIndex);\n\n            public const int DESKTOPHORZRES = 118;\n            public const int DESKTOPVERTRES = 117;\n\n            [DllImport(\"user32.dll\")]\n            public static extern int ReleaseDC(IntPtr hWnd, IntPtr hDC);\n\n            // Define the Win32 RECT structure\n            [StructLayout(LayoutKind.Sequential)]\n            public struct RECT\n            {\n                public int Left;    // X coordinate of the left edge of the window\n                public int Top;     // Y coordinate of the top edge of the window\n                public int Right;   // X coordinate of the right edge of the window\n                public int Bottom;  // Y coordinate of the bottom edge of the window\n            }\n\n            // Import GetWindowRect API to retrieve window's screen coordinates\n            [DllImport(\"user32.dll\")]\n            public static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);\n\n            public static List<(IntPtr HWnd, string Title)> FindDesktopWindowHandler(string[] matchingWindowsTitles)\n            {\n                var windows = new List<(IntPtr HWnd, string Title)>();\n\n                _ = EnumWindows(\n                    (hWnd, lParam) =>\n                    {\n                        int length = GetWindowTextLength(hWnd);\n                        if (length > 0)\n                        {\n                            var builder = new StringBuilder(length + 1);\n                            _ = GetWindowText(hWnd, builder, builder.Capacity);\n\n                            var title = builder.ToString();\n                            if (matchingWindowsTitles.Contains(title))\n                            {\n                                windows.Add((hWnd, title));\n                            }\n                        }\n\n                        return true; // Continue enumeration\n                    },\n                    IntPtr.Zero);\n\n                return windows;\n            }\n\n            /// <summary>\n            /// Get the center point coordinates of a specified window (in screen coordinates)\n            /// </summary>\n            /// <param name=\"hWnd\">The window handle</param>\n            /// <returns>The center point (x, y)</returns>\n            public static (int CenterX, int CenterY) GetWindowCenter(IntPtr hWnd)\n            {\n                if (hWnd == IntPtr.Zero)\n                {\n                    throw new ArgumentException(\"Invalid window handle\");\n                }\n\n                if (GetWindowRect(hWnd, out RECT rect))\n                {\n                    int width = rect.Right - rect.Left;\n                    int height = rect.Bottom - rect.Top;\n\n                    int centerX = rect.Left + (width / 2);\n                    int centerY = rect.Top + (height / 2);\n\n                    return (centerX, centerY);\n                }\n                else\n                {\n                    throw new InvalidOperationException(\"Failed to retrieve window coordinates\");\n                }\n            }\n\n            public static (int Left, int Top, int Right, int Bottom) GetWindowRect(IntPtr hWnd)\n            {\n                if (hWnd == IntPtr.Zero)\n                {\n                    throw new ArgumentException(\"Invalid window handle\");\n                }\n\n                if (GetWindowRect(hWnd, out RECT rect))\n                {\n                    return (rect.Left, rect.Top, rect.Right, rect.Bottom);\n                }\n                else\n                {\n                    throw new InvalidOperationException(\"Failed to retrieve window coordinates\");\n                }\n            }\n\n            [DllImport(\"user32.dll\")]\n            public static extern int GetSystemMetrics(int nIndex);\n\n            public enum SystemMetric\n            {\n                ScreenWidth = 0,            // Width of the primary screen in pixels (SM_CXSCREEN)\n                ScreenHeight = 1,           // Height of the primary screen in pixels (SM_CYSCREEN)\n                VirtualScreenWidth = 78,    // Width of the virtual screen that includes all monitors (SM_CXVIRTUALSCREEN)\n                VirtualScreenHeight = 79,   // Height of the virtual screen that includes all monitors (SM_CYVIRTUALSCREEN)\n                MonitorCount = 80,          // Number of display monitors (SM_CMONITORS, available on Windows XP+)\n            }\n\n            public static (int CenterX, int CenterY) GetScreenCenter()\n            {\n                int width = GetSystemMetrics((int)SystemMetric.ScreenWidth);\n                int height = GetSystemMetrics((int)SystemMetric.ScreenHeight);\n\n                return (width / 2, height / 2);\n            }\n        }\n    }\n}\n"
      },
      {
        "instruction": "Factory 패턴을 사용하는 C# 코드를 작성해주세요.",
        "context": "프로덕션 환경에서 사용 가능한 수준으로 작성해주세요.",
        "output": "﻿// Copyright (c) Microsoft Corporation\n// The Microsoft Corporation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Microsoft.PowerToys.UITest\n{\n    internal static class WindowHelper\n    {\n        internal const string AdministratorPrefix = \"Administrator: \";\n\n        /// <summary>\n        /// Sets the main window size.\n        /// </summary>\n        /// <param name=\"size\">WindowSize enum</param>\n        public static void SetWindowSize(IntPtr windowHandler, WindowSize size)\n        {\n            if (size == WindowSize.UnSpecified)\n            {\n                return;\n            }\n\n            int width = 0, height = 0;\n\n            switch (size)\n            {\n                case WindowSize.Small:\n                    width = 640;\n                    height = 480;\n                    break;\n                case WindowSize.Small_Vertical:\n                    width = 480;\n                    height = 640;\n                    break;\n                case WindowSize.Medium:\n                    width = 1024;\n                    height = 768;\n                    break;\n                case WindowSize.Medium_Vertical:\n                    width = 768;\n                    height = 1024;\n                    break;\n                case WindowSize.Large:\n                    width = 1920;\n                    height = 1080;\n                    break;\n                case WindowSize.Large_Vertical:\n                    width = 1080;\n                    height = 1920;\n                    break;\n            }\n\n            if (width > 0 && height > 0)\n            {\n                WindowHelper.SetMainWindowSize(windowHandler, width, height);\n            }\n        }\n\n        /// <summary>\n        /// Gets the main window center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public static (int CenterX, int CenterY) GetWindowCenter(IntPtr windowHandler)\n        {\n            if (windowHandler == IntPtr.Zero)\n            {\n                return (0, 0);\n            }\n            else\n            {\n                var rect = ApiHelper.GetWindowCenter(windowHandler);\n                return (rect.CenterX, rect.CenterY);\n            }\n        }\n\n        /// <summary>\n        /// Gets the main window center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public static (int Left, int Top, int Right, int Bottom) GetWindowRect(IntPtr windowHandler)\n        {\n            if (windowHandler == IntPtr.Zero)\n            {\n                return (0, 0, 0, 0);\n            }\n            else\n            {\n                var rect = ApiHelper.GetWindowRect(windowHandler);\n                return (rect.Left, rect.Top, rect.Right, rect.Bottom);\n            }\n        }\n\n        /// <summary>\n        /// Gets the screen center coordinates.\n        /// </summary>\n        /// <returns>(x, y)</returns>\n        public static (int CenterX, int CenterY) GetScreenCenter()\n        {\n            return ApiHelper.GetScreenCenter();\n        }\n\n        /// <summary>\n        /// Sets the main window size based on Width and Height.\n        /// </summary>\n        /// <param name=\"width\">the width in pixel</param>\n        /// <param name=\"height\">the height in pixel</param>\n        public static void SetMainWindowSize(IntPtr windowHandler, int width, int height)\n        {\n            if (windowHandler == IntPtr.Zero\n                || width <= 0\n                || height <= 0)\n            {\n                return;\n            }\n\n            ApiHelper.SetWindowPos(windowHandler, IntPtr.Zero, 0, 0, width, height, ApiHelper.SetWindowPosNoZorder | ApiHelper.SetWindowPosShowWindow);\n\n            // Wait for 1000ms after resize\n            Task.Delay(1000).Wait();\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public static Color GetPixelColor(int x, int y)\n        {\n            IntPtr hdc = ApiHelper.GetDC(IntPtr.Zero);\n            uint pixel = ApiHelper.GetPixel(hdc, x, y);\n            _ = ApiHelper.ReleaseDC(IntPtr.Zero, hdc);\n\n            int r = (int)(pixel & 0x000000FF);\n            int g = (int)((pixel & 0x0000FF00) >> 8);\n            int b = (int)((pixel & 0x00FF0000) >> 16);\n\n            return Color.FromArgb(r, g, b);\n        }\n\n        /// <summary>\n        /// Retrieves the color of the pixel at the specified screen coordinates as a string.\n        /// </summary>\n        /// <param name=\"x\">The X coordinate on the screen.</param>\n        /// <param name=\"y\">The Y coordinate on the screen.</param>\n        /// <returns>The color of the pixel at the specified coordinates.</returns>\n        public static string GetPixelColorString(int x, int y)\n        {\n            Color color = WindowHelper.GetPixelColor(x, y);\n            return $\"#{color.R:X2}{color.G:X2}{color.B:X2}\";\n        }\n\n        /// <summary>\n        /// Gets the size of the display.\n        /// </summary>\n        /// <returns>\n        /// A tuple containing the width and height of the display.\n        /// </returns\n        public static Tuple<int, int> GetDisplaySize()\n        {\n            IntPtr hdc = ApiHelper.GetDC(IntPtr.Zero);\n            int screenWidth = ApiHelper.GetDeviceCaps(hdc, ApiHelper.DESKTOPHORZRES);\n            int screenHeight = ApiHelper.GetDeviceCaps(hdc, ApiHelper.DESKTOPVERTRES);\n            _ = ApiHelper.ReleaseDC(IntPtr.Zero, hdc);\n\n            return Tuple.Create(screenWidth, screenHeight);\n        }\n\n        public static bool IsWindowOpen(string windowName)\n        {\n            var matchingWindows = ApiHelper.FindDesktopWindowHandler([windowName, AdministratorPrefix + windowName]);\n            return matchingWindows.Count > 0;\n        }\n\n        internal static class ApiHelper\n        {\n            [DllImport(\"user32.dll\")]\n            public static extern bool SetForegroundWindow(IntPtr hWnd);\n\n            public const uint SetWindowPosNoMove = 0x0002;\n            public const uint SetWindowPosNoZorder = 0x0004;\n            public const uint SetWindowPosShowWindow = 0x0040;\n\n            [DllImport(\"user32.dll\", SetLastError = true)]\n            public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int x, int y, int cx, int cy, uint uFlags);\n\n            // Delegate for the EnumWindows callback function\n            private delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);\n\n            // P/Invoke declaration for EnumWindows\n            [DllImport(\"user32.dll\")]\n            [return: MarshalAs(UnmanagedType.Bool)]\n            private static extern bool EnumWindows(EnumWindowsProc lpEnumFunc, IntPtr lParam);\n\n            // P/Invoke declaration for GetWindowTextLength\n            [DllImport(\"user32.dll\", SetLastError = true, CharSet = CharSet.Auto)]\n            private static extern int GetWindowTextLength(IntPtr hWnd);\n\n            // P/Invoke declaration for GetWindowText\n            [DllImport(\"user32.dll\", SetLastError = true, CharSet = CharSet.Auto)]\n            private static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);\n\n            [DllImport(\"user32.dll\")]\n            public static extern IntPtr GetDC(IntPtr hWnd);\n\n            [DllImport(\"gdi32.dll\")]\n            public static extern uint GetPixel(IntPtr hdc, int x, int y);\n\n            [DllImport(\"gdi32.dll\")]\n            public static extern int GetDeviceCaps(IntPtr hdc, int nIndex);\n\n            public const int DESKTOPHORZRES = 118;\n            public const int DESKTOPVERTRES = 117;\n\n            [DllImport(\"user32.dll\")]\n            public static extern int ReleaseDC(IntPtr hWnd, IntPtr hDC);\n\n            // Define the Win32 RECT structure\n            [StructLayout(LayoutKind.Sequential)]\n            public struct RECT\n            {\n                public int Left;    // X coordinate of the left edge of the window\n                public int Top;     // Y coordinate of the top edge of the window\n                public int Right;   // X coordinate of the right edge of the window\n                public int Bottom;  // Y coordinate of the bottom edge of the window\n            }\n\n            // Import GetWindowRect API to retrieve window's screen coordinates\n            [DllImport(\"user32.dll\")]\n            public static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);\n\n            public static List<(IntPtr HWnd, string Title)> FindDesktopWindowHandler(string[] matchingWindowsTitles)\n            {\n                var windows = new List<(IntPtr HWnd, string Title)>();\n\n                _ = EnumWindows(\n                    (hWnd, lParam) =>\n                    {\n                        int length = GetWindowTextLength(hWnd);\n                        if (length > 0)\n                        {\n                            var builder = new StringBuilder(length + 1);\n                            _ = GetWindowText(hWnd, builder, builder.Capacity);\n\n                            var title = builder.ToString();\n                            if (matchingWindowsTitles.Contains(title))\n                            {\n                                windows.Add((hWnd, title));\n                            }\n                        }\n\n                        return true; // Continue enumeration\n                    },\n                    IntPtr.Zero);\n\n                return windows;\n            }\n\n            /// <summary>\n            /// Get the center point coordinates of a specified window (in screen coordinates)\n            /// </summary>\n            /// <param name=\"hWnd\">The window handle</param>\n            /// <returns>The center point (x, y)</returns>\n            public static (int CenterX, int CenterY) GetWindowCenter(IntPtr hWnd)\n            {\n                if (hWnd == IntPtr.Zero)\n                {\n                    throw new ArgumentException(\"Invalid window handle\");\n                }\n\n                if (GetWindowRect(hWnd, out RECT rect))\n                {\n                    int width = rect.Right - rect.Left;\n                    int height = rect.Bottom - rect.Top;\n\n                    int centerX = rect.Left + (width / 2);\n                    int centerY = rect.Top + (height / 2);\n\n                    return (centerX, centerY);\n                }\n                else\n                {\n                    throw new InvalidOperationException(\"Failed to retrieve window coordinates\");\n                }\n            }\n\n            public static (int Left, int Top, int Right, int Bottom) GetWindowRect(IntPtr hWnd)\n            {\n                if (hWnd == IntPtr.Zero)\n                {\n                    throw new ArgumentException(\"Invalid window handle\");\n                }\n\n                if (GetWindowRect(hWnd, out RECT rect))\n                {\n                    return (rect.Left, rect.Top, rect.Right, rect.Bottom);\n                }\n                else\n                {\n                    throw new InvalidOperationException(\"Failed to retrieve window coordinates\");\n                }\n            }\n\n            [DllImport(\"user32.dll\")]\n            public static extern int GetSystemMetrics(int nIndex);\n\n            public enum SystemMetric\n            {\n                ScreenWidth = 0,            // Width of the primary screen in pixels (SM_CXSCREEN)\n                ScreenHeight = 1,           // Height of the primary screen in pixels (SM_CYSCREEN)\n                VirtualScreenWidth = 78,    // Width of the virtual screen that includes all monitors (SM_CXVIRTUALSCREEN)\n                VirtualScreenHeight = 79,   // Height of the virtual screen that includes all monitors (SM_CYVIRTUALSCREEN)\n                MonitorCount = 80,          // Number of display monitors (SM_CMONITORS, available on Windows XP+)\n            }\n\n            public static (int CenterX, int CenterY) GetScreenCenter()\n            {\n                int width = GetSystemMetrics((int)SystemMetric.ScreenWidth);\n                int height = GetSystemMetrics((int)SystemMetric.ScreenHeight);\n\n                return (width / 2, height / 2);\n            }\n        }\n    }\n}\n"
      }
    ]
  }
]